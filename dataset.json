[
    {
        "example": "Photo sharing social network",
        "model": "sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {}",
        "id": "x3JXgWhJ3uti5Dzxz",
        "requirements": [
            {
                "description": "Every photo is posted by one user",
                "pred": "this/inv1",
                "oracle": "{\n\t// Every image is posted by one user.\n  all p: Photo | one (posts.p)\n\t\n}",
                "erroneous": [
                    "{\n\t// Every image is posted by one user.\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p : Photo | some u : User | p in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall x : Photo | lone posts.x\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall p: Photo, u: User | p in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all x: Photo | one x.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p: Photo | one u: User | u.posts = p\n}",
                    "{\n\t// Every image is posted by one user.\n  \tone u : User | all p : Photo | p in u.posts\n\t\n}",
                    "{\n  // Every image is posted by one user.\n  all disj u1 : User, u2 : User | no (u1.posts & u2.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n  all u : User | lone u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | one User.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User | one posts.u\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall p : Photo | lone User.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tone p: Photo, u: User | p in u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n  all x : Photo | some y : User | all z: User | y->x in posts\tand y=z\n}",
                    "{\n\t// Every image is posted by one user.\n  all u : User | one u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  one (posts.Photo)\n\t\n}",
                    "{\n  // Every image is posted by one user.\n  all user: User | some photo: Photo | photo in user.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\t\n  \tall p: Photo, u: User | one (p & u).posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p: Photo | some u: User | u.posts = p\n}",
                    "{\n\t// Every image is posted by one user.\n  all p : Photo | lone User\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tlone posts.Photo\n}",
                    "{\n\t// Every image is posted by one user.\n  one Photo.posts\n  \n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p : Photo | one User\n\t\n}",
                    "{\n\t\n\tall u : User | u.posts not in u.sees\n}",
                    "{\n\t// Every image is posted by one user.\n\tall img : Photo, ad : Ad | img in User.posts and ad in User.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p:Photo , u:User| u.posts in p\n}",
                    "{\n\t// Every image is posted by one user.\n  some p: Photo | one User.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | p in User.posts implies one User\n}",
                    "{\n\t// Every image is posted by one user.\n\tall img : Photo, ad : Ad | img in User.posts or ad in User.posts\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo | (p in User.posts) and (p not in Influencer.posts)\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u1, u2: User, p: Photo | (p in u1.posts and p in u2.posts) <=> u1 = u2\n}",
                    "{\n\t// Every image is posted by one user.\n    some (Photo & User.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo, disj u: User, i: Influencer |  p in u.posts or p in i.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo |all u: User | u.posts != none implies p in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall photo : Photo,user : User | one user.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall disj u, v: User | u.posts not in v.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u1, u2: User | u1 != u2 implies u1.posts != u2.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo, u : User, i : Influencer | lone u.posts & i.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  \tone u : User | all p : Photo | p in posts.u\n\t\n}",
                    "{\n\t\n\tone u : User |  u.posts not in u.sees\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u: User | one posts.Photo\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall p : Photo | some User.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Ad, u:User | p in u.posts\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall ph: Photo | one u: User | ph in u.sees\n}",
                    "{\n\t// Every image is posted by one user.\n\tone p: Photo | one posts.p\n}",
                    "{\n\t// Every image is posted by one user.\n  \tone u : User | all p : Photo | u.posts in p \n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u1, u2 : User | u1 != u2 implies no (u1.posts.date & u2.posts.date)\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, disj p1,p2 : u.posts | p1.date != p2.date\n}",
                    "{\n\t// Every image is posted by one user.\n  all i:Photo | some u: User | one i->u\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tposts in User lone -> some Photo\t\n}",
                    "{\n\t// Every image is posted by one user.\n  Photo - Ad in (User-Influencer).posts\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  Photo - Ad in User.posts\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall x: Photo, u: User | one posts.x\n\t\n}",
                    "{\n\t\n\tone u : User | u.posts - Photo in u.follows.posts\n}",
                    "{\n\t// Every image is posted by one user.\n    Photo in User.posts\n  \tPhoto in Influencer.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | lone (Influencer.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n  lone u: User, p: Photo | p in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  one u: User, p: Photo, a: Ad | p in u.posts or a in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall ph : Photo, u : User | ph in User.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p:Photo , u: User  | u.posts = p\n}",
                    "{\n  all x,y : User-Influencer | no (x.posts & y.posts)\n\t// Every image is posted by one user.\n}",
                    "{\n\t// Every image is posted by one user.\n\tposts in Photo some -> one User\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall p : Photo | let U = {u : User | p in u.posts } | no u2 : User, inf : \t\t\t\t\tInfluencer | p in u2.posts or p in inf.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tposts in User lone -> one Photo\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all u : User | lone Photo\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all u : User | one Photo\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p : Photo | some u : User, u2 : User - u | p in u.posts and no u2.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all u1 : User | some u2 : User - u1 | u1.posts not in u2.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  some u1 : User | all u2 : User - u1 | u1.posts not in u2.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u1, u2: User | u1 != u2 implies lone (u1.posts & u2.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u1, u2: User | u1 != u2 implies one (u1.posts & u2.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n\tall disj u0,u1: User | no (u0.posts &  u1.posts)\n  \tall p: Photo | one u:User | no posts.p\n}",
                    "{\n\t// Every image is posted by one user.\n  all p:Photo, u:User, i:Influencer | p in u.posts and p in i.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p:Photo | one u1:User | one u2:User | (p in u1.posts) implies (p not in u2.posts)\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p:Photo | one u1:User | all u2:User | (p in u1.posts) implies (p not in u2.posts)\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, i: Influencer | one (u.posts & i.posts)\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall ph : Photo, u1,u2 : User | u1 = posts.ph implies u2 != posts.ph  \t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | one posts.Photo\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, i: Influencer | lone u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, i: Influencer | lone (u.posts + i.posts)\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, disj p1,p2 : Photo | p1.date != p2.date\n}",
                    "{\n\t// Every image is posted by one user.\n  all u:User, p:Photo , others:User-u |\n \t\t(p in u.posts && p not in others.posts) or p in others.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | some u : User - Influencer | p in u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | one u : User | p in u.follows.posts\n}",
                    "{\n\t// Every image is posted by one user.\n    all u:User | one p:Photo | u.posts in p\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  \t\n\tPhoto in User.posts\n  \tall u : User | lone u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n  \tall p: Photo | lone sees.p\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tposts in User one -> some Photo\n}",
                    "{\n\t// Every image is posted by one user.\n  Photo - Ad in (User-Influencer).posts\n  Ad not in User.posts\n\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  Photo - Ad in (User-Influencer).posts\n  (User-Influencer).posts in Photo -Ad\n  \n\n\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all i : Photo - Ad | i in User.posts and i not in Influencer.posts\n\n  \n\n\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all i : User.posts| i not in Influencer.posts\n\n  \n\n\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  User.posts = Photo-Ad\n  all i : User.posts| i not in Influencer.posts\n\n  \n\n\n\n\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n \t\n  \t\n  \tall x : Photo | one posts.x\n  \tone posts.Photo\n}",
                    "{\n\t\n\tall u : User | u.posts not in u.follows.posts\n}",
                    "{\n\t\n\tall u : User | u.posts - Ad in u.follows.posts\n}",
                    "{\n\t\n\tone u : User |  u.sees not in u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u: User | some posts.Photo\n}",
                    "{\n\t// Every image is posted by one user.\n    some (Photo & User.posts) and (all x: Photo | one posts.x)\n}",
                    "{\n\t// Every image is posted by one user.\n  lone u: User, p: Photo, a: Ad | p in u.posts or a in u.posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo |one disj u: User, i: Influencer |  p in u.posts or p in i.posts \n\t\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo | one posts\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tone posts.Photo || one posts.Ad\n}",
                    "{\n\t// Every image is posted by one user.\n\tall u : User, p : Photo | some u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tall i : Influencer, u : User | \n  \t\ti != u implies i in u.follows\n}",
                    "{\n\t// Every image is posted by one user.\n  all p: Photo | all ad:Ad |  p in User.posts and ad in User.posts\n  no disj u1,u2: User | (u1.posts & u2.posts) != none \n\t\n}",
                    "{\n  all disj x,y : User-Influencer | no (x.posts & y.posts)\n\t// Every image is posted by one user.\n}",
                    "{\n\t// Every image is posted by one user.\n\tsome disj a, b: User | no (a.posts & b.posts)\n}",
                    "{\n\t// Every image is posted by one user.\n  \n\tall u:User,p:Photo, a:Ad | u -> p in posts && u -> a in posts  \n}",
                    "{\n\t// Every image is posted by one user.\n  \n\tsome p:Photo| all u:User | p in u.posts  \n}",
                    "{\n\t// Every image is posted by one user.\n\tlone u: User | all i: Photo | i in u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tlone p : Photo | one posts.p\n}",
                    "{\n\t// Every image is posted by one user.\n\tsome p : Photo | one posts.p\n}",
                    "{\n\t// Every image is posted by one user.\n\tall p : Photo | one u : User | u.posts in p\n}",
                    "{\n\t// Every image is posted by one user.\n  one Photo one User\n\t\n}",
                    "{\n\t// Every image is posted by one user.\n\tposts in User lone -> lone Photo\n}",
                    "{\n\t// Every image is posted by one user.\n\tone u: User | all p: Photo | some u.posts\n}",
                    "{\n\t// Every image is posted by one user.\n\tone u: User | all p: Photo | lone u.posts\n}"
                ]
            },
            {
                "description": "Users cannot follow themselves",
                "pred": "this/inv2",
                "oracle": "{\n\t// Users cannot follow themselves.\n    all u: User | u not in u.follows\n}",
                "erroneous": [
                    "{\n\t// Users cannot follow themselves.\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  all u: User | no follows.u\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  all x : User | x & iden.x in none\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall u : User |  (u in u.follows)\n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall u: User | u not in u.^follows\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall u: User | u.follows != u\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  one u:User | u not in u.follows\n  \n\n}",
                    "{\n\t// Users cannot follow themselves.\n\n  \t\n\n\t\n\t// \n  \t\n\n\t\n\t\n\t//\n  \t\n  \n  all x, y: User | not(x->y in follows) and x = y\n}",
                    "{\n\t// Users cannot follow themselves.\n\tfollows not in iden\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | no (u0.follows & u0.follows) \n \t\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tfollows.~follows in iden\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall u : User |  u.*(follows) != u\n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | no (u0.follows - u1.follows)\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tnot follows in ~follows\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  all u : User | some u1 : User | u1 in u.follows implies u!=u1\n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tUser not in User.follows\n}",
                    "{\n\t// Users cannot follow themselves.\n    all user : User | user not in user.suggested\n}",
                    "{\n\t// Users cannot follow themselves.\n  all u:User , other:User-u |\n  \tother in u.follows\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall x,y : User | x->y in follows implies y->x not in follows\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tfollows in iden\n\n}",
                    "{\n\t// Users cannot follow themselves.\n    \n  \t\n  \n\t\n  \n\tno User.follows & follows.User\n}",
                    "{\n\t// Users cannot follow themselves.\n\tone u1: User | one u2: User | u1 -> u2 in follows\n  \n}",
                    "{\n\t// Users cannot follow themselves.\n  \n  all p1, p2 : User | p1.follows = p2 \n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall x, y : User | some follows.x\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall u : User | one follows.u \n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | no (u0.^follows & u1.^follows)\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | one (u0.^follows & u1.^follows)\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0 : User | one u0.^follows \n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0 : User | some u0.^follows \n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | some (u0.^follows + u1.^follows) \n \t\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj u0,u1 : User | some (u0.^follows - u1.^follows) \n \t\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall u : User | User in u.follows \n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall u : User | some follow : User | follow not in u.follows\t\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall x : User | follows.x != x\n  \n\n}",
                    "{\n\tnot all u:User | u in u.follows\n\n}",
                    "{\n\t// Users cannot follow themselves.\n    all user : User | no user.suggested\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall x : User | not one follows.x\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tfollows.~follows not in iden\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tfollows.~follows not in follows\n}",
                    "{\n\t// Users cannot follow themselves.\n  \t\n  \tfollows & iden not in follows\n}",
                    "{\n\t// Users cannot follow themselves.\n  User not in follows.User\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  one u: User | u in u.follows\n\n}",
                    "{\n\t// Users cannot follow themselves.\n  \tall p : Photo | one posts.p\n\n}",
                    "{\n\t// Users cannot follow themselves.\n\tall disj x, y : User | all p : y.posts | (p in x.sees) iff (y in x.follows)\n}"
                ]
            },
            {
                "description": "Users can see ads posted by everyone, but only see non ads posted by followed users",
                "pred": "this/inv3",
                "oracle": "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.sees in (u.follows.posts + Ad)\n}",
                "erroneous": [
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | u.sees = {Ad + u.follows.posts} \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n  \t\n  \tall u: User | (u.follows.posts + Ad) in u.sees \n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \tall u: User + Influencer, a: Ad | a in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u : User, add : Ad | add in u.sees \n\t// but only see non ads posted by followed users.\n  \tall u : User, p : Photo |\n  \t\t\n  \t\t(p in u.sees and not p in Ad) implies\n  \t\t\n  \t\tsome user : User | p in user.posts and user in u.follows\n  \n\n}",
                    "{\n    // Users can see ads posted by everyone,\n    \n    all u: User |\n        u.sees in Ad and\n        (all p: u.sees - Ad | some f: u.follows | p in f.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n   all u: User, p: Photo |\n        (p in Ad) or (some f: u.follows | p in f.posts) implies p in u.sees\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, p: Photo | \n        (p in sees.u) <=> (p in Ad or (some v: u.follows | p in posts.v))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User, y : Ad | y in x.sees\n  all x : User, y : Photo-Ad | y in x.sees  implies posts.y in x.follows \n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | no a: Ad | a in u.sees & u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n  \t\n  \tall u1,u2: User, p: Photo - Ad | p in u1.sees implies p in u2.posts and u2 in u1.follows\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.sees = u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u : User | all p : Photo| (p in Ad implies p in u.sees) and (p not in Ad implies (some poster : User | poster in u.follows and p in poster.posts and p in u.sees))\n\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | u.posts not in u.sees\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | u.sees in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User |\n  \tu.sees = Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u:User | (u.follows.posts) in u.sees \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u: User, p: Photo |\n        (p in Ad => p in u.sees) and           \n        (p not in Ad => some u2: u.follows | p in u2.posts => p in u.sees) \n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad | some sees.a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u:User | (Ad + u.follows.posts - u.posts) = u.sees \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | all a: Ad | a in u.sees\n  \tall u: User | all p: u.posts | (p in Ad) or (p not in u.sees)\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 and p in u2.posts and u2 in u1.follows implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users\n  all u:User,p :Photo |(p not in Ad) && (p in u.follows.posts) \n  all u:User,p:Photo | p in Ad && p in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.sees = (Ad + u.follows.posts + u.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n    \n    \n\n    \n    \n\n    \n\n      all x:User | x.sees in (x.follows.posts & Ad)\n  \n  \t\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User, a:Ad | a in u.sees\n  \n  all u1, u2:User, p: Photo - Ad | \n  \t\tu1 in u2.follows and p in u1.posts and u1 != u2 \n  \t\t\timplies \n  \t\tp in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  all x: User, p: Photo | p in Ad or p in x.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | p in u.sees\n\n}",
                    "{\n  \n  all p: Ad | all u: User | p in u.sees\n\n  \n  all p: (Photo - Ad), u: User | p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | Ad in u.sees && u.sees in u.follows.posts \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some u.sees & Ad\n  \tall u: User | some u.sees.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User, y : Ad | y in x.sees\n  all x : User, y : Photo | y in x.sees implies posts.y in x.follows \n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees = Ad + (u.follows.posts - Ad - u.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n    (p in Ad => p in u.sees) &&  \n    (p not in Ad => (some poster: User | p in poster.posts && poster in u.follows => p in u.sees))  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x: User, y: Ad | x->y in sees \n  all x, y: User, z: Photo | x->z in sees and not z in Ad implies x->y in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all a : Ad | a in u.sees and u.follows.posts in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u:User | no a:Ad | a in u.sees and a in u.follows.posts \n  \tall u:User | no (u.posts & u.sees)\n  \tall i:Influencer | no a:Ad | a in i.sees and a in i.follows.posts \n  \tall i:Influencer | no (i.posts & i.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    \n  \tall u, y : User, a : Ad | a in y.posts implies (a in u.sees) \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p:Photo|\n  \t(p in u.sees) <=> (p in u.follows.posts) || (p in Ad) \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj x, y : User | all p : y.posts | (p in x.sees) implies (y in x.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | posts.(u.sees - Ad) in follows.u \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo | p in u.sees implies (posts.p in u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all a: Ad | a in u.sees\n  and\n  all u: User | all p: Photo - Ad | p in u.sees implies (some u2: User | p in u2.posts and u2 in u.follows)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a : Ad | a in u.sees\n  all u1,u2 : User, p : Photo | p in u1.sees implies u2 in u1.follows or p in u1.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.sees = (User.posts)&Ad + u.follows.posts    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | (\n  \tp in Ad implies p in u.sees else (\n      posts.p in u.follows implies p in u.sees else p not in u.sees\n    )\n  )\n}",
                    "{\n\tall u: User, p: Photo | \n        (p in Ad implies p in u.sees) and \n        (p not in Ad implies (some f: u.follows | p in f.posts))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Photo | u in sees.a implies a in Ad or\n  \tsome u1 : User | u1 in posts.a and u1 in follows.u\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u:User | u.sees in (u.follows.posts - Ad)  \n\n}",
                    "{\n\t\n\t\n    \n    all u: User | \n    u.sees = { p: Photo | p in Ad and (p in (u.follows.posts - u.posts) and not p in Ad) }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, a : Ad, p : Photo | a in u.sees and p in u.sees implies p in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a : Ad | a in u.sees\n  all u1,u2 : User, p : Photo | p in u1.sees implies u2 in u1.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u: User | u.sees = (Ad & u.posts) + ((Photo - Ad) & u.follows.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all p: Photo-Ad, u:User | p in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u : User | all p : Photo| (p in Ad implies p in u.sees) and (p not in Ad implies (all poster : User | poster in u.follows and p in poster.posts and p in u.sees))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u:User | all a:Ad | u->a in sees\n  \tall u1, u2:User | all p:Photo | \n  \tp not in Ad and u1->p in sees implies (u1->u2 in follows and u2->p in posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u: User | Photo - Ad in u.follows\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1, u2 : User, p : Photo | u2 in u1.follows and p in u1.sees and p in u2.posts implies p not in Ad \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x : User | all z : User | all y : Photo | z -> y in posts and x -> y in sees and y != Ad implies x -> z in follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \tall u: User, p: Photo-Ad | (posts.p in u.follows) \n}",
                    "{\n  // Users can see ads posted by everyone, \n  // but only see non ads posted by followed users.\n  all u : User | Ad in u.sees\n  all u: User, p: Photo | p in u.sees iff (p not in Ad) and p in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | (p in Ad => p in u.sees) and (p not in Ad => (some v : User | p in v.posts and u in v.follows) =>p in u.sees)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees and p in u.sees implies a in u1.posts and u1 in u.follows or u = u1\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x : User, y : Photo | x in sees.y implies (y in Ad) or (all z : User | z in posts.y and z in follows.x)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall disj u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | u.sees not in u.posts\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\nall x: User | all y: Photo | x-> y in sees and y in Ad or\n  all z: User | z->y in posts implies x->z in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    all p: Photo | \n      (p in Ad and p not in u.posts implies p in u.sees) and\n      (p not in Ad implies (some f: u.follows | p in f.posts) implies p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u:User | u.sees in u.follows.posts or u.sees in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a: Ad | all u: User | a in u.sees &&\n  \tall p: Photo - Ad | all u1: User | p in u.sees iff u1 in u.follows and p in u1.posts \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:x.follows, r:y.posts , z:x.sees | z in r\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all add : Ad | add in u.posts \n  \tall u : User, add : Ad| add->u not in follows \n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\tall u : User, p : Photo | u->p in posts implies p in Ad or some u1 : User | u1->p in posts and u->u1 in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User.follows.posts | Ad not in u\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n\tall u: User | some p: Photo | p in u.sees implies ((some f: User | u in f.follows and p in f.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n  \tUser.follows.posts - Ad in User.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | some u.posts & Ad implies u.posts in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall disj u,u1 : User | all p : u.sees | p not in Ad implies p in u1.posts and u1 in u.follows\n\t// but only see non ads posted by followed users.\n\t\n}",
                    "{\n\tall u: User, p: Photo |\n  p in u.sees <=> (p in Ad) or (p in u.follows.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2 : User |\n  \t((u1 not in u2.follows) implies (all p : Photo | (p in u1.posts and p in Ad) \t\t \t\timplies (p not in u2.sees)))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj x, y : User | some ((x.sees - Ad) & y.posts) implies (y in x.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees && a not in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | Ad & u.follows.posts in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n    \n    \n\n    \n    \n\n    \n    \n     \n\tall u : User, a : Ad | u->a in sees implies\n\t    some u1 : User | u1->a in posts and u->u1 in follows\n  \n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all x: u.follows | all a: Ad | u.sees in x.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some u.sees & Ad\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees | all a : Ad | all f : u.follows | p in a or p in f.posts \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all p : Photo | one u2:User|\n  \t\t\tp in u2.posts and\n  \t\t\tp in Ad => p in u.sees and\n  \t\t\t(p not in Ad and p in u.sees) => u2 in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    no a : Ad, u : User | a in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees in (Ad + u.follows.posts + u.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u : User - Influencer | u.sees = u.follows.posts + Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all y : Ad | x->y in sees\n  all x : User | all y : User |all z : Photo | (z not in Ad) and (x->z in sees) and (x->y in follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo, a:Ad |\n  \t\t(p in u.sees) implies \n  \t\t\t(p in a or posts.p in u.follows)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:x.follows, r:y.posts , z:x.sees | r not in Ad implies z in r\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all ads : Ad, nonAds : Photo - Ad, user : User | \n  \t\tads in user.sees\n    \n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all a : Ad | a in User.sees\n  all u : User | u.sees in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n  \t(p in Ad implies p in u.sees)\n  \tand (p not in Ad implies one poster : User | poster in u.follows and p in poster.posts and p in u .sees)\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : Photo | p in u.sees implies\n  \t(p in Ad or (all u2 : u.follows | p in u2.posts))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, p : Photo | p in u.sees implies p in Ad and one u2 : User | p in u2.posts and u2 in u.follows\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u,u1 : User | (u1.posts & Ad in u.sees) and (u1 in u.follows implies u1.posts - Ad in u.sees) \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n \t// but only see non ads posted by followed users.\n\tUser.sees = Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User , ad : Ad | ad in u.sees\n  all u : User | u.follows.posts = u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User | u.posts-Ad in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.follows.posts-Ad | u.sees = Ad + p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad | ad in u.sees and ( all p : Photo | p in u.sees and p in u.follows.posts )\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.follows.posts & Ad not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees = (u.follows.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, photo: u.sees - Ad | \n  \t\t(Ad in u.sees) and\n  \t\t(posts.photo in (u.follows + u.posts))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \n  all u: User, p: Photo - Ad | p.~posts in u.follows\n}",
                    "{\n  \n  all u: User | all a: Ad | a in u.sees\n  and\n  all u: User | all p: Photo - Ad | p in u.sees implies (one u2: User | p in u2.posts and u2 in u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p: Photo | some u: User | p in u.sees implies p in Ad or p in u.follows.posts \n\n}",
                    "{\n\t  // Users can see ads posted by everyone,\n \n  \n  all p: Ad | all u: User | p in u.sees\n\n  \n  all p: Photo - Ad | all u: User | p in u.sees implies (u in u.follows && p not in Ad)\n  \n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | (Photo - Ad) not in u.sees\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \t\n  \tall u: User | all p: u.posts | (p not in Ad) implies (p not in u.sees)\n  \tall u: User | all p: u.posts | (p in Ad) implies (p in u.sees)\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | all a: Ad | a in u.sees\n  \tall u: User | all p: u.posts | p not in u.sees\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | some a: Ad | a in u.sees\n  \tall u: User | all p: u.posts | (p in Ad) or (p not in u.sees)\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : Photo | p not in Ad and p in u.sees implies p not in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall u : User, a : Ad | a in u.sees\n\t// but only see non ads posted by followed users.\n  \tall u1,u2 : User, p : Photo | p not in Ad and p in u1.sees implies u2 in follows.u1\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User, y : Ad | y in x.sees\n  all x : User, y : Photo-Ad | y in x.sees implies posts.y in y.^(posts.follows) \n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | some x: u.follows | all a: Ad | u.sees not in x.posts implies u.sees in a\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | all a: Ad | u.sees not in x.posts implies u.sees in a\n\n}",
                    "{\n    // Users can see ads posted by everyone, \n    // but only see non ads posted by followed users.\n  all user: User |\n    user.sees =  (User.follows.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees  | (( p in Ad ) or ( p in u.follows.posts ) ) and (not p in u.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | u in sees.p implies p in Ad or\n  \tsome u1 : User | u1 in sees.p implies (u1 in posts.p and u1 in follows.u)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all p : Photo | one u2:User | \n  \t\t\tp in u.sees => (p in Ad or (p in u2.posts and u2 in u.follows))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u1: User, u2: User, p: u2.posts | u2 in u1.follows && p in Ad => p not in u1.sees\n  \tall u1: User, u2: User, p: u2.posts | u2 not in u1.follows && p in Ad => p in u1.sees\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \t\n  \t\t\n    \n    \n      \n      \n      \n    \n  \n  \tall u1:User,nonAd: Photo-Ad| Ad in u1.sees and (some nonAd & u1.sees) => (posts.nonAd in u1.follows)  \n  \t\n}",
                    "{\n    // Users can see ads posted by everyone,\n    \n    all u: User |\n        (u.sees & Ad = u.posts & Ad) and\n        (all p: u.sees - Ad | some f: u.follows | p in f.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all a: Ad | a in u.sees implies (some u1: User | a in u1.posts and (u1 in u.follows or u = u1))\n  all u: User | all p: Photo | p in u.sees implies (some u1: User | p in u1.posts and (u1 in u.follows or u = u1))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | u.sees in (u.follows.posts + u.posts) - Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t all u: User, p: Photo | p in u.sees <=> (p in u.posts && p not in Ad) || (p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.sees = Ad - u.posts\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u : User | u.follows.posts in u.sees\n    all u: (User-Influencer)| u.posts not in u.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all p: Photo - Ad | p in i.posts and p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, i : Photo | u->i in sees implies i = Ad or some v : User | u->v in follows and v->i in posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall ad: Ad, u: User | ad in u.sees\n  \tall p: Photo, u: User | p in u.sees => (posts.p in u.follows) or p in u.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x: Photo | lone posts.x\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad | all u : User | a in u.sees implies not a in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User | all a:Ad | a in u.sees\n  all u1,u2:User | all p:Photo-Ad | p in u1.sees and u2 in follows.u1\n  \n\n}",
                    "{\n  // Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u: User | \n        \n        all a: Ad | a in u.sees and\n        \n        all p: Photo - Ad | p in u.sees iff p in (u.follows).posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some(u.sees & Photo-Ad) implies some(u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo - Ad, u : User | sees.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:Ad | y in x.sees and x in x.follows \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    \n    all p: Photo | (p in Ad) or p in (User.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    User.sees = Photo\n}",
                    "{\n  \n  all u: User, p: Ad | p in u.sees\n  \n  \n  all u: User, p: Photo | \n    p not in Ad implies (\n      (some y: User | y in u.follows and p in y.posts) and p != u.posts implies p in u.sees\n    )\n}",
                    "{\n    // Users can see ads posted by everyone, \n    // but only see non ads posted by followed users.\n  \tall u : User, u2 : User, p : Photo |\n  \t\t(p in Ad or p in u.sees) and (p in u2.posts) implies u2 in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  \n  all a: Ad | a in sees.a and a not in follows.posts.a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all x: User | all y: Ad | y in x.sees\n  all w: User | all p: Photo | some z: w.follows | (not p in Ad) => p in z.posts and p in w.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \tUser.sees in User.follows.posts + Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User,ad:Ad| ad in u.sees and posts.(u.sees - ad) in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | (posts.(u.sees) - u.follows).posts in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, p: Photo | p in Ad implies p in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | p not in Ad and u1 not in u2.follows implies p not in u2.sees and u1 != u2\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | one u2 : User| all i : Photo | (i in Ad) implies i in u.sees\n  or ((i in u2.posts) and ( u2 in u.follows)) implies i in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo-Ad, u : User | posts.p in follows.(sees.p)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo {\n    \t(p in Ad + u.follows.posts - u.posts) implies (p in u.sees)      \t\t\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall disj u : User | all p : u.sees |one u1 : User | (p in u1.posts and u1 in u.follows and u1 != u) or p in Ad\n\t\n\t\n}",
                    "{\n  \n  all u: User, a: Ad | a in u.sees\n  all u: User | #(u.sees & u.posts) = 0\n\n  \n  all u: User, p: Photo - Ad |  p in u.posts => p in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | \n    (p in Ad implies p in u.sees) and\n    (p not in Ad implies \n      (some poster: User | p in poster.posts and poster in u.follows) \n        implies p in u.sees) and\n    (p in u.posts implies p not in u.sees)\n}",
                    "{\n  \n  all u: User, a: Ad | a in u.sees\n  all u: User | #(u.sees & (u.posts - Ad)) = 0\n\n  \n  all u: User, p: Photo - Ad | p in u.follows.posts => p in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees in User.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad, followed : u.follows | ad in u.sees or #(u.follows)>0 and ( all p : Photo | p not in Ad and (p in u.sees iff p in followed.posts))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | #(u.sees & u.posts)=0\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | #(u.sees & u.posts)=0\n  all u1, u2: User| some p: Photo| (p not in Ad and p in u1.sees) implies (p in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2: User| some p: Photo| (p not in Ad and p in u1.sees) implies (p in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | #(u.sees & u.posts & (Photo - Ad))=0\n  all u1, u2: User| some p: Photo| (p not in Ad and p in u1.sees) implies (p in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n all u: User, p: Photo |\n       \n        (p not in Ad => (some u2: User | u2 in u.follows && p in u2.posts && p in u.sees) )\n\n}",
                    "{\n  \tall disj u1,u2 : User|\n  not (u2 in u1.follows) implies (all p : u1.posts| p in u2.sees implies p in Ad)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \n\t\n}",
                    "{\n  \tall disj u1,u2 : User|\n  (not (u2 in u1.follows)) implies (all p : u1.posts| p in u2.sees implies p in Ad)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \tall disj u1,u2 : User| some p : u1.posts| \n(not p in Ad and p in u2.sees) implies (u2 in u1.follows)\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, p : u.sees | some u1 : User | u1 != u and u1 in u.follows and \n  \t\tp in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = Ad\n  \tall u : User | all p : u.follows.posts - Ad | p in u.sees\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | (u.posts - Ad) in u.sees\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad and posts.p != u) => (p in u.sees) \n        else (p not in Ad and some f: u.follows | p in f.posts) => (p in u.sees) \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n\tall u: User, p:Photo | u in sees.p implies p in Ad\n  \n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies posts.p in u.follows\n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\tall u: User, p:Photo | u in sees.p implies p in Ad\n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p: Photo | p in u.sees implies u in u.follows\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\t\n  \t\n  \t\n\n  \n\t\n\t\n  \t\n  \n  // but only see non ads posted by followed users.\n  \t\n  \n\t\n  \n  \n\tall u: User, a: Ad | a in posts.u => a in sees.u\n\tall u: User, p: Photo-Ad| p in u.sees implies u.posts in u.follows\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n    all u: User, a: Photo | u in sees.a implies a in Ad or \n  \tsome u1: User, a: Photo | u1 in posts.a and u in follows.u1\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \n  all u: User, p: Photo | p in Ad implies p in u.sees\n\n  \n  all u, y: User, p: Photo | \n      (p in y.posts and p not in Ad) implies (( y in u.follows) iff (p in u.sees))\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    \n    all p: Photo | (p in Ad) or (sees.p in User.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, a: Ad | u.sees in (u.follows.posts & a)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u,m:User-Influencer, p:Photo | all a:Ad | a in u.sees and m in u.follows implies p in u.sees \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \tall u: User, p: Photo |\n    (p in Ad implies p in u.sees) and\n    (p not in Ad implies\n      ((u in Influencer implies p in u.posts) and\n       (p in u.follows.sees or p in u.sees))\n    )\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \t\n  \t\tall u: User, i:Influencer, p: Photo | (p in Ad implies some u.sees) and (p in Ad implies  some i.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees in Ad\n  \t\n  \tall u: User | u.follows.posts in u.sees\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User, a: Ad | (Photo - Ad) not in u.sees\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | (a in u.sees) and (u.posts not in u.sees)\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | lone a: Ad | a in u.sees\n  \tall u: User | all p: u.posts | (p in Ad) or (p not in u.sees)\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u0,u1: User | u0.sees in u1.posts\n\tsome p: Photo | User.follows in posts.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall disj u1: User, u2: User | (u1 in u2.follows) implies (u1.posts in u2.sees)\n  \tall u: User | all p: u.posts | (p not in Ad) implies (p not in u.sees)\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n    \n    \n\n    \n    \n\n    \n    \n     \n\tall u : User, a : u.sees | u.sees in Ad or some posts.(u.sees) & u.follows\n  }",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall u : User, a : Ad | a in sees.u\n\t// but only see non ads posted by followed users.\n  \tall u1,u2 : User, p : Photo | p in u1.sees implies u2 in follows.u1\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some(u.sees-Ad & u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | u.sees not in x.posts implies u.sees in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall user: User, image: Photo | image in user.sees => image in Ad || (one user2: User | image in user2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | u->p in sees implies p= Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    some p : Photo | all a : Ad | some e : User | some d : User | p != a and e->p in posts and d->p in sees implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \n\n\tall p : Photo | p in User.posts implies p in User.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees | all a : Ad | all f : u.follows | ( p in a ) or ( p in f.posts ) and not p in u.posts\n}",
                    "{\n  \n  all p: Ad | all u: User | p in u.sees\n\n  \n\n  no ad: Ad | all u: User | ad in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | all a : Ad | some e : User | some d : User | p != a and e->p in posts and d->p in sees implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees | all a : Ad | all f : u.follows | ( p in a and not p in f.posts) or ( p in f.posts and not p in a )\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a : Ad | a in u.sees\n  all u1,u2 : User, p : Photo | p in u1.sees implies  u2 in u1.follows and p in u2.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all ad : Ad  | ad in u.sees\n  no u : User | u.sees = u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees | all a : Ad | all f : u.follows | (( p in a ) or ( p in f.posts ) ) and not p in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all o,e : User | all a : Ad | o->a in posts implies e->a in sees\n    all p : Photo | all a,b : User | b->p in posts and a->p in sees implies a->b in follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees and p in u.sees implies p in u1.posts and u1 in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees and u1!= u and p in u.sees implies u1 in u.follows and p in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User, p : Photo | p in u1.sees implies u2 in u1.follows and p in u2.posts or p in u1.posts\n  \tall u1,u2 : User, ad : Ad, p : Photo | ad in u1.sees implies ad in u2.posts or ad in u1.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | some p : Photo | some a : Ad | a in u.sees and p in u.sees implies u1 in u.follows and p in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | some p : Photo | some a : Ad | (a in u.sees) and (p in u.sees implies u1 in u.follows and p in u1.posts and u!=u1)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees\n  \tall u : User | u.follows.posts in u.sees\n  \tall u : User | (User.posts - Ad - u.follows.posts) not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1,u2 : User, p : Photo | p in u1.sees implies (p in Ad or u2 in u1.follows or p in u1.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u,v: User | all a: Ad | a in v.posts and a in u.sees and v in u.follows implies v.posts in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, a: Ad | a in u.posts implies a in u.sees\n  all u1, u2: User, p: Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and (u2 in u1.follows or u1 = u2) implies p in u1.sees\n\n}",
                    "{\n    // Users can see ads posted by everyone,\n    all a: Ad | all u: User | a in u.sees\n    // but only see non ads posted by followed users.\n    all u: User, p: Photo - Ad | p in u.sees implies (one f: u.follows | p in f.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad,  u : User | a in u.sees\n  \tall u : User, p : Photo-Ad | p in u.sees implies p in u.follows.posts+u.posts\n}",
                    "{\n  all u: User, p: Photo | \n    (p in u.posts && p not in Ad) => \n      (p in u.sees) ||\n      (some u.follows && (p in (u.follows & User) && p not in Ad))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User,a:Ad | a in u.sees\n  all u:User,p :Photo |\n  \t  (p not in Ad) && (p in u.follows.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t(all u: User| all p: Photo|\n\t(p in Ad implies p in u.sees) and \n  \t(p in (u.follows).posts) implies p in u.sees and (p in u.posts implies p not in u.sees)\n\n\n)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t(all u: User| all p: Photo|\n\t(p in Ad implies p in u.sees) and \n  \t(p in (u.follows).posts) implies p in u.sees and #(u.sees & u.posts) = 0\n\n\n)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all a: Ad | a in u.sees\n\tall u : User | all p : Photo | all a: Ad | p not in a and p not in u.follows.posts and p not in u.posts => p not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all a : Ad | Ad in u.sees implies (a not in u.follows.posts) \n  \t\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall a: Ad | some sees.a\n  \tall p: Photo - Ad, u: User | posts.p in u.follows implies u->p in sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall a: Ad | some sees.a\n  \tall p: Photo - Ad | all u: User | u->p in sees implies posts.p in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u1: User, u2: u1.follows + u1, p: u2.posts | p in u1.sees && p not in Ad\n    all u1: User, u2: User - u1.follows - u1, p: u2.posts & Ad | p in u1.sees \n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad, photo: u.sees - Ad | \n  \t\t(a in u.sees) and\n  \t\t(posts.photo in (u.follows + u.posts))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: u.sees | p in Ad => one f: u.follows | p in f.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \tall u : User | all p : Photo | u in sees.p implies p in Ad or some u1 : User | u1 in posts.p and u in follows.u1 \n\t\n  \tall u : User | all p: Photo | some sees.p implies p in Ad or some posts.p & u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees = Photo \n  \tall u: User, p : Photo | p in u.sees && p in u.posts implies p not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all a : Ad | a in u.sees\n  \tall u : User | all p : (Photo - Ad) | p in u.^follows.posts implies p in u.sees \n\n}",
                    "{\n  // Users can see ads posted by everyone,\n  \n  all u: User, p: Photo | p in u.sees implies (p in u.posts implies p in Ad) or (p in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n        (p in u.sees <=> p in Ad) ||\n        (p in u.sees <=> some u1: u.follows | p in u1.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Ad | no u : User | a in (u.follows.posts + u.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Ad, u : User | u.sees in (u.follows.posts - a)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.posts not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | u.sees in Ad or (all p : (Photo - Ad) | posts.p in u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  User.sees = User.follows.posts + Ad\n}",
                    "{\n\t\n\t\n    \n    all u: User | \n    u.sees = { p: Photo | p in Ad and p in (u.follows.posts - { pp : u.posts | pp not in Ad})}\n}",
                    "{\n\t\n\t\n    \n    all u: User | \n    u.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    u.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all a: Ad | a in i.posts =>\n             a in i.sees\n  \n    all i: Influencer | all p: Photo - Ad | p in p.posts => p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n\n \n  \n    all i: Influencer | all p: Photo - Ad | p in i.posts => p not in i.sees\n\n  \n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    \tu.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n    all i: Influencer |\n  \t\ti.sees = Ad + i.follows.posts + i.posts\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | all p : i.posts | p not in Ad and p not in i.sees\n\tall u : User |  u.sees = Ad + { p: u.follows.posts| p not in Ad}\n}",
                    "{\n\t\n\t\n    \n    Influencer.sees = Ad\n    Influencer.posts in Photo\n\tall u : (User-Influencer) |  u.sees = Ad + { p: u.follows.posts| p not in Ad}\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | no (u.follows.posts & u.sees & Ad) and ((u.sees - u.follows.posts) in Ad)\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall ad: Ad, u: User | ad not in u.sees => ad in u.posts\n  \tall p: Photo - Ad, u: User | p in u.sees => posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all y : Photo | all z : User | ((y in Ad and x->x not in follows) or (x->z in follows and z->y in posts and y not in Ad)) implies (x->y in sees) \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo | all x : User | all y : User | p in x.posts and p in y.sees and x in y.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x : User | all y : User | y.posts -> x in sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u : User | (u.sees in Ad) or (u.sees in u.follows.posts)\n\t// but only see non ads posted by followed users.\n  all f : Photo | (f not in Ad) and (sees in follows.posts)   \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    all p: Photo | \n      (p in Ad and p not in u.posts and p in u.sees) and\n      (p not in Ad implies (some f: u.follows | p in f.posts) implies p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Ad | u -> a in sees\n  \tno u : User, p : Photo | p in Ad and u -> p in sees implies all u2 : posts.p | u -> u2 in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p: Photo | all u: User |\n  \tp in u.sees implies p in Ad or (p in u.follows.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:Ad | y in x.sees and x not in x.follows \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all x: u.follows | u.sees in x.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:Photo-Ad | y in x.sees and x not in x.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all pa : Photo - Ad | some u:User | pa in u.sees and pa in u.follows.posts \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, p : Photo - Ad |  (posts.p & sees.p) in u.follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:User - x.follows | y.posts-Ad not in x.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in sees.ad and u in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad, f:User | f in posts.ad and u in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    User.sees = Photo\n    all x: Photo-Ad, u:User | u in sees.x implies x in u.follows.posts\n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.follows.posts in u.sees and u.posts - Ad not in u.sees\n}",
                    "{\n    \n    \n  \n    // Users can see ads posted by everyone\n\tall u : User, a : Ad | a in u.sees\n  \n    \n\tall u : User, p : Photo | \n  \t\tp in u.sees implies (\n  \t\t\tp not in Ad iff (\n           \t\tsome y : User | p in y.posts and y in u.follows )\n        )\n\n\n        \n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x: User | all y: User | some w : Photo | (not x->y in follows and y->w in posts and not w in Ad and not x=y) implies (not x->w in sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, p: Photo | (p in u.sees) =>\n    (p in u.posts && no Ad & p)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some x.sees\n\t\n  \tall x : Photo |  not Ad in follows.x\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some sees.x\n\t\n  \tall x : Photo | not Ad in x.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall a : Ad, u : User | u in sees.a\n  \tall p : Photo | posts.p.follows in sees.p and p not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    \n\t\n  \tall x : Photo, u : User | posts.x in u.follows and x not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users\n   all u: User | some a : Ad |\n        u.sees = a + (u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all w: User | all p: Photo | all z: w.follows | (not p in Ad) => p in z.posts and p in w.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all p: Photo-Ad, u:User | p in u.follows.sees\n\n}",
                    "{\n    User -> User in sees.(iden & (Ad -> Ad)).(~posts).((iden) -  follows)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n    User -> User in sees.(iden & (Ad -> Ad)).(~posts).((univ -> univ) -  follows)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2:User | some p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1:User | some u2:User | all p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1:User | some u2:User | all p:Photo| p in u1.sees implies ((u1 in follows.u2 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x: User | x.sees = (Ad + x.follows.posts) or ((x.follows = none) implies x.sees = Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users\n   all u: User | all a : Ad |\n        u.sees = a + (u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, ad: Ad | {\n      u.sees = ad\n      u.sees = u.follows.posts\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, ad: Ad | {\n      u.sees = ad + u.follows.posts - u.posts\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n  \tPhoto - User.follows.posts - Ad not in User.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \tall u: User + Influencer, a: Ad | a in u.follows.sees and a in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | all u: User | ad in u.sees\n  all u : User |\n  \tsome p: u.sees | \n  \tsome f: u.follows | p in Ad or p in f.posts\n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | all u: User | ad in u.sees\n  all u : User | some p : u.sees | some f : u.follows |p in Ad or p in f.posts or p in u.posts\n  \n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Ad, u : User |\n  \t\ta in u.sees implies a not in (u.posts & u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u : User, add : Ad | add in u.sees or add in u.posts\n\t// but only see non ads posted by followed users.\n  \tall u : User, p : Photo |\n  \t\t\n  \t\t(p in u.sees and not p in Ad) implies\n  \t\t\n  \t\tsome user : User | (p in user.posts and user in u.follows)\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p : Photo | one u : User | p in u.posts\n  \tall u : User | not (u in u.follows)\n  \tall u : User, p : Photo - Ad | p in u.sees implies p in u.follows.posts\n  \tall a : Ad, u : User | a in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all u: User, a: Ad | a in u.sees\n\n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a not in u.sees one date\n  \n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | p in u.sees iff p in Ad or posts.p in u.follows\n\n}",
                    "{\n\t\n\t\n\tall u: User, p: Photo | u -> p in sees implies p-Ad in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | (posts.(u.sees) - u.follows - u).posts in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Photo | a in u.sees implies a in Ad or \n\t    some u1 : User | a in u.posts and u1 in u.follows\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2:User, p:Photo, a:Ad | \n  \t\t\tu1 in u2.follows and p in u1.posts and a !=p\n  \t\t\t\timplies \n  \t\t\tp in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p : Photo | posts.p.follows in sees.p or p in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, ad: Ad | ad in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | (p not in Ad && u1 -> p in sees && u2-> p in posts) implies (u2 in u1.follows) && u1 != u2\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, ad: Ad | ad in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | (p not in Ad && u1 -> p in sees && u2-> p in posts) implies (u2 in u1.follows) or u1 != u2\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall i : Photo, u : User | i in u.sees implies i in Ad or u in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | Ad in u.sees && u.sees in u.follows.posts + u.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall disj u1,u2 : User |one p : Photo | ((p != Ad and u1 not in u2.follows) \t\timplies p not in u2.sees ) or p = Ad\n  \t\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall u1,u2 : User |one p : Photo | ((p != Ad and u1 not in u2.follows) \t\timplies p not in u2.sees ) or p = Ad\n  \t\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall u1,u2 : User |lone p : Photo | ((p != Ad and u1 not in u2.follows) \t\timplies p not in u2.sees ) or p = Ad\n  \t\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a in u.sees\n  \tall p: Photo, u, u2: User | Photo not in Ad and p in u2.posts and u2 in u.follows and p in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees in (User - u).posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | u.sees in (User - u).posts\n  \tall u: User | all p: Photo - Ad | p in u.sees => p in u.follows.posts \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n   all u: User | u.sees = u.posts + Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    all p: Photo | \n      (p in Ad and p not in u.posts iff p in u.sees) and\n      (p not in Ad implies (some f: u.follows | p in f.posts) implies p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.follows.posts not in Ad and u.sees = u.follows.posts + Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts implies a in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | (u1 != u2 and a in u2.posts) implies a in u1.sees\n  \tall u1, u2: User | all p: Photo - Ad | u1 != u2 and p in u1.sees implies (u2 in u1.follows and p in u2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n\tall u : User | u.follows.posts in u.sees - Ad \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n\tall u : User | Ad in u.sees or u.sees - Ad in u.follows.posts \n  \n  \t\n    \n  \t\n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo, u1 : User | p in u1.sees implies some u2 : User | p in Ad or p in u2.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tUser.follows = none\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall disj u, followed : User | all p : u.sees | followed in u.follows and p in u.sees and p in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall disj u, followed : User | all p : u.sees | followed in u.follows and p in u.follows.posts and u.sees & u.posts = none\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all p : u.sees | p in u.follows.posts and u.sees & u.posts = none\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, p : Photo | #(u.follows) > 0 and  p not in Ad and (p in u.sees iff p in u.follows.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad | ad in u.sees or ( all p : Photo | p not in Ad and p in u.sees iff p in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all disj u1, u2 : User |\n  \t(u1 not in u2.follows) implies u2.posts not in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2: User, a: Ad| a in u1.sees implies (a in u2.posts and u2 in u1.follows)\n\n}",
                    "{\n  \tall u1,u2 : User|\n  (not (u2 in u1.follows)) implies (all p : u1.posts| p in u2.sees implies p in Ad)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \tall  u1,u2 : User| some p : u1.posts| \n(not p in Ad and p in u2.sees) implies (u2 in u1.follows)\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u, u1 : User, p : Photo | p in Ad implies not u in follows.u1\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | Ad not in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, a: Ad | a in u.sees \n  \t// but only see non ads posted by followed users.\n  \tall u : User, a: Ad | u.sees in u.follows.posts implies no a\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u: User, u1: User | u1 in u.follows implies u.sees not in Ad\n\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \t\n  \n  \tall u, u1: User, p: Photo | u1->p in posts and u->p in sees implies u1 in u.follows and p not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | (a in u.sees iff a not in u.follows.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u : User, a : Ad | u in sees.a or\n  \t\tsome u1 : User | u1->a in posts and u->u1 in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2: User | ((u2 not in u1.follows) and (u2.posts not in Ad)) => (u2.posts not in u1.sees) \n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo |\n        (p in u.sees) <=> (p in Ad or (all f : u.follows | p in f.posts))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User | u1 in u2.follows => u2.sees not in (u1.posts & Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User | u1 in u2.follows => u2.sees in (u1.posts & Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2:User, p:Photo | (p in Ad => p in u1.sees)\n  \t\t\t\t\t\t&& (u2 in u1.follows => not(p in (u2.posts & Ad) => p in u1.sees))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo |\n    (p in Ad) => (p in u.sees)\n    else (some u.follows & User) => (p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, s: u.sees | sees.s in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n\tall u: User, p:Photo | u in sees.p implies p in Ad\n  \n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies u.posts in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u1, u2: User| some p: Photo| ((p not in Ad and p in u1.sees) implies (p in  u2.posts and u2 in u1.follows)) and ((p in u1.sees and p in u1.posts )implies p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | u.sees = (Ad + follows.posts.p)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees and (User - u.follows).posts not in u.sees\n}",
                    "{\n\t\n  \tall u:User, p: Photo | u in sees.p and posts.p not in u.follows implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\n\n\tall u: User, p: Photo| p not in Ad implies u.follows in posts.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, a: Ad | u in sees.a and \n\t// but only see non ads posted by followed users.\n\tsome u1: User| all p: Photo-Ad | (p in u1.posts) and (u in follows.u1) implies u in sees.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, p : Photo | (p in Ad) => (p in u.sees)\n  \tall u, v : User | (u.posts in v.sees)<=>(u in v.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \n  all u: User, p: Photo | p in Ad implies p in u.sees\n\n  \n  \n  all u, y: User, p: Photo |\n      (p in y.posts and not (p in Ad)) implies \n          (y in u.follows and p in u.sees)\n\n  \n  all u, y: User, p: Photo |\n      (p in y.posts and not (p in Ad) and not (y in u.follows)) implies \n          not (p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, a: Ad | u.posts in (u.follows.posts & a)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  \n  all a: Ad | lone sees.a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u,m:User, p:Photo | all a:Ad | a in u.sees and m in u.follows implies p in u.sees \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \tall u: User - Influencer, a:Ad | a in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \tall u: User, p: Photo |\n    (p in Ad implies p in u.sees) and\n    (p not in Ad implies\n      (p in u.posts and (p in u.follows.sees or p in u.sees))\n    )\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \tall u: User - Influencer, p: Photo |\n    (p in Ad implies p in u.sees) and\n    (p not in Ad implies\n      (p in u.posts and (p in u.follows.sees or p in u.sees))\n    )\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \tall u: User + Influencer, a: Ad | a in u.follows.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \t\n  \t\tall u: User, i:Influencer, p: Photo | (p in Ad implies some u.sees) and (p in Ad implies no i.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \t\n  \t\tall u: User, i:Influencer, p: Photo | (p in Ad implies some u.follows.sees) and (p in Ad implies some i.follows.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n\n  \t\n  \n  \t\n    \n    \n      \n       \n    \n  \t\n  \t\n  \t\tall u: User, p: Photo |\n    (p in Ad implies p in u.sees) and\n    (p not in Ad implies (\n      (p in u.posts and p in u.sees) or\n      (p in u.follows.posts and p in u.follows.sees) or\n      (u in Influencer and p in u.posts and p in u.sees))) or\n    (p in Ad and u in User)\n}",
                    "{\n\t  // Users can see ads posted by everyone,\n \n  all p: Ad | all u: User | p in u.sees\n\n  \n  all p: Photo - Ad | all u: User | p in u.sees implies (u in u.follows or p in u.posts)\n  \n}",
                    "{\n  \n  all p: Ad | all u: User | p in u.sees\n\n  \n  all p: (Photo - Ad), u: User | p in u.sees implies ((u in u.follows) implies (p in u.posts))\n}",
                    "{\n  \n  all p: Ad | all u: User | p in u.sees\n\n  \n  all p: (Photo - Ad), u: User | p in u.follows\n  no ad: Ad | all u: User | ad in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad | (all u : User | a in u.posts) implies (all u : User | a in u.sees)\n\tall p : Photo | all u1 : User | (not (p in Ad) and p in u1.sees) implies (some u2 : User | u2 in u1.follows and p in u2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.sees = (Ad + u.follows.posts + u.posts - (Ad - u.posts))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.suggested = Ad + u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some (u.sees & Ad)\n  \tall u: User | some (u.sees & u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | u.sees in Ad\n  \t\n  \tall u: User | (u.follows.posts) not in u.sees\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a in u.sees\n  \t\n  \tall u: User | (User.posts - u.posts) in u.sees \n  \t\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a in u.sees\n  \t\n  \tall u: User | (User.posts - u.posts) not in u.sees \n  \t\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | (a in u.sees) or (u.posts not in u.sees)\n  \tall u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, p: Photo |\n    p in u.sees =>\n      (p in u.posts and p !in Ad) or\n      (p in Ad and p in (u.follows.posts + posts.Ad))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall disj u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | (u.posts) not in Ad\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall disj u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | u.sees not in Ad\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \tall disj u1: User, u2: User | (u2 in u1.follows) implies (u2.posts in u1.sees)\n  \tall u: User | (u.sees & Ad) not in u.posts\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | all p: Photo | (posts.p in u.follows) implies (p in u.sees)\n  \t\n  \t\n  \t\n  \t\n  \t\n  \t\n\t\n  \t\n  \t\n  \t\n  \t\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u0,u1: User | u0.sees in u1.posts\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, ad:Ad| ad in u.sees\n  \tall p: Photo - Ad, u: User | p in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad: Ad | all u: User | ad in u.sees\n\tall p: Photo - Ad | some u:User | p in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad: Ad | all u: User | ad in u.sees\n\tall p: Photo - Ad | some u:User | p in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  some ad: Ad | all u: User | ad in u.sees\n\tall p: Photo - Ad | all u:User | p in u.sees implies some v: u.follows | p in v.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall ads: Ad | one sees.ads\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n    \n    \n\n    \n    \n\n    \n    \n     \n\tall u : User, a : Ad | u->a in sees implies\n\t    some u1 : User | u1->a in posts and u1->u in follows\n  \n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tno p: User | p in p.follows\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall u : User, a : Ad | a in u.sees\n\t// but only see non ads posted by followed users.\n  \tall u1,u2 : User, p : Photo | p not in Ad and p in u1.sees and p in u2.posts implies u2 in follows.u1\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | some x: u.follows | u.sees in x.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u,v: User | all a: Ad | a in u.sees and v in u.follows implies v.posts in u.sees\n\n}",
                    "{\n  // Users can see ads posted by everyone, \n  // but only see non ads posted by followed users.\n  all user: User | all fuser : user.follows | user.sees in fuser.posts\n  all user: User | all ad: Ad | ad in user.sees\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n  // but only see non ads posted by followed users.\n  all user: User | all fuser : user.follows | all ad: Ad |user.sees in fuser.posts implies ad not in user.sees else ad in user.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some(u.sees & Photo-Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | some x: u.follows | all a: Ad | u.sees in x.posts <=> u.sees in a\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x: User, p : Photo | Ad in x.sees or posts.p in x.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | some x: u.follows | all a: Ad | u.sees in x.posts <=> !(u.sees in a)\n\n}",
                    "{\n\tall u:User, p:Photo | p in u.sees\n  \tall u:User | u in u.sees implies u in u.follows else u not in u.follows \n  \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | some x: u.follows | all a: Ad | u.sees in x.posts || !(u.sees in a)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | all a: Ad | u.sees in x.posts || !(u.sees in a)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | all a: Ad | u.sees in x.posts <=> u.sees in a\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | one a: Ad | u.sees not in x.posts implies u.sees in a\n\n}",
                    "{\n\tall u:User, p:Photo | p in u.sees and u not in u.follows implies p in Ad\n  \tall u:User, p:Photo | p in u.sees implies u in u.follows else u not in u.follows \n  \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | u.sees not in u.follows.posts implies u.sees in Ad\n\n}",
                    "{\n\tall u:User, p:Photo | p in u.sees and u not in u.follows implies p in Ad\n  \tall u:User, p:Photo | p in u.sees and p not in Ad implies some u2:User | u2 in u.follows and p in u2.posts \n  \n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n   all u:User, p : Photo |  some(u.sees - Ad) implies  some(u.follows & posts.p)\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | one x: u.follows | u.sees not in x.posts implies u.sees = Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : (u.posts-Ad) | u not in User.follows implies p  not in User.sees   \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u:User | u.sees in (u.follows.posts - Ad - u.posts)  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User, p:Photo | p in u.sees and p in u.follows.posts implies p not in Ad else p in Ad \n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all o,e : User | all a : Ad | o->a in posts implies e->a in sees\n    all p : Photo | some a,b : User | b->p in posts and a->p in sees implies a->b in follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | all a : User | some b : User | a->p in posts and b->p in sees implies b->a in follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall user: User | all fusers: user.follows | all ad: Ad | fusers.sees in user.posts  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all ad : Ad, photo : Photo | lone sees.ad & follows.sees.photo\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | all a : User | some b : User | all e : Ad | p!=e implies a->p in posts and b->p in sees implies b->a in follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u in sees.Ad\n  \tall u : User | u not in posts.Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all a : Ad | x.sees in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all ad : Ad  | ad in u.sees\n  all u : User | u.sees = u.follows.posts and u.sees = u.posts  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | all a : Ad | some e : User | some d : User | ((p != a and e->p in posts) and d->p in sees) iff d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall user: User | all fusers: follows.user | all ad: Ad | fusers.sees in user.posts and user.sees in user.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | p in Ad and p not in u.sees implies posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | some e : User | some d : User | (e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | some e : User | all d : User | (e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all ad : Ad | some sees.ad\n    all photo : User.follows | some sees.photo\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \n  \n  \n  \n  all u: User, p: Photo |\n        (p in u.sees) =>\n        (p in Ad || (p in u.posts && p in (u.follows.posts)))\n\n}",
                    "{\n    // Users can see ads posted by everyone, \n    // but only see non ads posted by followed users.\n  all user: User |\n    user.sees = (user.posts - Ad) + (User.follows.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees and p in u.sees implies a in u1.posts and u1 in u.follows or u != u1\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a : Ad | a in u.sees\n  all u1,u2 : User, p : Photo | p in u1.sees implies u1 in u2.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User, ad : Ad, p : Photo | p in u2.posts and p in u1.sees implies u2 in u1.follows \n  \tall u1,u2 : User, ad : Ad, p : Photo | ad in u2.posts implies ad in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all a : Ad | all p : Photo | all e,d : User | (e!=d and e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees or p in u.sees implies p in u1.posts and u1 in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | all a : Ad |  e->a in sees\n    all p : Photo | all e,d : User | (e!=d and e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall user: User | all fusers: follows.user | all ad: Ad | (user.sees in user.posts) implies user.posts in Ad and fusers.sees in user.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | some a : Ad |  e->a in sees\n    all p : Photo | all e,d : User | (e!=d and e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall user: User | all fusers: follows.user | all ad: Ad | user.sees in ad and (fusers.sees in user.posts)\n\n}",
                    "{\n    // Users can see ads posted by everyone, \n    // but only see non ads posted by followed users.\n  all user: User |\n    user.sees = (user.posts) + (User.follows.posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | all a : Ad | a in u.sees and a not in u.posts and p in u.sees implies u1 in u.follows and p in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | some a : Ad |  e->a in sees\n    all p : Photo | all e,d : User | (e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User, p : Photo | p in u2.posts and p in u1.sees implies u2 in u1.follows else p in u1.posts\n  \tall u1,u2 : User, ad : Ad, p : Photo | ad in u2.posts implies ad in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | all p : Photo | some a : Ad | a in u.sees and p in u.sees implies u1 in u.follows and p in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  some u : User | some u1:User | some p : Photo | some a : Ad | a in u.sees and p in u.sees implies u1 in u.follows and p in u1.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User, p : Photo | p in u1.sees implies u2 in u1.follows or p in u1.posts\n  \tall u1,u2 : User, ad : Ad, p : Photo | ad in u2.posts implies ad in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User, p : Photo | p in u1.sees implies u2 in u1.follows and p in u2.posts or p in u1.posts\n  \tall u1,u2 : User, ad : Ad, p : Photo | ad in u2.posts implies ad in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | (posts.Ad + u.follows.posts) in u.sees and (User.posts - (posts.Ad + u.follows.posts)) not in u.sees\n}",
                    "{\n    // Users can see ads posted by everyone, \n    // but only see non ads posted by followed users.\n  all user: User |\n    user.sees in (user.posts) + (User.follows.posts) +Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | some p : Photo | some a : Ad | (a in u.sees) and (p in u.sees implies u1 in u.follows and p in u1.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall user : User | user.sees in Ad and some user.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n  all u : User, a : u.sees & Ad | one posts.a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, i : Photo | u->i in sees implies i = Ad or some v : User | u->v in follows and v->i in posts or u->i in posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | all u1:User | some p : Photo | all a : Ad | (a in u.sees) and (p in u.sees implies u1 in u.follows and p in u1.posts and u!=u1)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all e : User | some v : User | some a : Ad |  v->a in posts implies e->a in sees\n    all p : Photo | all e,d : User | (e->p in posts and d->p in sees) implies d->e in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | some u1:User | some p : Photo | some a : Ad | (a in u.sees) and (p in u.sees implies u1 in u.follows and p in u1.posts and u!=u1)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees\n  \tall u : User | u.follows.posts in u.sees\n  \tall u : User | (User.posts - Ad - u.follows.posts - u.posts) not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall a:Ad | some u:User | a->u in sees\n  \tall p:Photo, u:User | sees.p = follows.u \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall a:Ad | some u:User | u->a in sees\n  \tall p:Photo, u:User | sees.p = follows.u \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u:User | all a:Ad | u->a in sees\n  \tall u1, u2:User | all p:Photo | \n  \t(u1->p in sees) implies (u1->u2 in follows and u2->p in posts and p not in Ad)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all p: Photo | all a: Ad | p in u.sees and p in a\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all p: Photo | all a: Ad | p in u.sees and p in a\n  all u: User, u1 : User | all p: Photo | p in u.sees and u1 in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all p: Photo | p in u2.posts and p in u1.sees\n  \tall u1, u2: User | all a: Ad | a in u2.posts and u2 in u1.follows implies a in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and u2 in u1.follows <=> p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees and u1 not in Influencer\n  \tall u1, u2: User | all p: Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and (u2 in u1.follows and u1 not in Influencer and u2 not in Influencer) implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and (u2 in u1.follows or (u1 not in Influencer and u2 not in Influencer)) implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | p in u2.posts and (u2 in u1.follows or (u1 in Influencer and u2 in Influencer)) implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: Influencer | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: Influencer | all p: Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | (u1 != u2 and p in u2.posts and u2 in u1.follows) <=> p in u1.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 and (p in u1.posts and u2 in u1.follows) implies p in u1.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 and (p in u2.posts and u2 in u1.follows) implies p in u1.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 and (p in u2.posts and p in u1.sees) implies u2 in u1.follows\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 or (p in u2.posts and u2 in u1.follows) implies p in u1.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: User | all p: Photo | u1 != u2 and (p in u2.posts and u2 in u1.follows) implies p in u1.sees\n  \tall u1, u2: Influencer | all a: Ad | u1 != u2 and a in u2.posts and a in u1.sees\n  \tall u1, u2: Influencer | all p: Photo | u1 != u2 or (p in u2.posts and u2 in u1.follows) implies p in u1.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, p: Photo |\n\t\tp in u.sees <=>\n\t\t(p in Ad && p not in u.posts) ||\n\t\t(p not in Ad && (p in u.follows.posts or p in u.posts))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, p: Photo |\n\t\t(p in Ad => p not in u.posts) &&\n\t\t(p in u.sees => (p in Ad && p not in u.posts) || (p not in Ad && (p in u.follows.posts or p in u.posts)))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    (all a: Ad | a in u.sees) and\n    (all p: Photo - Ad | p in u.posts and some f: u.follows | p in f.sees)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad,  u : User | a in u.sees\n  \tall u : User | u.posts in Ad+u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = Ad + u.follows.*posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User |\n\t\tu.sees = u.posts - Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tUser.sees & Ad = Ad and\n  \t(all p: Photo|all u: User|\n  \t(p not in Ad and p in ((u.follows).posts)) implies p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t(all p: Photo|all u: User|\n  \t((p not in Ad and p in ((u.follows).posts)) iff p in u.sees) and\n  \t(p in Ad iff p in u.sees)\n)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t(all u: User| all p: Photo|\n\t(p in Ad implies p in u.sees) and \n  \t(p in (u.follows).posts) and p not in u.posts implies p in u.sees)\n\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u:User, a:Ad |\n  \ta in u.sees implies  one other:User-u | a in other.posts && other not in u.follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u:User, p:Photo , other:User-u|\n\tp in u.sees implies ((p in other.posts) && ( other in u.follows)) or u.sees in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u : User, cont : Photo-Ad | (u.follows.posts & cont) + Ad = u.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u : User, cont : Photo-Ad | (u.follows.posts & cont) + Ad in u.sees\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u : User, cont : Photo-Ad, p : Photo | p in u.sees implies (p in Ad or u.follows.posts in cont)\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.posts | p in Ad => p in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | Ad in u.sees\n  \tall u: User, p: Photo - Ad | p in u.sees implies (posts.p in u.follows or posts.p = u)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Photo | u in sees.a implies a in Ad or\n  \tall u1 : User | u1 in sees.a and u1 in follows.u\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u,u1 : User | (u1.posts & Ad in u.sees) and (u1 in u.follows implies u1.posts - Ad in u.sees) and (u.sees not in u.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u,u1 : User - Influencer | (u1.posts & Ad in u.sees) and (u1 in u.follows implies u1.posts - Ad in u.sees) \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tAd in User.sees \n  \tAd in User.posts \n  \tall u : User , p : (Photo-Ad) | p in u.sees implies posts.p in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u1: User | one u2: User | all p: Photo | p in u1.sees implies (p in Ad) or (p in u2.posts and u2 in u1.follows)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n\tall u : User, a : u.sees | a = Ad + u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u:User, u2:User | u2 in u.follows => {\n        all a:Ad | a in u2.posts => a not in u.sees else {\n            a in u.sees\n        }\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u:User, u2:User | u2 in u.follows => {\n        all a:Ad | a in u2.posts => a not in u.sees else {\n            a in u.sees\n        }\n    }\n        else{\n            all p:Photo | p in u2.posts => p in u.sees\n\n        }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u:User, u2:User | u2 in u.follows => {\n        all a:u2.posts | a not in u.sees\n    }\n    else{\n        all p:Photo | p in u2.posts => p in u.sees\n\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (all v: User | p in v.posts)) ||\n\t\t((p not in Ad) && (some v: User | (v in u.follows) && (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (all v: User | (v not in u.follows) && (p in v.posts))) ||\n\t\t((p not in Ad) && (some v: User | (v in u.follows) && (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (some v: User | (v not in u.follows) && (p in v.posts))) ||\n\t\t((p not in Ad) && (some v: User | (v in u.follows) && (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (all v: User | (v not in u.follows) && (p in v.posts))) ||\n\t\t((p not in Ad) && (all v: User | (v in u.follows) && (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (all v: User | (v not in u.follows) => (p in v.posts))) ||\n\t\t((p not in Ad) && (some v: User | (v in u.follows) => (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t\n\n\tall u: User, p: Photo | (p in u.sees) implies\n\t\t((p in Ad) && (all v: User  - u| (v not in u.follows) => (p in v.posts))) ||\n\t\t((p not in Ad) && (some v: User - u  | (v in u.follows) => (p in v.posts)))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Ad | a in u.sees\n  \tall u : User | all p : Photo | one u2:User | \n  \t\t\tp in u.sees => (p in Ad or (p in u2.posts and u2 in u.follows))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all p : Photo | one u2:Influencer | \n  \t\t\tp in u.sees => (p in Ad or (p in u2.posts and u2 in u.follows))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all p : Photo | one u2:User | \n  \t\t\tp in u.sees => (p in Ad or p in u.posts or \n              \t\t(p in u2.posts and u2 in u.follows))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | u.sees in Ad\n  \tall disj u,u1 : User | some p : u1.posts | u1 in u.follows and  p in u.sees and p not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo-Ad | u->Ad in sees or (u->p in sees and u->(posts.p) in follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User | all a: Ad | a in u.sees\n\tall u : User | all p : Photo | all a: Ad | p not in a and p not in u.follows.posts => p not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees\n  \tall u : User | (u.follows-Ad) in u.sees \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1:User, u2:User, p:Photo | p in Ad => p in u1.sees && u2.sees in u1.posts => u2 in u1.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1:User, u2:User, p:Photo | p in Ad => p in u1.sees && u1 in u2.follows => u2.sees in u1.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all a : Ad | a in u.sees\n  \tall u : User | one p : Photo | (p not in Ad) implies (p not in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all a : Ad | a in u.sees\n  \tall u : User | all p : Photo | (p not in Ad) implies (p not in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo, u1, u2 : User | p not in Ad and p in u1.sees and p in u2.posts iff u2 in u1.follows  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \tall u : User | all p : Photo | u in sees.p implies p in Ad or some u1 : User | u1 in posts.p and u.follows in u1\n\t\n  \tall u : User | all p: Photo | u in sees.p implies p in Ad or some posts.p & u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall ad : Ad | ad in (some User.sees)\n\t// but only see non ads posted by followed users.\n\tall u : User | all na : u.sees-Ad | na in u.follows.posts\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \tall p: Photo - Ad | all u: User | posts.p in u.follows implies u->p in sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo-Ad | some (sees.p) implies one (sees.p).posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall user1: User, user2: User, ad: user1.posts & Ad | ad in user2.sees\n    all user1: User, user2: user1.follows, ad: user2.posts | ad not in user1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall user1: User, user2: User - user1.follows, ad: user1.posts & Ad | ad in user2.sees\n    all user1: User, user2: user1.follows, ad: user2.posts | ad not in user1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall user1: User, user2: User - user1.follows - user1, ad: user1.posts & Ad | ad in user2.sees\n    all user1: User, user2: user1.follows, ad: user2.posts | ad not in user1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n    \n  \n  \tall u1: User, u2: u1.follows, p: u2.posts | p in u1.sees && p not in Ad\n    all u1: User, u2: User - u1.follows, p: u2.posts & Ad | p in u1.sees \n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u1: User, u2: u1.follows, p: u2.posts | p in u1.sees && p not in Ad\n    all u1: User, u2: User - u1.follows - u1, p: u2.posts & Ad | p in u1.sees \n  \t\n}",
                    "{\n    all u: User | \n        \n        all a: Ad | a in u.sees and\n        \n        all p: Photo - Ad | p in u.sees iff p in (u.follows + u).posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n   all u: User, p: Photo |\n    (p in Ad implies p in u.sees) and \n    (p !in Ad and p in u.sees implies no f: u.follows | p !in f.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n    (p in Ad implies p in u.sees) and\n    (p !in Ad implies (some f: u.follows | p in f.posts) or u.follows = none)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo - Ad | \n  \t\t(Ad in u.sees) and\n  \t\t(p in u.sees => posts.p in u.follows)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t3 < 0\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n\t\tp in u.sees =>\n\t\t\t(p in u.posts and p not in Ad) or\n\t\t\t(p in Ad and all f: u.follows | p in f.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n\t\tp in u.sees =>\n\t\t\t(p in Ad and all f: u.follows | p in f.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: u.sees | p in Ad => all f: u.follows | p in f.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User, p:User.sees |\n  \t\tone u2:User-u |\n  \t\t\t(p in Ad) implies p in u2.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User, p:User.sees |\n  \t\tone u2:User-u |\n  \t\t\t(p in Ad) implies p in u2.posts\n  \n  all u:User, p:User.sees |\n  \tone u2:User-u |\n  \t\t(p not in Ad) implies u2 in u.follows\n\n}",
                    "{\n\tall u: User, p: Photo |\n        (p in Ad implies p in u.sees) and\n        (p in u.posts implies (p in u.sees or some f: u.follows | p in f.posts))\n\n}",
                    "{\n\tall u: User, p: Photo |\n        (p in Ad implies p in u.sees) and\n        (p not in Ad implies (p in u.sees or some f: u.follows | p in f.posts))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | (p in u.posts && p in u.sees) or (p in u.posts && p in u.follows.posts && p in u.sees) or (p in Ad && p in u.sees)\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | (p in u.posts) or (p in u.posts && p in u.follows.posts && p in u.sees) or (p in Ad && p in u.sees)\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo | (p in u.posts) or ( p in u.follows.posts && p in u.sees) or (p in Ad && p in u.sees)\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = u.follows + u.posts + Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo |\n        (p in u.sees implies p in Ad) &&\n        (p not in Ad implies p in u.follows.posts)\n  \n\n}",
                    "{\n    // Users can see ads posted by everyone,\n    \n    all u: User |\n        u.sees = Ad + (Photo - Ad) && u.sees = u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | u.sees in u.follows.posts implies Ad not in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    no a : Ad, u : User | u.sees in (u.follows.posts - a)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Ad, u : User | a in u.posts implies u.sees = u.posts - a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | some a : Ad | a in u.sees implies a not in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | sees.u = Ad + u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u : User | u.sees in Ad and u.sees in (u.posts + u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall na: Photo - Ad | posts = sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u : User - Influencer | u.follows.posts in u.sees and Ad in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u : User - Influencer | u.follows.posts in u.sees\n  Ad in User.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all u : User - Influencer | u.follows.posts in u.sees\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.follows.posts in u.sees\n  all u : User | (Ad - u.posts) in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User, ads : Ad | u1.sees in ads or  u1.sees in u2.posts and u2 in u1.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : (User - Influencer) | u.sees = Ad + u.follows.posts - u.posts\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.follows.posts in u.sees\n  all u : User | no u.posts & u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n      all u: User | {\n        // Users can see ads posted by everyone\n        all p: Photo | p in u.sees iff p in Ad or\n        \n        (some p1 : Photo - Ad | p1 in u.sees and some f: u.follows | p1 in f.posts)\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n      all u: User, p: Photo | u not in Influencer implies { \n        p in u.sees iff p in u.follows.posts or p in Ad\n      }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n      all u: User, p: Photo | { \n        p in u.sees iff p in (u.follows - Influencer).posts or p in Ad\n      }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees != u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees not in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  sees in User one -> Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    all p: Photo | \n      (p in Ad and p not in u.posts implies p in u.sees) and\n      (p not in Ad implies (some f: u.follows | p in f.posts) implies p in u.sees) and\n      (p in Ad and p in u.posts implies p not in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | \n    all p: Photo | \n      (p in u.posts implies p not in u.sees) and\n      (p in Ad and p not in u.posts implies p in u.sees) and\n      (p not in Ad and p in u.posts implies p not in u.sees) and\n      (p not in Ad implies (some f: u.follows | p in f.posts) implies p in u.sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    Ad in User.sees - User.posts\n\tall u : User | u.follows.posts in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    Photo in User.sees - User.posts\n\tall u : User | u.follows.posts in u.sees\n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    \tu.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n    all i: Influencer |\n  \t\ti.sees = { p: Photo | p in Ad and p in i.posts}\n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    \tu.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n    all i: Influencer |\n  \t\ti.sees = { p: Photo | p in Ad and p in (i.follows.posts +i.posts)}\n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    \tu.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n    all i: Influencer |\n  \t\ti.sees = Ad + i.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n    User.posts not in User.sees\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n    (User-Influencer).posts not in (User-Influencer).sees\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n    all u: (User-Influencer)| u.posts not in u.sees\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n    all u: (User-Influencer)| (u.posts-Ad) not in u.sees\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u : User | u.follows.posts in u.sees\n    all u:  User | u.posts not in u.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: User | u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n    all i: Influencer | all p: i.posts | p not in Ad and p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: User | u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n    all i: Influencer | all p: i.posts | p in Ad and p in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: User | u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all p: (Photo-Ad) | p in i.posts and p in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: User | u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all p: Ad | p in i.posts and p in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: User | u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all p: Photo - Ad | p in i.posts and p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | i.posts not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | (i.posts-Ad) not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all a: Ad & Influencer.posts |\n             a not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all a: Ad & Influencer.posts |\n             a in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tAd in (User-Influencer).sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n    all i: Influencer | all a: Ad | a in i.posts =>\n             a in i.sees\n  \n    all i: Influencer | all p: Photo - Ad | p in i.posts => p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tAd in User.sees\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n\n \n  \n    all i: Influencer | all p: (Photo - Ad) | p in i.posts and p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tUser.sees= Ad\n\tall u: (User - Influencer)| u.follows.posts in u.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n\n \n  \n    all i: Influencer | all p: (Photo - Ad) | p in i.posts and p not in i.sees\n\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n\tUser.sees= Ad\n\t\n  User.follows.posts = User.sees\n    all u: (User-Influencer)\n           | u.posts not in u.sees\n\n\n \n  \n    all i: Influencer | all p: (Photo - Ad) | p in i.posts and p not in i.sees\n\n  \n}",
                    "{\n\t\n\t\n    \n    all u: User-Influencer | \n    \tu.sees = { p: Photo | p in Ad and p in (u.follows.posts - u.posts)}\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n\tAd in User.sees\n\tall u : User | u.follows.posts in u.sees\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n\tall u : User |  u.sees = Ad + u.follows.posts\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n\tall u : (User-Influencer) |  u.sees = Ad + u.follows.posts\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | i in Ad\n\tall u : (User-Influencer) |  u.sees = Ad + u.follows.posts\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | i.posts in Ad\n\tall u : (User-Influencer) |  u.sees = Ad + u.follows.posts\n    no { p: Photo | some i: Influencer | p in i.sees and p in i.posts and not p in Ad }\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | i.posts in Ad\n\tall u : User |  u.sees = Ad + u.follows.posts\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | all p : i.posts | p not in Ad and p not in i.sees\n\tall u : (User-Influencer) |  u.sees = Ad + { p: u.follows.posts| p not in Ad}\n}",
                    "{\n\t\n\t\n    \n    Influencer.sees = Ad\n    Influencer.posts = Ad\n\tall u : (User-Influencer) |  u.sees = Ad + { p: u.follows.posts| p not in Ad}\n}",
                    "{\n\t\n\t\n    \n    all i : Influencer | i.sees = Ad + i.follows\n\tall u : (User-Influencer) |  u.sees = Ad + { p: u.follows.posts| p not in Ad}\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | posts.p = u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p: Photo, u : User | posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u: User | all f : u.follows | no (u.sees & f.posts & Ad) and no (u.sees & u.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  \tall u: User | all f : (u.follows + u) | no (u.sees & f.posts & Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall ad: Ad, u: User | ad in u.sees\n  \tall p: Photo - Ad, u: User | p in u.sees => (posts.p in u.follows) or (p in u.posts)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n\t\n\t\n\n\t\n\t\n  \n\t\n\t\n  \n\t\n\t\n\t    \n\t\n\n\t\n\n\t\n  \n\t\n\n\t\n\n\t\n\n\t\n\n\t(all u, u1 : User | (some (u.sees-Ad)&u1.posts) implies u->u1 in follows) iff  (all u : User | u.sees in Ad + u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all y : Ad | x->y in sees\n  all x : User | all y : User | all z : Photo |  (x->z in sees) and (x->y in follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x: Photo, y: User | lone posts.x && one follows.y\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x: Photo | one posts.x\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x: Photo, y: User | one posts.x && one follows.y\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all y : Photo | all z : User | ((y in Ad and x->z not in follows) or (x->z in follows and z->y in posts and y not in Ad)) implies (x->y in sees) \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User | all y : Photo | all z : User | ((y in Ad and x->x in follows) or (x->z in follows and z->y in posts and y not in Ad)) implies (x->y in sees) \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a : Ad | all u : User | a in u.sees iff not a in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all x, y : User | x->y in follows and y -> x in follows implies x in y.sees\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n  \tall x: User,z: Photo | x -> z in sees\n \tall x,y:User ,z:Photo| x -> z in posts and y -> z in sees implies x -> y in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo | some x : User | some y : User | x != y and p in x.posts and p in y.sees implies x in y.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tsome p : Photo | all x : User | all y : User | x != y and p in x.posts and p in \t\ty.sees implies x in y.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tno p : Ad | all x : User | all y : User | x != y and p in x.posts and p in y.sees implies x in y.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x : User, a : Photo | some y : User | a in x.posts and y in sees.a implies y in x.follows \n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u : User | u.sees in u.posts\n\t// but only see non ads posted by followed users.\n  all f : Photo | (f not in Ad) and (sees in follows.posts)   \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u : User | u.posts in u.sees\n\t// but only see non ads posted by followed users.\n  all f : Photo | (f not in Ad) and (sees in follows.posts)   \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u : User | (u.sees in Ad) or (u.sees in u.follows.posts) or (u.sees in u.posts)\n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo |\n  \t(p in Ad implies p in u.sees)\n  \tand (p not in Ad implies one poster : User | poster in u.follows and p in poster.posts implies p in u .sees)\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Ad | u -> a in sees\n  \tall u : User, p : Photo | p in Ad and u -> p in sees implies all u2 : posts.p | u -> u2 in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, a : Ad | u -> a in sees\n  \tall u : User, p : Photo | p in Ad and u -> p in sees implies all u2 : posts.p | u != u2 and u -> u2 in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User.follows.sees | Ad not in u\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x: Photo, y,z: User | (not x in Ad) and User->Photo in sees and User->Photo in posts implies User->User in follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, p : Photo - Ad | u.sees in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x: User | all y: User | some w : Ad | (x->y in follows and y->w in posts) implies x->w in sees \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, p : Photo - Ad | lone( u.follows & sees.p)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User, p: Photo - Ad | \n    p in u.sees iff posts.p in u.follows  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all x : User, y: Ad | y in x.sees\n  and all u,x :User, y: Photo - Ad | y in u.posts and y in x.sees implies u in x.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, p : Photo - Ad | u in sees.p & u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x,z:User, y:Photo-Ad | y in x.sees and z in x.follows implies x not in z\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:User-x.follows | y.posts not in x.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x:User, y:User-x.follows | y.posts not in x.sees - Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User| u.sees - Ad not in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x: User | all y: User | some w : Photo | (not x->y in follows and y->w in posts and not w in Ad) implies (not x->w in sees)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in sees.ad and u not in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in follows.sees.ad and u not in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in follows.posts.ad and u not in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in follows.posts.ad and u in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, ad: Ad, na: Photo - Ad | u in follows.posts.na\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all ads : Ad, nonAds : Photo - Ad, user : User | one sees.ads\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all ads : Ad, nonAds : Photo - Ad, user : User | \n  \t\tsees.ads = Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all x: Photo-Ad, u:User | sees.x = u.follows.posts\n    \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all a: Ad, u: User | a in u.sees and u.follows.posts in u.sees and a not in u.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all a: Ad, u: User | a in u.sees and u.follows.posts in u.sees and u.posts not in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | u.follows.posts in u.sees and u.posts not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  Ad in User.sees\n  all u: User | u.follows.posts in u.sees - Ad\n}",
                    "{\n    // Users can see ads posted by everyone\n    \n    \n    \n  \n  \n\t// Users can see ads posted by everyone\n\tall u: User, p: Ad | p in u.sees\n\t\n\tall u: User, p: Photo |\n    \tp not in Ad implies (\n      \t\tp in u.sees iff (\n        \t\tsome y: User | y in u.follows and p in y.posts) or\n          \t\tp in u.posts\n    \t)\n}",
                    "{\n    // Users can see ads posted by everyone\n    all u : User, a : Ad | a in u.sees\n  \n    \n    all u : User| some p : Photo |\n        p not in Ad implies (\n            p in u.sees iff (\n                some y : User | p in y.posts and y in u.follows\n            )\n        )\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Photo | all u1,u2 : User | (a in u1.sees ) iff ( a in Ad ) or ( u2 in u1.follows and a in u2.posts )\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all a : Photo | all u1,u2 : User | (a in u1.sees ) iff ( ( a in Ad ) or ( u2 in u1.follows and a in u2.posts ) )\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User | all a:Ad| u.sees in a.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall x: User | some sees.x\n\t// but only see non ads posted by followed users.\n\tall p: Photo | p not in Ad \n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u : User | all p : Photo| p not in Ad implies some ad : Photo | ad in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u : User | not sees.Ad in follows.u\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some sees.x\n\t\n  \tall x : Photo, u : User | not Ad in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | some ad: Ad | ad in u.sees \n\tall u: User | some p: Photo | p in u.sees implies (some f: User | u in f.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n\tall u: User | some p: Photo | p in u.sees implies (some f: User | u in f.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all x: User | all y: Ad | y in x.sees\n  all w: User | all p: Photo | some z: w.follows | (not p in Ad and p in w.sees) => p in z.posts \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p : Photo | posts.p.follows in sees.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some sees.x\n\t\n  \tall x : Photo, u : User | u.follows not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some sees.x\n\t\n  \tall x : Photo | User.follows not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all a : Ad | some sees.a\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n\tall u: User | some p: Photo | p in u.sees implies (some f: User | u in f.follows and p in f.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all x : Ad | some sees.x\n\t\n  \tall x : Photo, u : User | (posts.x in u.follows and x not in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all w: User | all p: Photo | some z: w.follows | (not p in Ad) => p in z.posts and p in w.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \t\n\t// but only see non ads posted by followed users.\n  \tPhoto - Ad in User.follows\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users\n   all u: User | some a : Ad |\n        u.sees = Ad + (u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n  \tall x : Photo, u : User | x = Ad or posts.x in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n  all w: User | all p: Photo | all z: w.follows | (not p in Ad) => p in z.posts and p in w.sees and p in w.posts\n\n}",
                    "{\n    User -> User in sees.(~posts)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n  \tall x : Photo, u : User | Ad in sees.x or posts.x in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo | p not in Ad => posts.p in sees.p.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all p: Photo | \n    (p in Ad => all u: User | p in u.sees) and\n    (p not in Ad => all u: User | p in u.sees && posts.p in u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all p: Photo |\n    (p not in Ad => all u: User | p in u.sees && posts.p in u.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\t\n\tall u: User | some p: Photo | p in u.sees implies ((some f: User | f in u.follows and p in f.posts) or p in Ad)\n}",
                    "{\n    User -> User in sees.(iden & (Ad -> Ad)).(~posts).follows\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n\t// but only see non ads posted by followed users.\n  all u : User | all p : Photo| \n  (p in Ad implies all poster : User | p in u.sees and p in poster.posts) and \n  (p not in Ad implies \n    (all poster : User | poster in u.follows and p in poster.posts and p in u.sees))\n}",
                    "{\n    User -> User in sees.(iden - (Ad -> Ad)).(~posts).((User -> User) -  follows)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2:User | some p:Photo| p in sees.u1 implies (u2 in follows.u1 or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2:User | some p:Photo| p in u1.sees implies (u2 in follows.u1 or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2:User | some p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in posts.u2) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1:User | one u2:User | some p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1:User | one u2:User | one p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1:User | one u2:User | all p:Photo| p in u1.sees implies ((u2 in follows.u1 and p in u2.posts) or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p : Photo | one sees.p\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall u1 ,u2 : User |all ad : Ad |  u2.posts in u1.sees \n\t// but only see non ads posted by followed users.\n  \t\n  \t\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall x: User | (some Ad & x.sees) and ((some x.follows) implies (x.follows.posts in x.sees))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, ad: Ad | {\n      u.sees = ad + u.follows.posts + u.posts\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a in u.sees\n  \tall u: User | u.follows.posts in u.sees\n  \tall u: User | (User - u.follows) not in u.sees\n  \t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad, f: u.follows.posts | {\n      u.sees = a + f\n      \n  \t}\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tAd in User.sees\n  \tUser.posts - User.follows.posts not in User.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  all u : User |\n  \n  \tsome p: u.sees | some f: u.follows | p in Ad or p in f.posts\n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | all u: User | ad in u.sees\n  all u : User | some p : u.sees | p in Ad or p in u.follows.posts\n  \n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | all u: User | ad in u.sees\n  all u : User | some p : u.sees | p in Ad or p in u.follows.posts or p in u.posts\n  \n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | \n  \tall u: User | \n  \t\tad in u.sees\n  \n  all u : User | \n  \tsome p : u.sees |\n  \t\tall f : u.follows |\n  \t\tp in Ad or p in f.posts or p in u.posts\n  \n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all ad : Ad | \n  \tall u: User | \n  \t\tad in u.sees\n  \n  all u : User | \n  \tall p : u.sees |\n  \t\tall f : u.follows |\n  \t\tp in Ad or p in f.posts or p in u.posts\n  \n  \t\t\n \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall x, y: User, z: Photo | z in x.sees implies (z in Ad or (z not in Ad and y in x.follows and z in y.posts and y not in Influencer))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n    all u: User, a: Ad | a in u.sees\n\n    \n    all u: User, p: Photo | \n        \n  \tsome v: User | p in v.posts and v in u.follows\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n    all u: User, a: Ad | a in u.sees\n\n\t// but only see non ads posted by followed users.\n\tall u: User, a: Ad | a not in u.sees some date\n  \n  \t\n}",
                    "{\n  // Users can see ads posted by everyone, \n  // but only see non ads posted by followed users.\n  all u : User | u.sees in Ad\n  all u: User, p: Photo | p in u.sees iff ((p not in Ad) and p in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, f : u.follows | Ad in u.sees and f.posts in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = (Ad - (u.posts <: Ad) + (User <: u.follows).posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = Ad - u.posts <: Ad + (u.follows.posts <: (Photo - Ad))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u1, u2 : User, p : Photo, a : Ad |\n  (u1 -> p in sees && u1 -> u2 in follows) implies p not in Ad \n  \n  \n\n\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2 : User, p : Photo | u2 in u1.follows and p in u1.sees and p in u2.posts implies p in Ad \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1 : User, p : Photo | some u2 : User | u2 in u1.follows and p in u1.sees and p in u2.posts implies p not in Ad \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1, u2: User | all s: u2.sees| u2 not in u1.follows and s in Ad and s not in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1, u2: User | all s: u2.sees| u2 not in u1.follows and s not in Ad and s not in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1, u2: User | all s: u2.posts| u2 not in u1.follows and s not in Ad and s not in u1.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj x, y : User | all p : y.posts | (p in x.sees) iff (y in x.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj x, y : User | some ((x.sees - Ad) & x.posts) implies (y in x.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | all ad: Ad | ad in u.sees\n  \tall p: Photo - Ad | all u1, u2: User | p in u1.sees iff u2 in u1.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | all ad: Ad | ad in u.sees\n  \tall p: Photo - Ad | all u: User | all img: u.sees | posts.img in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | all s: (User - u).posts | s in Ad implies s not in u.sees \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2:User, p:Photo, a:Ad | u1 in u2.follows and p in u1.posts \n  \t\t\timplies p in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2, u3:User, p:Photo, a:Ad | \n  \t\t\tu1 in u2.follows and p in u1.posts and u3 not in u2.follows and a in u3.posts and a != p \n  \t\t\t\timplies \n  \t\t\tp in u2.sees and a in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u:User, a:Ad | a in u.sees\n  \n  all u1, u2:User, p: Photo - Ad | \n  \t\tp in u2.sees and p in u1.posts and u1 != u2 \n  \t\t\timplies \n  \t\tu1 in u2.follows \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n  all disj u1: User | all s: u1.sees | s not in Ad implies s in ((u1.follows).posts)\n  \n  all u:User, a:Ad | a in u.sees\n  \n  all disj u1, u2:User, p: Photo - Ad | \n  \t\tu1 in u2.follows and p in u1.posts \n  \t\t\timplies \n  \t\tp in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n\n \n  \n  \n  \n  all disj u1, u2:User, p: Photo - Ad | \n \t\tu1 in u2.follows and p in u1.posts \n \t\t\timplies \n \t\tp in u2.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, ad: Ad | all uu: u.follows| ad in u.sees implies not ad in uu.posts\n  \t\tand not ad in u.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | {\n        all ad: Ad | ad in u.sees implies {\n         \tad.~posts not in u.follows\t\n         }\n        \n    }\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall ad: Ad | all u: User | (ad-u.posts) in u.sees\n\t// but only see non ads posted by followed users.\n  \tand (u.follows.posts- ad) in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \tall ad: Ad | all u: User | (ad-u.posts) in u.sees\n\t// but only see non ads posted by followed users.\n  \tand ((u.follows.posts-ad)-u.posts) in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all ad: Ad | ad in u.sees and (ad not in u.follows.sees )\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, ad: Ad | ad in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User|some p: Photo | (p not in Ad && u1 -> p in sees && u2-> p in posts) implies (u2 in u1.follows) && u1 != u2\n  \t\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, ad: Ad | ad in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User|some p: Photo | (p not in Ad && u1 -> p in sees && u2-> p in posts) implies (u1 -> u2 in follows)\n  \t\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User, ad: Ad | ad in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | u1 != u2 and p not in Ad and u1 not in u2.follows implies p not in u2.sees \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u: User| some p: Photo | p in Ad implies p in u.sees\n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | (p not in Ad and u1 not in u2.follows) implies (p not in u2.sees)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \t\n  \tall u1, u2: User, p: Photo | (p not in Ad and u1 not in u2.follows) implies (p not in u2.sees)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo, u : (User - Influencer) | p in Ad implies p in u.sees\n  \tall u : (User - Influencer) | no (u.sees & Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | one u2 : User| all i : Photo | (i in Ad) implies i in u.sees\n  and ((i in u2.posts) and ( u2 in u.follows)) implies i in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \n  all u, u1 : User, p : Photo | u != u1 and u in follows.u1 implies u in sees.p\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall p : Photo | all u : User | (p in u.posts and p in Ad) implies p in u.sees\n  \tall p : Photo | all u : User | (p in u.posts and p !in Ad) implies p in u.follows.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all p : Photo - Ad, u : User | Ad in u.sees && u.sees in u.follows.posts \n\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall disj u : User | all p : u.sees |one u1 : User | (p not in Ad) implies p in u1.posts and u1 in u.follows\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall disj u : User , a : Ad | all p : u.sees |one u1 : User | (p in u1.posts and u1 in \tu.follows and u1 != u) or a in u.sees\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall a : Ad , u : User | a in u.sees or\n  \tall disj u1,u2 : User | all p : u1.sees | u2 not in u1.follows implies (p not \t  in u2.posts)  \n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall disj u1,u2 : User |one p : Photo | (u1 not in u2.follows and p in u2.sees) \timplies p in Ad  \n  \t\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t// but only see non ads posted by followed users.\n  \tall u1,u2 : Influencer |one p : Photo | ((p != Ad and u1 not in u2.follows) \t\timplies p not in u2.sees ) or p = Ad\n  \t\n\t\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u: User | all a: Ad, p: Photo - Ad | a in u.sees and (p in u.follows.posts => p in u.sees)  \n  \t\n}",
                    "{\n  \n  all u: User, a: Ad | a in u.sees\n  all u: User | #(u.sees & (u.posts - Ad)) = 0\n\n  \n  all u: User, p: Photo - Ad | p in u.follows.posts <=> p in u.sees\n}",
                    "{\n  \n  all u: User, a: Ad | a in u.sees\n  all u: User | #(u.sees & (u.posts - Ad)) = 0\n\n  \n  all u: User | some p: Photo - Ad | p in u.follows.posts => p in u.sees\n}",
                    "{\n  \n  all u: User, a: Ad | a in u.sees\n  \n\n  \n  all u: User | some p: Photo - Ad | p in u.follows.posts => p in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t\n\t\n  \tall u: User | \n        u.sees = (Ad + (Photo - Ad) & {p: Photo | some u.follows & p.(~posts)}) \n  \t\tor u.sees = none \n}",
                    "{\n\t// Users can see ads posted by everyone,\n  \t\n\t\n  \t\n        \n  \t\t\n  all u: User | {\n        \n        Ad in u.sees or #u.sees = 0  \n        \n        \n        all p: Photo - Ad | \n            p in u.sees iff some u.follows & p.(~posts)\n    }\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User | u.sees in (User - u).posts\n  \tall u: User | all p: Photo - Ad | p in u.sees <=> p in u.follows.posts \n\n}",
                    "{\n  all u1, u2: User, p: Photo |\n    (u2 in u1.follows => (p !in Ad and p in u2.posts and p in u1.sees)) and\n    (u2 !in u1.follows => (p in Ad => p in u1.sees))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a:Ad | a in u.sees\n  all u: User, f: Photo | f in u.sees implies some u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, a:Ad | a in u.sees\n  all u: User | some f: Photo | f in u.sees implies f in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | Ad in u.sees \n  all u: User | Photo in u.sees implies Photo not in u.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = u.follows.posts + posts.Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees = u.follows.posts + posts.Ad + u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.follows.posts - Ad | u.sees = Ad \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | (u.follows.posts not in Ad) and u.sees in (u.follows.posts + Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | (a in u2.posts) implies a in u1.sees\n  \tall u1, u2: User | all p: Photo - Ad |( u1 != u2 and p in u1.sees )implies (u2 in u1.follows and p in u2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | (a in u2.posts) implies a in u1.sees\n  \tall u1, u2: User | all p: Photo - Ad |( p in u1.sees )implies (u2 in u1.follows and p in u2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1, u2: User | all a: Ad | (a in u2.posts) implies a in u1.sees and u2 in u1.follows\n}",
                    "{\n\t\n\t\n\tall u : User | some p : Photo - Ad |\n  \t\tp in u.follows.posts\n  \t\t\n}",
                    "{\n\t\n\t\n\tall u : User | some p : Photo - Ad |\n  \t\tp in u.sees and p in u.follows.posts\n  \t\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | all p : u.sees | p not in Ad implies (some uu : User - u | p in uu.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n all u: User, p: Photo |\n        (p in Ad => p in u.sees) and\n        (p not in Ad => (some u2: User | (u2 in u.follows && p in u2.posts && p in u.sees)) or (p in u.posts and p in u.sees))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall disj u, followed : User | all p : Photo | followed in u.follows and p in u.sees and p in followed.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall disj u, followed : User | all p : Photo | followed in u.follows and p in u.sees and p in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad | ad in u.sees and ( all p : Photo | p != ad and p not in Ad and p in u.sees iff p in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad | u not in Influencer and ad in u.sees or ( all p : Photo | p != ad and p not in Ad and p in u.sees iff p in u.follows.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u : User, ad : Ad, followed : u.follows | ad in u.sees or ( all p : Photo | p not in Ad and p in u.sees iff p in followed.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2 : User |\n  \t(u1 not in u2.follows) implies u2.posts not in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2 : User |\n  \t(u1 = u2 or (u1 not in u2.follows)) implies u2.posts not in u1.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all disj u1, u2 : User |\n  \t((u1 not in u2.follows) implies (all p : Photo | (p in u1.posts and p in Ad) \t\t \t\timplies (p not in u2.sees)))\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2: User| some a: Ad| a in u1.sees implies (a in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2: User| some a: Ad| a in u1.sees iff (a in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u1, u2: User| some p: Photo| (p not in Ad and p in u1.sees) iff (p in  u2.posts and u2 in u1.follows)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | \n  (p not in Ad and p in u.sees) implies (one v : User | v not in u.follows and p in v.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall a: Ad, u: User | a in u.sees\n  \tall p: Photo - Ad, u: User | p in u.sees iff \n  \t\tsome u1: User | u1 in u.follows and u1 != u\n}",
                    "{\n  \tall disj u1,u2 : User|\n  (not (u1 in u2.follows)) implies (all p : u1.posts| p in u2.sees implies p in Ad)\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \tall disj u1,u2 : User| some p : u1.posts| \n(not p in Ad and p in u2.sees) implies (u1 in u2.follows)\n\t\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\nall disj u1,u2:User, p:Photo|u1 in u2.follows and p in u1.posts implies p not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\nall disj u1,u2:User, p:Photo|u1 in u2.follows and p in u1.posts implies p not in Ad\nall u:User,p:Photo| p in u.sees implies (p.~posts in u.follows and p not in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\nall u:User,p:Photo| p in u.sees implies  \n                         (p.~posts in u.follows and p not in Ad) or \n                                               (p.~posts not in u.follows and p in Ad)\n}",
                    "{ \n\t// Users can see ads posted by everyone, \n\t\n  \tall u1 : User, p : u1.sees |\n  (p not in Ad) implies (some u2 : User | \tu1 != u2 and\n  \t\t\t\t\t\t\t\t\t\t\tp in u2.posts and\n  \t\t\t\t\t\t\t\t\t\t\tu2 in u2.follows)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.sees not in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User | u.sees & Ad not in u.follows.posts\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u, u1 : User, p : Photo | u in posts.p  and u1 in follows.u implies u in sees.p and p not in Ad\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u, u1 : User, p : Photo | u in posts.p  and u in follows.u1 implies u in sees.p and p not in Ad\n  \n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall s : User.sees | s not in User.follows.posts & Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.sees not in u.follows.posts & Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees implies Ad in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad not in u.follows.posts && u.posts not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad not in u.follows.posts && u.posts & Ad not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.follows.posts & Ad not in u.sees\n    all u : User | u.posts not in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.follows.posts not in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall p : Photo | all u : User | p in u.sees implies (posts.p in u.sees or p in Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | u in sees.p implies p in Ad or all z : User | z!=u and u in follows.z implies z in posts.p\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | u in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo | u.follows in u.sees implies p not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u: User, p: Photo | u.follows in u.sees implies p not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u: User, u1: User, p: Photo | u1 in u.follows implies p not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u: User, u1: User, p: Photo | u1 in u.follows implies u.sees not in Ad\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo | p in u.sees implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u, u1: User | u1 in u.follows implies no (u.sees & Ad)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | u.posts in u.follows.posts\n}",
                    "{\n\t\n  all u : User, a : Photo | \n\t  some u1 : User | u1->a in posts and u->u1 in follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all disj u, q : User | u.sees in (Ad)\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall disj u1,u2: User | all p: Photo | ((u2 not in u1.follows and p not in Ad) => u2.posts not in u1.sees) \n  \n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad => p in u.sees) &&\n        (p not in Ad =>\n            (some f: u.follows | p in f.posts implies p in u.sees)\n            or (some i: Influencer | p in i.posts implies p in u.sees)\n        )\n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad => some f: u.follows | p in f.posts or p in Influencer.posts) &&\n        (p not in Ad =>\n            (some f: u.follows | p in f.posts implies p in u.sees)\n            or (some i: Influencer | p in i.posts implies p in u.sees)\n        )\n}",
                    "{\n    all u: User, p: Photo |\n        \n        (p in Ad => p in u.sees) &&\n        \n        \n        (p not in Ad =>\n            (some f: u.follows | p in f.posts implies p in u.sees)  \n            or (some i: Influencer | i in u.follows and p in i.posts implies p in u.sees)  \n        )\n}",
                    "{\n    all u: User, p: Photo |\n        \n        (p in Ad => (some f: u.follows | p in f.posts)) &&\n        \n        \n        (p not in Ad =>\n            (some f: u.follows | p in f.posts implies p in u.sees)  \n            or (some i: Influencer | i in u.follows and p in i.posts implies p in u.sees)  \n        )\n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad and posts.p != u) => (p in u.sees) \n        else (some f: u.follows | p in f.posts) => (p in u.sees) \n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad and posts.p != u) => (p in u.sees)  \n        else (p not in Ad and some f: u.follows | p in f.posts) => (p in u.sees)  \n        \n        and (posts.p != u => p not in u.sees)  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u : User, p : Photo |\n    p in u.sees <=>\n      (p in Ad and all u2 : User | p in u2.posts) or\n      (p !in Ad and some u2 : u.follows | p in u2.posts)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u1,u2 : User | u2 in u1.follows => u2.sees not in (u1.posts & Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tall u: User, a: Ad | a in u.sees\n  \n \tall u: User, p: Photo - Ad |\n        (some owner: User | p in owner.posts and owner in u.follows) implies p in u.sees or u.sees in u.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  \tAd in User.sees\n\tall u: User | (u.sees & Ad) in u.follows.posts\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\tall u: User, p: Photo | p in Ad implies u in sees.u \n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\tall u: User, a: Ad | some u.sees implies a in u.sees  \n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\tall u: User, p:Photo | some u.sees implies p in Ad\n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies posts.p in u.follows\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t\n\tall u: User, p:Photo | p in Ad iff p in u.sees\n  \n  // but only see non ads posted by followed users.\n\tall u: User, p: Photo | p in u.sees implies posts.p in u.follows\n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\tall u: User, p:Photo | (u in sees.p implies p in Ad) and (p not in Ad implies u in u.follows)\n  // but only see non ads posted by followed users.\n\t\n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\tall u: User, p:Photo | u in sees.p implies p in Ad\n  // but only see non ads posted by followed users.\n\t\n\tall u: User|some p: Photo - Ad | p in u.sees implies u in u.follows\n \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\tall u: User, p: Photo | u in sees.p implies u.posts in Ad     \n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User|some p: Photo - Ad | p in u.sees implies u in u.follows\n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\tall u: User, p: Photo | u in sees.p implies u.posts in Ad     \n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p:Photo | p not in Ad implies u in u.follows\t\n  \n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\tall u: User, p: Photo | u in sees.p implies u.posts in Ad     \n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p:Photo | p not in Ad and p in u.sees implies u in u.follows\t\n  \n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\t\n  \tall u: User, p: Photo | p in Ad implies u.sees not in u.follows\n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p:Photo | p not in Ad and p in u.sees implies u in u.follows\t\n  \n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\t\n  \t\n  \n  all u: User, a: Ad | u.posts in Ad implies u not in u.follows   \n\t\n  \t\n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p:Photo | p not in Ad and p in u.sees implies u in u.follows\t\n  \n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\t\n  \t\n  \n  all u: User | u.posts in Ad implies u not in u.follows   \n\t\n  \t\n  \n  // but only see non ads posted by followed users.\n\t\n\tall u: User, p:Photo | p not in Ad and p in u.sees implies u in u.follows\t\n  \n\t\n  \n}",
                    "{\n  // Users can see ads posted by everyone, \n\t\n\t\n\t\n  \tall u: User, p:Photo| u in sees.Ad implies p in u.posts   \t\n  \n\t\n\t\n  \t\n  \n  // but only see non ads posted by followed users.\n  \tall u: User, p: Photo | p not in Ad implies posts.p in u.follows\n  \n\t\n\t\n  \n\t\n  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User, p : Photo | (Ad + follows.posts.p) in u.sees\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n\tall u : User | Ad in u.sees and u.sees not in ((User - u.follows).posts - Ad)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u:User, p: Photo | u in sees.p implies p in Ad\n  \tall u:User| one p: Photo | u in sees.p implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u:User, p: Photo - Ad | p in u.sees implies u in posts.p and u in follows.u\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \t\n  \tall u:User| one p: Photo | u in sees.p implies p in Ad\n\t// but only see non ads posted by followed users.\n  \tall u:User, p: Photo - Ad | p in u.sees implies u in posts.p and u in follows.u\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u:User, p: Photo | u in sees.p implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\tall u:User, p: Photo| u in u.follows and p in u.sees and u in posts.p implies p not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u:User, p: Photo | u in sees.p implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\tall u: User, p: Photo| u.follows in posts.p implies p not in Ad\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  \tall u:User, p: Photo | u in sees.p implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\tall u: User, p: Photo| u.follows in posts.p \n}",
                    "{\n\t\n  \tall u:User, p: Photo | u in sees.p and posts.p not in u.follows implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\tall u: User, p: Photo| u.follows in posts.p \n}",
                    "{\n\t\n  \tall u:User, p: Photo | u in sees.p and posts.p not in u.follows implies p in Ad\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\n\tall u: User, p: Photo| posts.p in u.follows implies u.sees not in Ad\n}",
                    "{\n\t\n  \tall u:User, p: Photo | u.sees in posts.p implies p in Ad\n\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\n\n\tall u: User, p: Photo| p not in Ad implies u.follows in posts.p\n}",
                    "{\n\t\n  \tall u:User, p: Photo | u in sees.p implies p in Ad \n  \t\n\n  \t\n\t\n  // but only see non ads posted by followed users.\n  \t\n  \t\n\t\n\n\n\tall u: User, p: Photo| p not in Ad implies u.follows in posts.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\tall u: User, p: Photo | u in sees.p implies p in Ad \n  // but only see non ads posted by followed users.\n\tall u1: User, p: Photo | some u2: User| (u2 in sees.p) and u1 in posts.p implies u2 in u1.follows  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n\tall u: User, p: Photo | u in sees.p implies p in Ad or\n  // but only see non ads posted by followed users.\n\tall u1: User, p: Photo | some u2: User| (u2 in sees.p) and u1 in posts.p implies u2 in u1.follows  \n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, a: Ad | u in sees.a or \n\t// but only see non ads posted by followed users.\n\tsome u1: User| all p: Photo-Ad | (p in u1.posts) and (u in follows.u1) implies u in sees.p\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo| (u in sees.p and p in Ad) or \n\t// but only see non ads posted by followed users.\n\tsome u1: User| all p: Photo-Ad | (p in u1.posts) and (u in follows.u1) implies (u in sees.p)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n  all u: User, p: Photo| (u in sees.p and p in Ad) or \n\t// but only see non ads posted by followed users.\n\tsome u1: User| (u in follows.u1) implies (u in sees.p)\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n \n  all u: User, p: Photo | p in Ad implies p in u.sees\n\n  \n  all u, y: User, p: Photo | \n      (p in y.posts and p not in Ad and y in u.follows) iff (p in u.sees)\n\n\n}",
                    "{\n    \n    \n\n    all u, y: User, p: Photo |\n        (p in y.posts and p not in Ad) implies\n           ((y in u.follows) iff (p in u.sees))\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all a: Ad | all p: Photo - Ad | some u2: User | p in u.sees implies (p in u2.posts and u2 in u.follows) and a in u.sees\n\n}",
                    "{\n\t// Users can see ads posted by everyone, \n\t// but only see non ads posted by followed users.\n  all u: User | all a: Ad | all p: Photo - Ad | a in u.sees and (p in u.sees implies (some u2: User | p in u2.posts and u2 in u.follows))\n\n}",
                    "{\n  \n  all u: User | all a: Ad | a in u.sees\n  and\n  \n  all u: User | all p: Photo - Ad | p in u.sees implies (some u2: User | p in u2.posts and u2 in u.follows)\n  and\n  \n  all u: User | all p: Photo | p in u.sees implies (some u2: User | p in u2.posts)\n}",
                    "{\n\n  all u: User | all a: Ad | a in u.sees\n  \n  and\n  \n  all u: User | all p: Photo - Ad | p in u.sees implies (p in u.posts or p in u.(follows.posts))\n}",
                    "{\n\n  all u: User | all a: Ad | a in u.sees\n  \n  and\n  \n  all u: User | all p: Photo - Ad | one u2: User | p in u.sees implies (p in u2.posts and u2 in u.follows)\n}",
                    "{\n  \n  all u: User | all a: Ad | a in u.sees\n  and\n  \n  all u: User | all p: Photo - Ad | p in u.sees implies (let u2 = {u2: User | p in u2.posts} | u2 = u or u2 in u.follows)\n}",
                    "{\n  \n  all u: User | all a: Ad | a in u.sees\n  and\n  \n  all u: User | all p: Photo - Ad | p in u.sees implies (one u2: User - u | p in u2.posts and u2 in u.follows)\n}"
                ]
            },
            {
                "description": "If a user posts an ad then all its posts should be labeled as ads",
                "pred": "this/inv4",
                "oracle": "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User | some u.posts & Ad implies u.posts in Ad\n\n}",
                "erroneous": [
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | some ad : Ad | ad in u.posts implies u.posts in Ad \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u:User | some p:Photo | p in Ad and p in u.posts implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u : User | u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \t\n  \tall u:User | Ad in u.posts implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\t\n\n\t\n\t\n  \t\n\tall u : User | some a : u.posts | a in Ad implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | all p: u.posts | p in Ad <=> u in p.posts\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | some(u.posts & Ad) implies (u.posts = Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u : User | (one u.posts & Ad) implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u:User | one up: u.posts | up in Ad implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall x: User | (some y: Photo | x->y in posts and y in Ad) implies \n  all z: Photo | x->z in posts and z in Ad  \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall x: User | some y: Ad | y in x.posts implies (all z: Photo | z in x.posts and z in Ad) \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p : u.posts | Ad in p implies p = Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p : Photo | p in Ad implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | some pa : u.posts & Ad | #pa > 0 implies (all p : u.posts | p in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | u.posts in Ad implies (u.posts not in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall user: User | one post: Photo | post in user.posts and post in Ad => user.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  all u:User | Ad in u.posts implies (Photo not in u.posts)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall user: User | one ad: Ad | ad in user.posts => user.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User| all a: Ad |a in u.posts implies all p: u.posts| p in a\n  \n        \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | some p : u.posts | p in Ad  \n  \t\n  \t\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u:User | (Ad!=none and Ad in u.posts) implies (u.posts in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | one p: Photo | ((p in Ad and p in u.posts) and u.posts in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p : u.posts | Ad in p implies u.posts = Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u :User, p: Photo | some y: Ad | y in u.posts implies( p in u.posts implies p in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User, a: Ad | a in u.posts implies (all p: Photo | p in Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all x : User | all y : Photo | (x in posts.y) and (y in Ad) \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | no sees.Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | lone p : Ad | p in u.posts implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \n\tall u : User, a : u.posts & Ad | a in u.sees\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all user : User | some Ad and some user.follows.posts\n \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User | (some sup: u.posts |Ad in sup) implies (all up:u.posts| Ad in up)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall a : Ad | not some u : User | a in u.posts implies all a2 : u.posts | a2 in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User, p:Photo | some ad: Ad | ad in u.posts implies p in u.posts and p in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | one p : Photo | p in Ad implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | \n  \t\tsome p: u.posts | some a: Ad | {\n      \t\ta in p => p in Ad\n    }\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall x : User | Ad in x.posts   \n}",
                    "{\n all u:User | some p : Photo |p in Ad implies all p1:Photo| p1 in u.posts and p1 in Ad\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  all u: User | (u.posts) - Photo in Ad => no p: Photo| p in u.posts\n  \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tsome a : Ad | a in User.posts implies User.posts in Ad\n  \t\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tsome u: User | some a: Ad | a in u.posts => u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tsome a : Ad | all u :User | a in u.posts implies u.posts in Ad\n  \t\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \t\n  \tall u : User | some a : Ad | \n  \t\ta in u.posts implies u.posts in a \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | (some x : u.posts | x in Ad) implies (all p : u.posts | p = Ad) \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\n\tone u: User| all a:Ad | u in posts.a  implies u.posts in Ad \n   \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all user : User | user.sees in Ad + user.follows.posts\n \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u : User | some p : Photo | u in posts.p and p in Ad implies \n  \tall p1 : Photo | u in posts.p1 implies p1 in Ad\n  \n\tall u : User | some (u.posts & Ad) implies u.posts in Ad\n}",
                    "{\n\tall u:User, p:Photo | some (u.posts & Ad) implies p in Ad else p not in Ad\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u:User, up:u.posts | one p:Photo | p in u.posts and p in Ad implies up in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u:User, p:Photo | (p in Ad and p in u.posts) implies u.posts in Ad else u.posts not in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User | all p: Photo | p in Ad implies u.posts = Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | some Ad & u.posts iff u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\n  \n  some x: User, y:Photo |  y in x.posts and y in Ad  implies (all z:Photo | z in x.posts implies z in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User |Ad in u.posts iff u.posts in Ad\n  \n        \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User |\n  all disj p1, p2: Photo |\n  p1 in Ad implies p2 in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  no a : Ad | some u : User | a in u.posts and all a2 : u.posts | a2 in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all a : Ad | some u : User | no a2 : Ad | u->a in posts implies u->a2 in posts\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all a : Ad | some u : User | all a2 : posts.u | u->a in posts implies a2 in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all a : Ad | some u : User | all a2 : u.posts | u->a in posts implies a2 in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tsome u : User |  ( u.posts in Ad ) implies u.posts in Ad    \t\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p: u.posts | one o: u.posts | (o in u) implies (p = Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p: u.posts | p in Ad implies (p = Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p: u.posts | Ad in p implies (p != Photo)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | Ad in u.posts implies all p : u.posts | p = Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | some a : u.posts+Ad | all p : u.posts | p in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User |\n  \t(some u.posts & Ad) implies (u.posts & Ad) = Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u: User | some ad: Ad | ad in u.posts => no p: Photo | p in u.posts\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tno posts.Ad or no (posts.Photo - posts.Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u : User | (some ad : Ad | ad in u.posts) implies (all u2 : User | u2.posts in Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | lone p: Photo | (p in u.posts) and (p in Ad) and (u.posts in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tAd in User.posts implies  User.posts in Ad\n  \t\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User| all a: Ad |a in u.posts implies all p: Photo| u.posts in p\n  \n        \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\t\n  \tnot Photo in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\t\n  all u: User, a: Photo | u in sees.a implies a in Ad or \n  some u1: User, a: Photo | u1 in posts.a and u in follows.u1\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n    all u : User | u.sees in Ad or no (u.sees & Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u : User, a : Ad | a in u.posts => lone (u.posts - Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User| some a: Ad |a in u.posts iff u.posts in a\n  \n        \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u: User| all a: Ad |a in u.posts iff u.posts in a\n  \n        \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  all i: Influencer | i.posts in Ad implies i.posts = Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u:User | one p:Photo | p in u.posts and p in Ad implies u.posts in Ad else u.posts not in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tsome u : User | u->Ad in posts implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n    some u : User | some a : u.posts | a in Ad implies u.posts in Ad  \t\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User | some a: Ad | all p : Photo | p in Ad \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n   all u : User | one p : u.posts| (p in Ad) implies (p in u.posts )\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all user : User | some Ad - user.posts and some user.follows.posts\n \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all user : User | some Ad or some user.follows.posts\n \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\t(all u : User | some p : Photo | p in u.posts and p in Ad) => (all p : Photo, u : User | p in u.posts => p in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all user : User | user.sees in Ad and some user.follows.posts\n \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  all u: User, ad: Ad | (ad in u.sees) => (no u1: User | u1.posts & ad != ad)\n\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u : User | Ad in u.sees implies u.sees in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall u : User | some a : Ad | a in u.sees implies u.sees in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u:User | (u.posts in Ad) => u.posts = Ad \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | #u->Ad=1\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall user : User | #user->Ad = 0 or #user->Ad = #user.posts\n  \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u : User, a : Photo | one add : Ad | u->add in posts implies\n  \t\ta in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | one p : Ad | p in u.posts implies all p1 : Photo | p1 in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tno Ad\n\tall u: User | (some Ad & u.posts) iff (u.posts in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tlone u:User | some y:Photo | (y in u.posts and y in Ad) implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User | (some sup: u.posts |Ad in u.posts) implies (all up:u.posts| Ad in up)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u : User | u.posts in Ad iff u in Influencer\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | u not in u.follows\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User |\n  all disj p1, p2: Photo | {\n    p1 in u.posts \n    p2 in u.posts\n    p1 in Ad implies p2 in Ad\n  }\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  some (User.posts & Ad) implies User.posts = Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall x,y : Photo | x in Ad implies y in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \t\n  \t\n\n  \tall u: User, b: Photo | one a: Photo-Ad| u -> a in posts and u -> b in posts implies b in Ad \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n    all u : User, p : Photo-Ad | one posts.p implies p in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  no a : Ad | some u : User, a2 : Ad | u->a in posts implies u->a2 in posts\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all x : User, y : x.sees | y in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u : User | Ad in u.posts and not Photo in u.posts\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u : User | some a : Ad |\n  \t\ta in u.sees implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u : User, a : Ad |\n  \t\ta in u.sees implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n    all a: Ad, u:User | u in posts.a implies u in Influencer\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \nall u:User | lone u.posts&Ad implies u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \t some u : User | u.posts in Ad => all p : Photo | posts.p in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u :User, p: Photo | one y: Ad | y in u.posts implies p in u.posts\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u :User, p: Photo, y: Ad | y in u.posts implies p in u.posts\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p : u.posts  | p = Ad \n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | (one x : u.posts | x in Ad) implies (all p : u.posts | p = Ad) \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n\t\n  \tsome u : User | one a : Ad | u->a in posts implies (all p : Photo | u->p in posts implies p in Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | all p : u.posts | Ad in p \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tone u : User | some a : u.posts | a in Ad implies (all p : u.posts | p in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u: User | some a: Ad | {\n      a in u.posts => u.posts in Ad else u.posts not in Ad\n    }\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall x: User | some z: Ad | (x in Influencer and z in x.posts) implies (all z: Photo | z in x.posts and z in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall x: User | some z: Ad | (z in x.posts) implies (all z: Photo | x in Influencer and z in x.posts and z in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u:User | one a:Ad | a in u.posts implies no (u.posts & Photo)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tno sees.Ad or (some sees.Ad and no (sees.Photo - sees.Ad))\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p : u.posts | Ad in p implies (all z : Photo | z = Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | u in Influencer and after always u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u:User | (no (u.posts & Ad)) implies (u.posts & Ad = u.posts)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p: Photo | one posts.p-Ad\n  \n  \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User, p: Photo-Ad | one posts.p\n  \n  \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User| some p : Photo-Ad | u in posts.p implies p in Ad\n  \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | one a : Ad | a in u.posts implies u.posts = Ad \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tsome a : Ad | all u :User | some u.posts & Ad implies u.posts in Ad\n  \t\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u:User | u.posts in Ad or lone (Ad & u.posts) \n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \n  all u : User | all p : u.posts | one a : Ad |\n  \ta in u.posts implies p in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \n  all u : User | all p : u.posts | one a : Ad |\n  \ta in p implies p in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u : User | one ad : Ad | ad in u.posts implies (all p : Photo | p in u.posts and p = Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u : User | some a : Ad | a in u.posts implies u.posts = u.posts + Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u : User |one  p : Photo | u in posts.p and p in Ad implies p in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User, p: Photo | lone a: Ad | a in u.posts implies Ad in p\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  all u: User, p: Photo | lone a: Ad | a in u.posts implies a in p\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads.\n  \tall a: Ad | one u: User | (u.posts = a) => (u.posts in Ad)\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tall u:User | lone p: u.posts | p in Ad => u.posts in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\tsome u : User | (u.posts in Ad)\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\t\n    Photo in Ad\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n  \tall u:User, p: Photo | one u.posts and p in Ad implies u.posts in Ad\n\n}",
                    "{\n\t// If a user posts an ad then all its posts should be labeled as ads. \n\n\tone u: User| all p: Photo | #u.posts>0 and p in Ad implies u.posts in Ad \n}"
                ]
            },
            {
                "description": "Influencers are followed by everyone else",
                "pred": "this/inv5",
                "oracle": "{\n\t// Influencers are followed by everyone else.\n    all u : User | all i : Influencer | u != i implies i in u.follows\n}",
                "erroneous": [
                    "{\n\t// Influencers are followed by everyone else.\n    all u : User, i: Influencer | i in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i: Influencer | all u: (User + Influencer) | i != u && i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer, u : User - Influencer | i in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  all u: User| all i: Influencer | u in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i in User.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall inf: Influencer, user: User | user != inf => user in inf.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\n      all x : Influencer | follows.x  in User-x         \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\n  follows.Influencer = User\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer | i in (User-Influencer).follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | i in (User-i).follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User - Influencer | some i: Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  all i: Influencer | all user: User - Influencer | user in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | u in Influencer => u in u.follows \n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | u.follows in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User | u in Influencer.follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User | Influencer in u.follows and u not in u.follows\n  \n  \n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  all u: User-Influencer| u in Influencer.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x : User | all z : Influencer | x.follows in z\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : User-Influencer | follows.u in Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | no i.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i in follows.User\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User, i: Influencer | some Influencer & u.follows implies i in u.follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tfollows in User some -> Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | Influencer in u.follows or #User = 1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u:User | u in Influencer implies Influencer in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  some u : User | all i : Influencer |\n  (i in u.follows)\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u:User| one i :User| \n  \t(i in Influencer) => i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  some Influencer =>  all u: User | u.follows in Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | i in User.follows && i not in i.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User - Influencer | u.follows = Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n     all i : Influencer | follows.i = User - Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall disj u: User, i: Influencer |u not in Influencer implies i in u.^follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer | i.follows = User - i\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u: User, u1: User | u in Influencer and u in u1.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t\n\t\n  \tsome u: User, i: Influencer | one i implies u->i in follows\n\tall u: User, i: Influencer | u in i implies u->i in follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n    \n    \n  \n    \n  \n    \n  \n     all x : Influencer, d : Day | some x.posts & date.d\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i: Influencer | all u: User | follows.i in u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User, v : Influencer | follows.v = u - v\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \t Influencer.~follows = User - Influencer.iden\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t Influencer in (User - Influencer).follows\n  \t Influencer.follows = none\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x : User | x.follows = Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : User | not (u in u.follows)\n\tall i : Influencer, u : User - Influencer | i in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | follows.u in Influencer  \n}",
                    "{\n\t// Influencers are followed by everyone else.\n    follows in (User-Influencer) -> some Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  all u:User | u-Influencer in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User |\n  \t\tu in Influencer implies (follows.u & User = none)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all disj u1, u2 : User | u1 in Influencer and u1 in u2.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tnot (Influencer & User.follows = none)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tsome u: User | u in Influencer implies all users: User - u | u in users.follows\n    \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User - Influencer | ((Influencer in u.follows) and (u not in u.follows))\n  \n  \n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  some i: Influencer | all user: User - Influencer | user in follows.i\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    all x : User | x in Influencer implies (all p : Photo, u : User | x->p in posts implies u->p in sees)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall user: User, user2: User | user2 in user.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u1:User | some u2:User | u2 in Influencer implies u1 in u2.follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  all u: User| one i: Influencer | u in follows.i\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x : User, i : Influencer | follows.i = x\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  some Influencer => all u: User - Influencer | u.follows in Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  some u: User-Influencer| all i: Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u : User, i : Influencer | u.follows = i\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall x : User, y : User | x -> y in follows and x != y implies y in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    all inf : Influencer | lone follows.inf\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer, u : Influencer-i | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall x : follows.User , y : User.follows | x->y in follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tsome u: User | u in Influencer implies all users: User | u in users.follows\n    \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tone i : Influencer | all u : User | u->i in follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  all u: User| one i: Influencer | u in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | User.follows :> i = User.follows - i\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tnot Influencer = User\n  \tall u: User, i: Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    follows in (User-Influencer) some -> Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User, i: Influencer | i.follows != none and u not in Influencer implies i in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | Influencer in u.follows => u not in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u : User, i : User-Influencer | u in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t\t\n \tall u : User | u.follows in Influencer-u\t\n  \n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer, u : User |\n  i in u.follows implies u not in Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all disj i, u : User |\n  i in u.follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User| one u1:User | u in follows.u1 implies u1 in Influencer \n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User|some u1: User| u1 in Influencer implies u in follows.u1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \t some i:Influencer | i.~follows = User - i\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t(User - Influencer).follows = Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  some i: Influencer | all user: User - Influencer | user in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  \n  some u: User-Influencer| some i: Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n    \n    \n  \n    \n  \n    \n  \n     some Influencer.posts & date.Day\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    all x,u : User | x in Influencer implies (all p : Photo | x->p in posts implies x->p in sees)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i: Influencer | all u: User | follows.i in u.follows\n}",
                    "{\n\tall u1:User| one u2:User | u2 in Influencer implies u2 in u2.follows    \n\t// Influencers are followed by everyone else.\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  some x: User | x in Influencer implies all y: User | x != y implies x -> y in follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User | all i:Influencer | u in i.follows and i in u.follows\n  \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n \tsome i : Influencer | follows.i in (User - i)\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all us : User| one i: Influencer | i in us.follows && i not in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User, d: Day | some i: Influencer | i in u.follows and i in d.posts\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | Influencer in u.follows iff u not in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tsome Influencer => follows.Influencer = User - Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User, f: u.follows | some Influencer => some u.follows & Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : User | Influencer in u.follows and u != Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : User | u != Influencer => Influencer in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u:User | follows.u = User-u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | follows.Influencer = u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall disj i1,i2 : Influencer | i1 in User.follows and i2 in User.follows implies i1 = i2\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | i in (User-Influencer).follows and i not in i.follows \n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | i in (User-Influencer).follows or i not in i.follows \n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer, u: User | i in u.follows\n\t\n\tall u: User - Influencer | some v: User - Influencer | v not in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer, u: User | i in u.follows\n\t\n\tall u: User - Influencer | some v: User - Influencer | v not in u.follows\n\t\n\tall u: User | some i: Influencer | i not in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer, u: User | i in u.follows\n\t\n\tall u: User - Influencer | no v: User - Influencer | v not in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer, u : User | i in u.follows or u not in i.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  User not in Influencer.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u: User, i: Influencer | not (User = Influencer) and i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tInfluencer = User or\n  \tall u: User, i: Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer | i in i.follows\n\n\tall i : Influencer | i in (User - Influencer).follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer | i in (User - Influencer).follows or (User - Influencer) = none\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : (User - Influencer) | Influencer != none implies not (u.follows & Influencer) = none\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : (User) | Influencer != none implies not (u.follows & Influencer) = none\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : (User) | Influencer != none and (User - Influencer != none) implies not (u.follows & Influencer) = none\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i:Influencer, u:User | u != i => Influencer - i in u.follows  \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i:Influencer | Influencer - i in (User-i).follows  \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i:Influencer | Influencer - i in User.follows  \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tone i : Influencer | all u : User | u in i.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User | u.follows = Influencer - u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x: User | some x.follows & Influencer implies x.follows in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x: User | lone x.follows & Influencer implies x.follows in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x: User | one x.follows & Influencer implies x.follows in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall x: User | no Influencer.follows & x implies x.follows in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\n  all x: User | Influencer in x.follows and x in x.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall x : User, y : User | y -> x  in follows and x != y implies y in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u : User | u in Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer | i.follows not in Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User\n  \t\t| u not in Influencer and u.follows = Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User - Influencer | follows.u = Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    all u: User - Influencer, i: Influencer | i.follows in u\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User, i: Influencer | some u.follows implies i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u: User, ni: User - Influencer,  i: Influencer | some Influencer & ni.follows implies i in u.follows \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer, u: User - Influencer| u in i.follows and i not in i.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall u : User | all i : Influencer | u in u.follows => i in u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i.~follows.follows = User\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | one Influencer implies Influencer in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User-Influencer | all i: Influencer | follows.i in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User-Influencer | all i: Influencer | follows.i in u\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | i.follows = User.follows - i\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i : Influencer | follows.i = User.follows - i\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u : User , i : Influencer | u!=i implies u.follows in i \n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tfollows in User -> some Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n    follows in (User-Influencer) -> Influencer\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t\n  follows in (User - Influencer) -> Influencer and some Influencer\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall disj u: User, i: Influencer |i in u.^follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i in (User-Influencer).follows or #Influencer = 1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i in (User-Influencer).follows or #User = 1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall i: Influencer | i in User.follows or #User = 1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | Influencer in u.^follows or #User=1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | Influencer in u.*follows or #User=1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: (User-Influencer) | Influencer in (u.follows + Influencer.follows) or #User=1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: (User-Influencer) | (Influencer in u.follows and Influencer in Influencer.follows) or #User=1\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | Influencer in u.follows and Influencer in u.suggested\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User | u = Influencer implies all u2: User-u | u in u2.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n   some i: Influencer | all u: User - i | u in i.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all u : User, i : User-Influencer | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tone u : User | no i : Influencer | i not in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n        all x: Influencer | (x in (User-x).follows) or (no ((User-x).follows))\n\n\n\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n        all x: Influencer | (x in (User-x).follows) or (no ((User-x)))\n\n\n\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer | follows.i  = User-i    \n\tall u : User | u-Influencer in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer | i.follows  = User-i          \n    all u : User | Influencer-u in u.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\t\n \tall i : Influencer | follows.i in (i.follows.follows - i.follows)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User |\n  \t\tu in Influencer iff (follows.u & User = none)\n}",
                    "{\n\t// Influencers are followed by everyone else.\n\tall u: User |\n  \t\tu in Influencer iff all u2: User - u | u in u2.follows\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \tall i : Influencer | i not in User iff all u : User | i in u.follows\n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  all i : Influencer, u : User | u = i \n\n}",
                    "{\n\t// Influencers are followed by everyone else.\n  \n  all u:User | u.follows&Ad = Ad\n}"
                ]
            },
            {
                "description": "Influencers post every day",
                "pred": "this/inv6",
                "oracle": "{\n\t// Influencers post every day.\n\tall d : Day, i : Influencer | d in i.posts.date\n}",
                "erroneous": [
                    "{\n\t// Influencers post every day.\n  \n\n}",
                    "{\n\t// Influencers post every day.\n  all d: Day, i: Influencer | i.posts.date in d\n\n}",
                    "{\n\t// Influencers post every day.\n  all d:Day, i:Influencer | d in i.posts\n\n}",
                    "{\n\t// Influencers post every day.\n    Influencer.posts.date = Day\n\n}",
                    "{\n\t// Influencers post every day.\n\tall d: Day | all i: Influencer | i.posts in d\n}",
                    "{\n\t// Influencers post every day.\n    all i: Influencer | all d: Day|  i.posts.date = d\n\n}",
                    "{\n\t// Influencers post every day.\n  \n\n\n  \n\n\n \n    \n \n     Influencer in posts.date.Day\n}",
                    "{\n\t// Influencers post every day.\n  all u: Influencer, d: Day, p: Photo | p in u.posts and d in p.date \n\n}",
                    "{\n\t// Influencers post every day.\n  \tall u : User | all p : Photo.date | u in Influencer implies p in u.posts\n  \n\n}",
                    "{\n\t// Influencers post every day.\n\tall i : Influencer | all d : Day | one p : i.posts | p.date = d\n}",
                    "{\n\t// Influencers post every day.\n  all x : Influencer | some y: Photo | all z: Day | y in date.z and y in posts.x\n}",
                    "{\n\t// Influencers post every day.\n\tall d: Day | some i: Influencer | i.posts.date in d\n}",
                    "{\n\t// Influencers post every day.\n\tall x : User | x in Influencer implies (all d : Day | some p : Photo | x->p in posts implies p->d in date)\n\n}",
                    "{\n\t// Influencers post every day.\n  all i: Influencer, d: Day | some i.posts.date\n}",
                    "{\n\t// Influencers post every day.\n\tall i:Influencer, d: Day | some p:Photo, a:Ad | (p in i.posts and p.date = d) or \n  \t\t\t\t\t\t\t\t\t\t\t\t\t(a in i.posts and a.date = d)\n}",
                    "{\n\t// Influencers post every day.\n  \tall i: Influencer | some p : Photo | all a : Day | p in i.posts and a in p.date\n\n}",
                    "{\n    // Influencers post every day.\n  \tall i: Influencer | all d: Day | some p: Photo | p.date = d\n\n}",
                    "{\n\t// Influencers post every day.\n  all i : Influencer | all d : Day | lone p : Photo | d in p.date and p in i.posts\n}",
                    "{\n\t// Influencers post every day.\n  all i:Influencer, d:Day, z:Photo | z in i.posts implies not some dx:Day | dx not in i.posts.date\n\n}",
                    "{\n\t// Influencers post every day.\n  \tall d: Day | d in Influencer.posts\n\n}",
                    "{\n\t// Influencers post every day.\n\tall i: Influencer | all disj p1, p2: Photo | p1 in i.posts and p2 in i.posts implies p1.date = p2.date\n}",
                    "{\n\t// Influencers post every day.\n  \tall d : Day, i: Influencer | date.d in i.posts\n\n}",
                    "{\n\t// Influencers post every day.\n  \n\n\n  \n\n\n \n    \n \n     some Influencer.posts & date.Day\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | lone posts.date.d & Influencer\n\n}",
                    "{\n\t// Influencers post every day.\n  all d: Day, i: Influencer | (i.posts.date++i.sees.date) in d\n\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day, i : Influencer | i.posts.date = d\n  all d : Day, p : Photo | p.date in d\n\n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tInfluencer -> Influencer & iden = (posts.date).~date.~posts\n  \n}",
                    "{\n\t// Influencers post every day.\n  \tsome Influencer => (Influencer <: posts.date) in Influencer some -> Day \n\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | one date.d\n\n}",
                    "{\n  // Influencers post every day.\n  \n  all i : Influencer, p : Photo, d : Day | some p : i.posts | p.date = d\n}",
                    "{\n\t// Influencers post every day.\n  all u:User, d:Day | (some p: Photo | p in u.posts and d in p.date)\n\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | lone posts.date.d\n\n}",
                    "{\n\t// Influencers post every day.\n  \t\n\n  \tall i: Influencer, p: Photo| one d1: Day, d2:Day | some posts.i implies posts.d1!=posts.d2\n}",
                    "{\n\t// Influencers post every day.\n\tall u: Influencer, disj d1,d2:Day|some i:u.posts | i in date.d1 and i in date.d2 implies d1!=d2\n}",
                    "{\n\t// Influencers post every day.\n\tall d: Day | all i: Influencer | i.posts.date not in d\n}",
                    "{\n\t// Influencers post every day.\n\tall p: Photo| p.date in Influencer\n}",
                    "{\n\t// Influencers post every day.\n\tall d: Day | some i: Influencer | some i.posts.date\n}",
                    "{\n\t// Influencers post every day.\n  all i : Influencer | i.posts.date = User.posts.date\n\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day, i : Influencer | i.posts.date = d\n  all d : Day, p : Photo | p in d\n\n}",
                    "{\n\t// Influencers post every day.\n\tall d:Day | some p: Photo | Influencer.posts in p\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | some i : Influencer | some p: Photo | p in posts.i implies p.date in d\n\n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | all i : Influencer | some p: Photo | p in posts.i implies p.date in d\n\n}",
                    "{\n\t// Influencers post every day.\n  \tall d : Day | posts.date.d in Influencer\n\n}",
                    "{\n\t// Influencers post every day.\n  \tall d : Day, i: Influencer | some posts.date.d \n\n}",
                    "{\n\t// Influencers post every day.\n  \tall d : Day | some posts.date.d \n\n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tInfluencer -> Influencer = (posts.date).~date.~posts\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tInfluencer -> Influencer & iden = posts.date.~date.~posts\n  \tDay -> Day & iden = ~date.~posts.posts.date\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tInfluencer -> Influencer & iden in posts.date.~date.~posts\n  \tDay -> Day & iden in ~date.~posts.posts.date\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tsome date + posts => (\n      Influencer -> Influencer & iden in posts.date.~date.~posts and\n  \t  Day -> Day & iden in ~date.~posts.posts.date)\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tsome Day => (\n      Influencer -> Influencer & iden in posts.date.~date.~posts and\n  \t  Day -> Day & iden in ~date.~posts.posts.date)\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tsome Day => (\n      Influencer -> Influencer & iden in posts.date.~date.~posts and\n  \t  Day -> Day & iden in ~date.~(Influencer <: posts).(Influencer <: posts).date )\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tsome Day and some Influencer => (\n      Influencer -> Influencer & iden in posts.date.~date.~posts and\n  \t  Day -> Day & iden in ~date.~(Influencer <: posts).(Influencer <: posts).date )\n  \n}",
                    "{\n\t\n  \t// Influencers post every day\n  \t\n\t\n  \n  \t\n  \n  \t\n  \n  \tsome Day and some Influencer => (\n      Influencer -> Influencer & iden = (Influencer <: posts).date.~date.~(Influencer <: posts) and\n  \t  Day -> Day & iden in ~date.~(Influencer <: posts).(Influencer <: posts).date )\n  \n}",
                    "{\n\t// Influencers post every day.\n  all d : Day | some u : Influencer | u.posts.date = d\n\n}",
                    "{\n\t// Influencers post every day.\n\tposts in Influencer -> some Photo.date\n}",
                    "{\n\t// Influencers post every day.\n\tall d : Day | some i : Influencer | i.posts.date->d in date\n}",
                    "{\n\t// Influencers post every day.\n  all i:Influencer, d:Day | some z:Photo | z in i.posts implies d in i.date\n\n}",
                    "{\n\t// Influencers post every day.\n  all i:Influencer, d:Day, z:Photo | z in i.posts iff d in i.posts.date\n\n}",
                    "{\n\t// Influencers post every day.\n  all i:Influencer, d:Day, z:Photo | z in i.posts and d in i.posts.date\n\n}",
                    "{\n     // Influencers post every day.\n  \n     \n     \n  \n     \n     \n \n     \n     \n \n     all x : Influencer, d : Day | some x.posts & date.d\n \n     \n \n     all d : Day | Influencer in posts.date.d\n\n     \n     Influencer in posts.date.Day\n\n     \n \n     all x : Influencer | Day in x.posts.date\n\n     \n     \n\n}",
                    "{\n\t// Influencers post every day.\n\tall u : Influencer, d : Day|\n  \t\tone p : Photo | \n  \t\t\tp in u.posts implies p.date = d\n}",
                    "{\n\t// Influencers post every day.\n  \tall i: Influencer | #i.posts = #Day\n\n}",
                    "{\n\t// Influencers post every day.\n  \n  all i : Influencer , p : Photo, d : Day \t| i.posts in p && i.posts in date.d\n  \n\n}",
                    "{\n\t// Influencers post every day.\n\tall i: Influencer | all disj p1, p2: Photo | p1 in i.posts and p2 in i.posts implies p1.date = p2.date.next\n}",
                    "{\n\t// Influencers post every day.\n\tall i : User-Influencer, d : Day | some z : Photo | i->z in posts and z->d in date\n  \n}",
                    "{\n\t// Influencers post every day.\n\tall d : Day | all i : Influencer | some p : Photo |d = p.date implies p in i.posts\n}",
                    "{\n\t// Influencers post every day.\n\tall d : Day | some p : Influencer.posts | p.date = Day\n}",
                    "{\n\t// Influencers post every day.\n\tall i : Influencer, p1, p2 : Photo | p1 != p2 implies p1 in i.posts and p2 in i.posts\n}",
                    "{\n\t// Influencers post every day.\n  \tall u : User, d :Day | some p : Photo | u in Influencer implies u in posts.p and p in date.d\n\n}",
                    "{\n\t// Influencers post every day.\n  all i: Influencer, disj d1,d2: Day |  some date.d1 and some date.d2\n\n}"
                ]
            },
            {
                "description": "Suggested are other users followed by followed users, but not yet followed",
                "pred": "this/inv7",
                "oracle": "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = (u.follows.follows - u.follows - u)\n\t\n}",
                "erroneous": [
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested in u.follows.follows - u.follows - u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = u.follows.follows - u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested in u.follows.follows - u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n    all u:User | (u.follows.follows - u.follows - u) in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: User, u3:User |u1 in u3.suggested implies u1 in u2.follows and  u2 in u3.follows and u1 not in u3.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n    all u:User |  (u.follows.follows - u.follows) in u.suggested\n}",
                    "{\n\n  \t// Suggested are other users followed by followed users, but not yet followed.\n \n  \n  \n  \n \n  \n  \n  all u1:User, u2:User-u1 |\n  \tu2 in u1.suggested implies ((u2 not in u1.follows) and u2 in (u1.follows.follows))\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 : User | u1 != u2 and (u1 in u2.follows and u2 not in u1.follows => u2 in u1.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  (all disj u, s: User|\n  s in u.suggested iff s not in u.follows and s in (u.follows).follows)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | all s : u.suggested | all f:u.follows |\n  \t\t(u != s) and (s not in u.follows) and (s in f.follows)\n  \t\t\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\n  all u : User | u.suggested in u.follows.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in u.follows and u.suggested in u.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | u.suggested in (u.follows.follows - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all uf : u.follows | uf.follows in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | u.suggested = u.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in u.follows and u.suggested in (u.follows.follows - u)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all s: u.suggested | all f: u.follows | s not in u.follows && s in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User, z : User | z in x.follows and y in z.follows and x != y implies y in x.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1: User, u2: User | all u3: u2.follows | ((u2 in u1.follows) and (u3 not in u1.follows)) implies u3 in u1.suggested\n  \tall u: User | u not in u.suggested\n}",
                    "{\n  // Suggested are other users followed by followed users, but not yet followed.\n  \n  all u: User | u.suggested = u.follows.follows - u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User, u2 : u.follows, u3 : u2.follows | u3 in u.follows implies not (u3 in u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all disj x,y: User | x!=y and  y in x.suggested implies y in x.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u:User | no(u.suggested & (u.follows+u)) \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested iff y in z.follows and z in x.follows and y not in x.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1, u2, u3 : User | (u1 != u2 and u2 != u3 and u1 != u3 and u2 in u1.follows and u3 in u2.follows and u3 not in u1.follows) iff u3 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u.suggested in ( (u.^follows) - u.follows )\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User |\n\t\tu.suggested = (u.follows).follows - u.follows and u not in u.suggested\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u.suggested = (u.^follows) - u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1, u2, u3 : User | u1 in u3.suggested implies u2 in u3.follows and u1 in u2.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n \n\tall u: User | u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u1, u2: User | u2 in u1.suggested implies u2 in u1.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | no (u.suggested & u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u : User | suggested.u = (u.follows.follows - u.follows - u)\n  \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  all disj u1, u2, u3: User | u3 in u1.suggested => u2 in u1.follows and u3 in u2.follows and u3 not in u1.follows\n  \n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, f: u.follows | u.suggested = f.follows - f\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | u.suggested = (User - u.follows - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows.follows | f in u.suggested implies not(f = u) and not(f in u.follows)\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, f: u.follows | u.suggested = (f.follows - f) - u\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | all s : u.suggested |\n  \t\t(u != s) and (s not in u.follows)\n  \n   all u : User | all s : u.suggested | all f:u.follows |\n  \t\t(s in f.follows)\n  \t\t\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all u2: User - u.follows| u2 in u.suggested iff u2 in (u.follows.follows - u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all u2: (User - u.follows)| u2 in u.suggested iff u2 in u.follows.follows and u2 not in u.follows and u2 != u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | (u.suggested in u.follows.follows \n            and u.suggested not in u.follows\n            and u not in u.suggested) or no u.suggested \n  \n            \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \t\n  \tall u: User + Influencer | u in u.follows.suggested implies u not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | no(s.follows & u) and no(u.follows & s) implies  u.follows.follows - u = s\n\t\n}",
                    "{\n\t\n  \n  all disj me,other : User | (some u : User | me != u and other in u.follows) and not (other in me.follows) implies (other in me.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, u2 : u1.follows | u1.suggested = u2.follows - u1.follows - u1  \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u2 : (User - Influencer - u) | u2 in u.suggested implies u2 in (u.follows.follows - u.follows - Influencer)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: User - u | u.suggested = other & other.follows & other.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2, u3 : User | u3 in u2.suggested implies (u2 in u1.follows and u3 in u2.follows) \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u, s: User | s in u.suggested implies s in u.^follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n   all x:User, y:User, z:User | x in y.follows and y in z.follows and x not in z.follows implies x != y and y != z and x != z and x in z.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | #(u.suggested & u.follows) = 0 and u.suggested = u.follows.follows \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : u.suggested | us in (u.follows.follows - Influencer - u) and us not in (u.follows + Influencer + u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User| u.suggested = (u.follows).follows & u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User | all y : User-x | all z : User-x | y in x.follows and z in y.follows and z not in x.follows and z in x.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | \n  \t\tsome u1:u.suggested |\n  \t\t\t\tsome u2:u.follows |\n\t\t\t\t\tu1 in u2.follows and u1 not in u.follows\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \tall u, uu: User | (u = uu implies u not in uu.suggested) \n    all u, uu: User | (u != uu) && u in uu.follows.follows && u not in uu.follows => u in uu.suggested  \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows, f2:f.follows-u | f2 in u.suggested and f2 not in u.follows\n}",
                    "{\n    // Suggested are other users followed by followed users, but not yet followed.\n  \tall u1, u2: User | some f: u1.follows | u2 in u1.suggested => u2 not in u1.follows and u2 in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\tall u: User| u.follows.follows not in u.follows\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tno follows & suggested\n  \tno iden & suggested\n  \tall u1 : User | u1.suggested = u1.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.suggested = u.follows.follows-u and (no u.suggested & u.follows)\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | not no u.suggested implies u.suggested in u.follows.follows and u.suggested not in u.follows and \n  \tall i:Influencer | not no i.suggested implies i.suggested in i.follows.follows and i.suggested not in i.follows\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and not(z -> x in follows) and x != z\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User, s : User-u.follows-u | ((some u2 : User-u-s | u2 in (u.follows & follows.s)) implies s in u.suggested) and (s in u.suggested implies (some u2 : User-u-s | u2 in (u.follows & follows.s)))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\nall u :User | all uf:User | all us:User | (u!=uf and uf!=us) => (uf in u.follows and us in uf.follows and us not in u.follows)<=> us in u.suggested\n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | \n  some u.suggested implies (\n    not u in u.suggested \n  \tand not u.follows in u.suggested \n  \tand u.suggested in u.follows.follows\n  )\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,z : User, y: User-x | y in x.suggested iff y not in x.follows and y in z.follows and z in x.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, u2 : follows.u1 | u1.suggested = u2.follows - u1.follows - u1  \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, s: u.suggested, f: u.follows |\n    no f & s and\n    s in User implies (some fu: u.follows | s in fu.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested\n  all disj u1, u2: User | u2 in u1.follows =>\n  (u2.follows - u1.follows) in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u in v.follows implies u.follows in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1: User, u2: User - u1 |\n    (u1 in u2.follows) and (u2 not in u1.follows) =>\n      u2 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all uf : u.follows | uf.follows = u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, random: User | random.follows.follows - u in u.suggested\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n    no p : User | p in p.suggested \n  \t\n  \tall u : User, s : User | s in u.follows implies s not in u.suggested\n\t\n\tall u : User, s : User | s in (u.follows.follows) implies s in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all u: User | all uf: u.follows | all uff: uf.follows | (uff & uff not in uf) implies \tuff in u.suggested  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested |u not in f.follows and \n  \t\t\ts in f.follows and s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all u2: User-u.follows | u2 in u.suggested implies (u2 in (u.^follows-u.follows) and u!=u2)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u : User | suggested.u in (u.follows.follows - u.follows - u)\n  \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested = follows.u.follows -  u.follows - u \n  \n  \n\t\n}",
                    "{\n    \n    all u: User | \n        all s: u.suggested - u | \n            all f: u.follows | s in f.follows and s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n      all x: User | (x.suggested in (x.^follows - x.follows - x) and x.suggested != none)\n\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, f: u.follows | u.suggested = f.follows - u\n  \n}",
                    "{\n   \t\n    all x, y, z: User | (x -> z in suggested) and (x -> y in follows) and (y -> z in follows) and x != y and x != z implies (x -> z in follows) \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in u.follows\n\t\n}",
                    "{\n  all u : User | u not in u.suggested\n  all u, y, x : User | (u != x and y in u.follows and x in y.follows and x not in u.follows) implies x in u.suggested\n  all u, y : User | y in u.follows implies y not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all s : u.suggested | all f : u.follows.follows | s in f and s not in u.follows and u not in s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1,u2,u3 : User | \n  \t\tu1 != u2 and u1 != u3 and u2 != u3 and\n  \t\tu3 in u2.follows and \n  \t\tu2 in u1.follows \n  \t\timplies u3 in suggested.u1\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1, u2: User | u2 in u1.follows implies u2 in {u1.follows.follows - u1.follows}\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall i:Influencer, u:User+i, f:u.follows, f2:f.follows-u-f | f2 in u.follows\n}",
                    "{\n    // Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | (u.follows.follows in u.suggested) and (u.suggested not in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User,u2:User -u | \n  \t\tsome u1:u.suggested |\t\n  \t\t\t(u1 in u2.follows) and (u2 not in u.follows) \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2:User-u1 | all sug : u2.follows-u1.follows | sug in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested = u.follows.follows - (u.follows - u)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | all u1 : u.follows | all u2 :u1.follows | \n  \t\tu not in u.suggested and \n  \t\t(u2 not in u.follows => u2 in u.suggested and u not in u.suggested)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\n    all u : User | all su : u.suggested | all fu : u.follows | su != u\n\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all s: u.suggested |\n    \t(s = u.follows.follows - u.follows) or (s not in u.follows) or u != s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, f:u.follows, s: u.suggested |\n  \t#(f & u ) = 0 and #(f.follows & u.suggested) = #u.suggested\n  \t\n\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows, f2:f.follows-u-f | f2 in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2,u3: User | u3->u1 in follows and not(u3->u2 in follows) and u2!=u3 implies u3 in u2.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.follows.follows in u.suggested-u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User, z : User | x in y.suggested implies x != y and x in z.follows and z in y.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u1 : User, u2 : u1.follows | u1.suggested = u2.follows-u1.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tsome s: User, u:User | some u.follows & follows.s \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | (u.suggested = u.follows.follows \n              and u.suggested not in u.follows\n              and u not in u.suggested) \n             or no u.suggested \n  \n            \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: u1.follows.follows - Influencer-u1 | u2 not in u1.follows implies u2 in u1.suggested\n\t\n}",
                    "{\n    \n    all u1, u2 : User | \n        (u2 in u1.follows) implies \n        (all u3 : User | \n            (u3 in u2.follows and not u3 in u1.follows) implies (u3 in u2.suggested)\n        )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1,u2,u3:User | u2 not in u1.follows and u3 in u1.follows and u2 in u3.follows implies u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows |\n  \t\t\tsome s: u.suggested | \n  \t\t\ts in f.follows and s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s:f.follows | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in (u.follows + u) and u.suggested in u.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2, u3: User | u1 in u3.suggested implies u3 in u2.follows and u2 in u1.follows and u1 not in u3.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u : User | suggested.u = (u.follows.follows - u.follows)\n  \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User |all f : u.follows| all s : f.follows - u.follows | u.suggested in s \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1,u2,u3 : User | \n  \t\tu1 != u2 and u1 != u3 and u2 != u3 and\n  \t\tu3 in u2.follows and \n  \t\tu2 in u1.follows and\n  \t\tu3 not in u1.follows\n  \t\timplies u3 = u1.suggested\n}",
                    "{\n    \n  \tall u1,u2 : User | u2 in u1.suggested implies (not u2 in u1.follows and u1 in u2.follows.follows) \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \n  all disj u,y,z : User |\n  \tz in u.suggested iff y in u.follows and z in y.follows and z not in u.follows and z != u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows | u.suggested in f.follows and u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | x in y.suggested implies (x != y and some z : User | x in z.follows and z in y.follows and y not in x.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1, u2: User | u1 in u2.suggested implies ( \n      u1 != u2 and u1 in (u2 - u1.^follows ))\n}",
                    "{\n  all disj u,u1,u2 : User | u1 in u.suggested and u1 not in u.follows and u2 in u.follows and u1 in u2.follows\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, others: User - u | s in others.follows and s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n  \tall disj u, v: User | u in v.follows implies u.follows - v in v.suggested\n\t\n}",
                    "{\n// Suggested are other users followed by followed users, but not yet followed.\n\t\n\n\n\n\n\n\n   \n   \n\n   \n   \n\n   \n   \n\n   all x, y : User | y in x.suggested iff\n   y in User-x-x.follows & x.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows implies u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User-Influencer | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows implies u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall i : Influencer, u1,u2,u3 : User-i | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows implies u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User-Influencer | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows implies u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj user, user2: User | user2 not in user.follows and user2 in user.follows.follows => user in user.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | u.follows.follows - u = s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested in u.follows.follows&u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | u.suggested = follows.u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, u2 : follows.u1 | not u2 in u1.follows   \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, p : follows.u1 | let u2 = follows.p | u1.suggested = u2 - u1.follows - u1  \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some(u.suggested) implies (no(u.follows&u.suggested) and some((u.follows.follows-u)&u.suggested))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n\tall u : User | all u2 : User | u2 in u.suggested implies u2 not in u.follows and u2 in u.follows.follows and no(u2.follows&u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all f:User.follows, u:User |\n  \t\tsome use : f |\n  \t\tuse in u.suggested && u not in use.follows\n  \t\t\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2:User | u2.follows.follows -u1 -u1.follows in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u1,u2: User | u1 in u.suggested implies u1 in u2.follows and u2 in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: u1.follows - u1, u3: u2.follows -u2 | u3 in u1.suggested iff u3 not in u1.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all s: u.suggested |\n    \t(s = u.follows.follows - u.follows) and (s not in u.follows) and u != s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User |\n    \t(all f: u.follows,f1 : f.follows | f1 in u.suggested) and \n\t\t(u not in u.suggested )\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall x, y: User | y in x.suggested iff x!=y and (some z: User | y in z.follows and z in x.follows and z not in x.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u2 : (User-u-Influencer-u.follows) | (u2 in u.suggested) implies ((u2 in (u.follows.follows-u-Influencer-u.follows)) and (u2 not in u.follows))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: u1.follows.follows | u2 in u1.suggested iff u1 != u2 and u2 not in u1.follows\n\t\n  \n  \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2 : User | u2 in suggested.u1 iff some u3 : User | u3 in follows.u2 \n    and u1 in follows.u3 and u2 not in follows.u1\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t  all u1, u2: User | (u1 in u2.follows) => (u1.suggested & u2.suggested) = none\n\t\n}",
                    "{\n\t\n  \n  all u : User | u.suggested = (u.follows.follows - u.follows) or no u.suggested\n}",
                    "{\n\t\n  \n  all disj x,y : User | x in Influencer implies x in y.follows\n  all disj me, other : User | not (other in me.follows) and (other in me.follows.follows) implies other in me.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested\n  all disj u1, u2: User | u2 in u1.follows <=>\n  ((u2.follows) - (u1.follows)) in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u:User, s:User | s in u.suggested implies (some u1:User | u1 in u.follows and u1 in s.follows)\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  \n  all disj u1, u2, u3: User | u3 in u1.suggested => u2 in u1.follows and u3 in u2.follows and u3 not in u1.follows\n  \n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested \n  \n\t\n  all disj u1, u2, u3: User | u1 -> u3 in suggested => u1 -> u2 in follows and u2 -> u3 in follows and u1 -> u3 not in follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User |\n  \tall recommended: u.follows.follows | recommended not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2,u3: User | u3->u1 in follows and not(u3->u2 in follows) and u1!= u2 and u2!=u3 implies u3 = u2.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User |\n  \tall recommended: u.follows.follows | \n  \t\tu != recommended => recommended not in u.follows\n\t\n}",
                    "{\n\t\n\tall u : User | \n\t\tall v : User | \n\t\t\tv in u.suggested implies \n\t\t\t(v in u.follows) or (some f : User | f in u.follows and v in f.follows) and not v in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | x in y.suggested implies (some z : User | x != y and x not in y.follows and z != x and z != y and z in x.follows and y in z.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | y in x.suggested implies (x != y and y not in x.follows and (some z : User | x in x.follows and y in z.follows))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | (x != y and some z : User | x in z.follows and z in y.follows and y not in x.follows) implies x in y.suggested\n}",
                    "{\n   \t\n    all x, y, z: User | (x -> z in suggested) implies (x -> y in follows) and (y -> z in follows) implies (x -> z in follows) and z != x\n\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u1 : User, u2 : u1.follows | u1.suggested = u2.follows-u1.follows\n  \tno iden & suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u1 : User, u2 : u1.follows, u3 : u2.follows | u1 not in u1.suggested and u1.follows not in u1.suggested and u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\tall u : User | u .suggested = { v: User | all f: u.follows | v in f.follows and v not in u.follows}\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows implies u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n   all x:User, y:User | some z:User | z in x.suggested implies x in y.follows and y in z.follows and x not in z.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x:User, z:User | some y:User | y in x.follows and z in y.follows and x not in z.follows implies z in x.suggested and x != z\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall s: User, u:User | lone (u.follows & follows.s )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = User - u & User - u.follows & (follows.(User - u) - u).follows \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | some u.suggested implies u not in u.suggested and o.follows.follows in u.suggested and u.follows not in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj x,z : User | \n  \t\tx not in Influencer implies (\n  \t\tz in x.suggested implies(\n          z in x.follows.follows and z != x) \n  )\n    \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows | u.suggested in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows in u.suggested and not (u.follows in u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | (u.follows not in u.suggested) and u.follows.follows in u.suggested  and u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested-u.follows implies u not in u.suggested and some (u.follows & follows.(u.suggested-u.follows))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested = (u.follows.follows - u.suggested)\n}",
                    "{\n  \t// Suggested are other users followed by followed users, but not yet followed.\n    all u : User |\n        no ((u.suggested + u) & u.follows) and\n  \t\tall s : u.suggested |\n            some f : u.follows | s in f.follows\n}",
                    "{\n  \t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User |\n\t\tall o : User - u |\n  \t\t\tsome f : u.follows |\n  \t\t\t\t(o in f.follows and o not in u.follows) implies o in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some s : User | u -> s in suggested implies not u -> s in follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u,u2 : User | u2 in u.suggested iff u2!=u and (some z : User | z in u2.follows and z not in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u :User| no (u.suggested & (u.follows + u)) and no(u.suggested-(User- u.follows.^(follows)))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested   in follows.u.follows \n  \n  \n\t\n}",
                    "{\n  \tall x,y,z: User | x -> y in follows and y -> z in follows implies z -> x in suggested\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all s : User | ( s in u.follows.follows ) and ( not u->s in follows ) and ( u != s ) implies u in s.suggested\n  \t\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1: User | all u2 : User| some u3: User |\n  \t\tu1 in follows.u2 implies\n   \t\t\tu3 in follows.u2 and not u3 in follows.u1 and u3 in u1.suggested and u3 != u1 \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all x,y: (User-Influencer) | y in x.suggested implies y in x.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all disj x,y: (User-Influencer) | y in x.suggested implies y in x.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all x, y: (User - Influencer) |\n  y != x and y in x.suggested implies (y in (x.follows).follows and y not in x.follows)\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested |u not in f.follows and \n  \t\t\ts in f.follows implies s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s:f.follows | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested and u not in s.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, s:u.suggested, f:u.follows | not (s = u) and not(s in f)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u,u2: User | u2 in u.suggested iff (u2 in u.^follows and u2 not in u.follows and u not in u2.follows and u!=u2)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.follows.follows in u.suggested-u.follows-u\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2, u3: User | u1 in u3.suggested implies u3 in u2.follows and u2 in u1.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User , u1 : User, u2 : User | (u in u1.follows and u2 in u1.follows) implies u in u2.suggested and u2 in u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj f,u : User | all s : f.follows - u.follows | u.follows in s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall f,u : User | all s : f.follows - u.follows | \t\tu.suggested in s \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested = follows.u.follows - u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2: User | some u3: User | (u3->u1 in suggested) implies (u1 -> u2 in follows and u2 -> u3 in follows and u3 -> u1 not in follows and u2 != u3 and u1 != u2)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User, x : User | u.suggested = x.follows + u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\nall u : User | u not in u.^suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n\tall s, u: User | s in u.suggested iff (some y: u.follows + follows.s | s not in (u.follows + u))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | (u.follows.follows & u.suggested != none)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | ((u.follows.follows - u - u.follows) & u.suggested != none)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in u.follows and u.suggested = u.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all s: u.suggested | u.suggested = u.follows.follows and u.suggested not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall us,u : User |\n  us in u.suggested implies (us != u and us in u.~follows.~follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested \n  suggested in follows.~follows\n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows.follows | u.suggested = f - (u.follows + u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u,u1,u2 : User | u!=u1 and u1!=u2 and u in suggested.u2 iff (u in follows.u1 and u not in follows.u2 and u1 in follows.u2)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : User | (s not in u) implies s in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : User - u | u.suggested = (s & u.follows.follows - u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested in (follows.User - u.follows - u)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User , s: User | (s!=u and s in u.suggested) iff \n  \t\t\t\t\t(s in (u.follows).follows and s not in u.follows)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2, u3 : User | u1 != u3 and u2!= u3 and u1 != u2 and u2 in u1.follows and u3 in u2.follows implies u3 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows.follows | u.suggested in f - u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = User.follows - u.follows\n\t\n}",
                    "{\n  // Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested -u  in u.follows.follows and u.suggested - u not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, others: User - u | s in others.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, others: User - u | s in others.follows and no u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, others: User - u | s in others.follows and u not in s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, f: u.follows | f.follows in s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, f: u.follows | f.follows in s and u.follows not in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, f: u.follows | s in f.follows and u.follows not in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  all u: User, s: u.suggested, f: u.follows | s in f.follows and u.follows not in f\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \t\n  \tall u: User - Influencer | u in u.follows.suggested implies u not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \t\n  \tall u: User + Influencer | (u in u.follows.suggested \n  \timplies u not in u.follows) and ( u !in u.suggested)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \t\n  \t\n  \t\n\tall u: User |\n    u.suggested = {v: User |\n      some w: u.follows |\n        (v not in u.follows) and\n        (v != u) and\n        (v not in w.follows)\n    }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u.suggested = u.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u in v.follows implies v.follows in u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u.suggested = u.^follows - u.follows - u\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u in v.follows && v not in u.follows implies u.follows in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u in v.follows implies u.follows in v.suggested && v not in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u, v: User | u in v.follows implies u.follows - v in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n  \tall disj u, v: User | u in v.follows implies u.follows in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n  \tall disj u, v: User | v in u.follows implies (u.follows - v.follows) in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n  \tall disj u, v: User | u in v.follows implies (u.follows - v.follows) in v.suggested\n  \tall disj u, v: User | u not in v.follows implies (u.follows - v.follows) not in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n  \tall disj u, v: User | u in v.follows implies (u.follows - v.follows) in v.suggested\n  \tall disj u, v: User | u not in v.follows implies u.follows not in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u, v: User | u.follows.follows in v.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tsome u1: User, u2: User, u3:User | u1 in u2.suggested implies u2 in u3.follows and no u1.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tsome u1: User, u2: User, u3:User | u1 in u3.suggested implies u1 in u2.follows and  u2 in u3.follows and u1 not in u3.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested not in u.follows and u.suggested in (u.follows-u).follows\n}",
                    "{\n    // Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | (u.follows.follows in u.suggested) and (u.suggested != u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u,v: User |  (v in u.suggested) implies (u in v.follows) \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall i:Influencer, u:User, f:u+i.follows, f2:f.follows-u-f | f2 in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall i:Influencer, u:User-i, f:u.follows, f2:f.follows-u-f | f2 in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f:u.follows, f2:f.follows-u-f | f2 in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User.suggested | some u2 : User | (u not in u2.follows) and u in u2.follows.follows\n}",
                    "{\n    // Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | (u.follows.follows in u.suggested) and (u.suggested not in u.follows) and (u not in u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested implies y in z.follows and y in x.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some(u.suggested) implies (no(u.follows&u.suggested) and some(u.follows.follows&u.suggested))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested iff y in z.follows and z in x.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some(u.suggested) implies (no(u.follows&u.suggested) and some(u.follows.follows-u&u.suggested))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows and u3 not in u1.follows implies u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows and u1 != u3 implies u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested iff y not in x.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested iff y not in x.follows and y in z.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows and u1 != u3 implies u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y,z : User | y in x.suggested iff y not in x.follows and y in z.follows and z in x.follows and x not in y.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User-Influencer | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows and u1 != u3 implies u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2,u3 : User-Influencer | u1 in u2.follows and u3 in u2.follows and u1 not in u3.follows and u1 != u3 iff u1 in u3.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y: User | x in x.follows.follows and x not in y.follows and x!=y iff x in y.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | u.follows.follows - u in s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | no(s.follows & u) implies  u.follows.follows - u = s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : u.suggested | us in u.follows and us in follows.u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u1 : u.follows | all u2 : u1.follows | one u2 & u.suggested\n\tand u2 != u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | no(u.follows & s) implies  u.follows.follows - u = s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : u.suggested | no(u.follows & s) and u.follows.follows - u = s\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User, u1 : u.follows, u2 : u1.follows | (one u2 - u.suggested\n\tand u2 != u) or u2 = u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.follows not in u.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | u.suggested = follows.u\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u:User, s:User | some u1:User | s in u.suggested and u1 in u.follows and s in u1.follows \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | u.suggested = follows.u.follows - u\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, u2 : follows.u1 | not u2 in u1.follows-u1   \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User, u2 : follows.u1 | u1.suggested = u2.follows - u1.follows   \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User | all u2 : follows.u1-u1 | u1.suggested = u2.follows - u1.follows \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1 : User | all u2 : follows.u1 | User.suggested = u2.follows - u1 - u1.follows \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some(u.suggested) implies (no(u.follows&u.suggested) and some((u.follows.follows-u)&u.suggested))\n\tall u : User | all s : u.suggested | s not in u.follows and s in u.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n\tall u : User | no(u.follows&u.suggested) and some(u.follows.follows&u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: User - u1 |\n    (u1 in u2.follows) => (u2 in u1.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n \tall u1:User, u2: User -u1|\n  \t\tsome u1.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n \tall u1:User, u2: User -u1|\n  \t\tu2 in u1.follows and \n  \t\tsome(u1.suggested) \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1, u2, u3 : User | u2 in u1.follows and u3 in u2.follows and u1 not in u3.follows implies u1 in u3.suggested\n}",
                    "{\n\n  \t// Suggested are other users followed by followed users, but not yet followed.\n  all  u:User, f:u.follows-u |\n  \t\tall use : f.follows |\n  \t\tuse in u.suggested implies use not in u.follows\n  \n\n}",
                    "{\n\n  \t// Suggested are other users followed by followed users, but not yet followed.\n  all  u:User, f:u.follows-u |\n  \t\tall use : f.follows-u |\n  \t\tuse in u.suggested implies use not in u.follows\n  \n\n}",
                    "{\n\n  \t// Suggested are other users followed by followed users, but not yet followed.\n \n  \n  \n  \n  all u : User , uf:u.follows | u.suggested in uf.follows and  u.suggested not in u.follows\n}",
                    "{\n\n  \t// Suggested are other users followed by followed users, but not yet followed.\n \n  \n  \n  \n  all u : User , uf:u.follows-u | u.suggested in uf.follows and  u.suggested not in u.follows\n}",
                    "{\n  all u :User, u2:User-u-u.follows | u.suggested in u2\n  \n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1,u2 : User | u1.suggested in u2.follows.follows-u1-u1.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all u:User, other_follow:u.follows.follows |\n  \tother_follow in u.suggested iff other_follow not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all u:User, other_follow:User |\n  \t(other_follow in u.follows.follows) && other_follow in u.suggested iff other_follow not in u.follows\n\t\n}",
                    "{\n  // Suggested are other users followed by followed users, but not yet followed.\n  all u: User |\n    all other_follow: User -u | \n      (other_follow in u.suggested) iff \n      (other_follow in User.follows and other_follow not in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2 : User | some sugg: u2.follows | sugg not in u1.follows and sugg != u1 implies sugg in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2 : User | u2 in suggested.u1 iff some u3 : User | u2 in follows.u3 \n    and u1 in follows.u3 and u2 not in follows.u1\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User | one u2: u1.follows.follows - u1 | u1 != u2 and u2 not in u1.follows implies u2 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User | lone u2: u1.follows.follows - u1 | u1 != u2 and u2 not in u1.follows implies u2 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User-Influencer, u2: u1.follows.follows - u1 | u2 not in u1.follows implies u2 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User-Influencer, u2: u1.follows.follows - u1-Influencer | u2 not in u1.follows implies u2 in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1: User, u2: u1.follows.follows - u1 | u2 in u1.suggested iff u1 != u2 and u2 not in u1.follows\n\t\n  \n  \t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 : User | all foll: u2.follows | foll in u1.suggested iff foll not in u1.follows and u2 != u1 \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User , uu : u.follows | u!=uu implies uu in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\nall u : User | all u1 : User | u.suggested in u1.follows and u1 in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested = (u.follows.follows - u - u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | all u1 : u.follows | all u2 :u1.follows | \n  \t\tu not in u.suggested and \n  \t\t(u2 not in u.follows) => u2 in u.suggested \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | all u1 : u.follows | all u2 :u1.follows | \n  \t\t(u2 not in u.follows) => u2 in u.suggested and u not in u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\n    all u : User | all su : u.suggested | some fu : u.follows | u!=su and u!=fu \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\n    all u : User | all su : u.suggested | some fu : u.follows | u!=su and u!=fu and su in fu.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | some su : u.suggested | all fu : u.follows | su != u\n        and su != fu and su in fu.follows and su not in u.follows\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.suggested not in u.follows and u.suggested = u.follows.follows-u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1,u2 : User | (u1.suggested not in u1.follows) and u1 in follows.u2 implies u1.suggested in u2.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | (u.follows not in u.suggested) or u.follows.follows in u.suggested  and u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all s : u.suggested | (s not in u.follows) and (s in u.follows.follows - Influencer)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User |  u in u.suggested implies u in u.follows.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n        u in u.suggested => {\n            some f: u.follows |\n                some f2: f.follows |\n                    u not in f2.follows\n        }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n        u in u.suggested => {\n            some f: u.follows |\n                some f2: f.follows |\n                    u not in f2.follows and u != f2\n        }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n        u in u.suggested => {\n            some f: u.follows |\n                some f2: f.follows |\n                    (u not in f2.follows) and (u != f2) and (u not in f2.suggested)\n        }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n        u in u.suggested => {\n            some f: u.follows |\n                some f2: f.follows |\n                    (u not in f2.follows) and (u != f2) and (u not in f2.suggested) and (u not in f.follows)\n        }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows | all s : User-u | s in f.follows and s not in f\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : u.suggested | us not in (u.follows - Influencer - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : u.suggested | us not in (u.follows - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : u.suggested | us in (u.follows.follows) and us not in (u.follows - Influencer - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all us : (User - u) | us in u.suggested implies (us in (u.follows.follows - Influencer - u) and us not in (u.follows + Influencer + u))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all su: u.suggested | some fu : u.follows | (su in u.follows and su!=u and fu!=u) implies su in fu.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.follows.follows = u.suggested-u.follows-u\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1, u2 : User | u1.suggested = u2.follows - u1.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n\tall u1, u2 : User | u1 in u2.suggested iff u2 in u1.follows.follows and u1 not in u2.follows and u1 != u2\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2 : User | u2 in u1.suggested iff one u : u1.follows | u2 in u.follows and u2 not in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1, u2 : User | u2 in u1.suggested iff some u : u1.follows | u2 in u.follows and u2 not in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 :User | all p: u2.follows | p in u1.suggested iff p != u1 and p not in u1.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 :User | all p: u2.follows | p in u1.suggested implies p != u1 and p not in u1.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1, u2: User | u2 in u1.suggested implies follows.u2 in u1.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u1, u2: User | u2 in u1.suggested implies follows.u2 in u1.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all uu : u.follows.follows | u not in uu.follows implies u in uu.suggested \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, f:u.follows, s: u.suggested |\n  \t#(f & u ) = 0\n  \t\n\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, f:u.follows, s: u.suggested |\n  \t#(f & u ) = 0 and #(f.follows & s) = #(s) and u not in s and u not in f\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, s: u.suggested, f: u.follows |\n    no f & s and u not in s and\n    s in User implies (some fu: u.follows | s in fu.follows)\n}",
                    "{\n\tsuggested in follows.~follows - follows // Suggested are other users followed by followed users, but not yet followed.\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, f: u.follows | u.suggested = f.follows & f\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, f: u.follows | some u.suggested => u.suggested = (f.follows - f) \n  \n}",
                    "{\n    // Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User, f: u.follows | u.suggested = f.follows - f and u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 : User | (u2 in u1.suggested and u1 != u2) => (u1 in u2.follows and u2 not in u1.follows) \n}",
                    "{\n  // Suggested are other users followed by followed users, but not yet followed.\n  all s: User | s in s.follows.suggested and s not in s.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | u.suggested = {s: User | s in u.follows - u}\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u, s: User | some u1: User | s in u.suggested implies u1 in u.follows and s not in u.follows\n}",
                    "{\n\t\n  \n  all u : User | not (u in Influencer) implies u.suggested = (u.follows.follows - u.follows) or no u.suggested\n}",
                    "{\n\t\n  \n  all disj x,y : User | x in Influencer implies x in y.follows\n  all i : Influencer | no i.suggested\n  all disj me, other : User | not (other in me.follows) and (other in me.follows.follows) implies other in me.suggested\n}",
                    "{\n\t\n  \n  all i : Influencer | no i.suggested\n  all disj me, other : User | not (other in me.follows) implies other in me.suggested\n}",
                    "{\n\t\n  \n  all i : Influencer | no i.suggested\n}",
                    "{\n\t\n  \n  all i : Influencer | no i.suggested\n  all disj me, other : User | not (other in me.follows)\n}",
                    "{\n\t\n  \n  \n  \n  all disj me, other : User | no (me.follows & me.suggested)\n}",
                    "{\n\t\n  \n  \n  \n  all disj me, other : User | not (other in me.follows) and no (me.follows & me.suggested)\n}",
                    "{\n\t\n  \n  all i : Influencer | no i.suggested\n  \n  all u : User | no u.follows & u.suggested\n  all u : User | u.suggested = u.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.suggested = (u.*follows - u.follows )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested and u1 not in u2.suggested\n  all disj u1, u2: User | u2 in u1.follows =>\n  (u2.follows - u1.follows) in u1.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  \n  suggested in follows.~follows\n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  all disj u1, u2: User | u2 in u1.follows => u2 not in u1.suggested \n  follows.~follows in suggested \n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u not in u.suggested\n  \n  \n\t\n  all disj u1, u2, u3: User | u1 -> u3 in suggested <=> u1 -> u2 in follows and u2 -> u3 in follows and u1 -> u3 not in follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2,u3: User | u3->u1 in follows and not(u3->u2 in follows) implies u3 in u2.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User |\n  \tall recommended: u.follows.follows | recommended not in u.follows and u != recommended\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2,u3: User | u3->u1 in follows and not(u3->u2 in follows) and u1!=u2 and u2!=u3 and u1!=u3 implies u3 in u2.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u . suggested in u . follows . follows and u . suggested not in u . follows - u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall user1 : User | some user2, user3 : User | not user1 in follows.user2 and user3 in follows.user2\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall user1 : User | some user2, user3 : User | not user1 in follows.user2 and user3 in follows.user2 and user1 != user2 and user1 != user3 and user2 != user3\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | (x != y and x->y in suggested) implies (some z : User | z != x and z != y and x->z in follows and z->y in follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | some z : User | z in x.follows and y in z.follows and x != y implies y in x.suggested\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested implies x -> y in follows and y -> z in follows implies not(x -> z in follows) \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and not(z -> x in follows)\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested and x!=z implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and not(z -> x in follows)\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and x!=z and x not in Influencer\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and x!=z and x not in Influencer and y not in Influencer and z not in Influencer\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n  \tall x,z: User | some y: User | x -> z in suggested and x not in Influencer and y not in Influencer and z not in Influencer implies \n    (x -> y in follows) and (y -> z in follows) and not(x -> z in follows) and x!=z \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \tall x, z: User | some y: User | x -> z in suggested implies (x -> y in follows) and (y -> z in follows) and not (x -> z in follows and z -> x in follows) and x != z \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \tall x, z: User | some y: User | x -> z in suggested implies (x -> y in follows) and (y -> z in follows) and x -> z not in follows or z -> x not in follows and x != z \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \t\n    all x, y, z: User | (x -> z in suggested) and (x -> y in follows) and (y -> z in follows) implies (x -> z in follows) and x != y and x != z\n\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \t\n    all x, y, z: Influencer | (x -> z in suggested) and (x -> y in follows) and (y -> z in follows) and x != y and x != z implies (x -> z in follows) \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \t\n    all x, y, z: User | (x -> z in suggested) and (x -> y in follows) and (y -> z in follows) implies not (x -> z in follows) or not(z -> x in follows) \n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n   \t\n    all x, y, z: User | (x -> z in suggested) implies (x -> y in follows) implies (y -> z in follows) implies not(x -> z in follows) implies x != z\n\t// Suggested are other users followed by followed users, but not yet followed.\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User, y : User | x in y.suggested iff (x != y and some z : User | x in z.follows and z in y.follows and y not in x.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u1 : User | u1.suggested = u1.follows.follows\n  \tno iden & suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n  \tall u1 : User, u2 : u1.follows, u3 : u2.follows | (u1.follows not in u1.suggested) and (u3 in u1.suggested)\n  \tno iden & suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\nall u : User | u.suggested in u.follows\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | (u.suggested in u.follows.follows) and (u not in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n   all x:User, y:User, z:User | x in y.follows and z in y.follows and x not in z.follows and x != y and y != z and x != z implies x in z.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n   all x:User, z:User, xf:x.follows, zf:z.follows, zs:z.suggested | x in zs implies some y:User, yf:y.follows | x in yf and y in zf and x not in zf \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User | all y : User | x.suggested not in x.follows and y.follows in x.suggested   \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall x : User | all y : User-x | x.suggested not in x.follows and y.follows in x.suggested   \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall s: User, f:User, u:User | s in f.follows implies u in follows.f\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tsome u:User, s:User | s in u.suggested implies s in u.follows.follows\n                     and s not in (u.follows) \n                     and not s=u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | (u.suggested = u.follows.follows \n                  and u.suggested not in u.follows+u\n                  ) \n               or no u.suggested \n  \n            \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n    all u: User | u.follows.follows in u.suggested and u + u.follows not in u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested in (User - u & User - u.follows & (User - u).follows )\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = User - u & User - u.follows & User - (User - u).follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = User - u & User - u.follows & User - ((User - u).follows).follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = User - u & User - u.follows &  ((User - u).follows).follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested = (User - u) & (User - u.follows) & (follows.(User - u) - u).follows \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: User - u | u.suggested = other & (User - u.follows) & (follows.(User - u) - u).follows \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: User - u | u.suggested = (User - u) & other.follows & other.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: (User - u) | u.suggested in other & other.follows & other.follows.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: (User - u) | u.suggested = (other )\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: (User - u) | u.suggested = (other & other.follows & other.follows.follows)\n\tall u: User, other: (User - u) | other = u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, other: (User - u), random: User | u.suggested = (other & (random.follows.follows))\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | User - u not in u.suggested\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | u not in u.suggested and o.follows.follows in u.suggested\n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | some o.follows.follows implies u not in u.suggested and o.follows.follows in u.suggested and u.follows not in u.suggested \n\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | one u.suggested implies u not in u.suggested and o.follows.follows in u.suggested and u.follows not in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | some u.suggested implies u not in u.suggested and (User - u).follows.follows in u.suggested and u.follows not in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | some u.suggested implies u not in u.suggested and o.follows.follows in u.suggested and u.suggested not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User, o: User | one u.suggested implies u not in u.suggested and o.follows.follows in u.suggested and u.suggested not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj x,y,z : User | \n  \t\tz in x.suggested implies(\n          y in x.follows and z in y.follows) \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, s:u.suggested, af:User.follows  | s in af and not( s in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, s:u.suggested, af:User.follows | s in af and not( s in u.follows) and not (s = u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, s:u.suggested, af:u.follows | s in af and not( s in u.follows) and not (s = u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.suggested in u.follows.follows and not (u.follows in u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows in u.suggested and not (u.follows in u.suggested) and not (u in u.suggested) and not (Influencer in u.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows in u.suggested and not (u.follows in u.suggested) and not (u in u.suggested) and not (Influencer & u.suggested = none)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows in u.suggested and not (u.follows & u.suggested = none) and not (u in u.suggested) and not (Influencer & u.suggested = none)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows in u.suggested and u.follows & u.suggested = none and not(u in u.suggested) and Influencer & u.suggested = none\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows = u.suggested and u.follows & u.suggested = none and not(u in u.suggested) and Influencer & u.suggested = none\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall s:User.suggested | not(s in Influencer)\n\tall u:User, f:u.follows.follows | not(f in Influencer) and not(f = u) and not(f in u.follows) implies f in u.suggested\n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | not(u in u.suggested)\n\tall u:User, f:u.follows.follows | f in u.suggested implies not(f in u.follows) \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User, u2 : u.suggested | some u3 : User | u3 in follows.u2 and u in follows.u3 and u2 not in follows.u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested implies u != u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested implies u not in (u.suggested+u.follows) and some (u.follows & follows.(u.suggested-u.follows))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested implies u not in (u.suggested+u.follows) and some (u.follows & follows.(u.suggested))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested implies u not in (u.suggested) and some (u.follows & follows.(u.suggested))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some u.suggested implies u not in (u.suggested) and some (u.follows & follows.(u.suggested))\n  \tall u : User, u2 : u.follows, u3 : u2.follows-u | u3 not in u.follows implies u3 in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User |\n  \t\tno ((u.suggested & u.follows) - u) and \n  \t\t\tall s : u.suggested |\n\t\t\t\ts in u.follows.follows\t\t\t\n}",
                    "{\n  \t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User |\n\t\tall o : User |\n  \t\t\tsome f : u.follows |\n  \t\t\t\t(o in f.follows and o not in u.follows) implies o in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u,z : User |\n        z in u.suggested implies\n        \t(some y : User | z in y.follows and z not in u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some s : User | u -> s in suggested implies not u -> s in follows and u != s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u1 : User | some s : User | u -> s in suggested implies u -> u1 in follows and u1 -> s in follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u1 : User | some s : User | u -> s in suggested implies u -> u1 in follows and u1 -> s in follows and u != s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all u1 : User | some s : User | u -> s in suggested implies u -> u1 in follows and u1 -> s in follows and u != s and not s -> u in follows\n}",
                    "{\n    \n    all u1, u2 : User | \n        all u3 : User | \n  \t\t\t(u1 != u2 and u1 != u3 and u2 != u3) implies (\n            (u3 in u2.suggested) implies \n            (u2 in u1.follows and u3 in u2.follows and (not u3 in u1.follows)))\n}",
                    "{\n    \n    all u1, u2 : User | \n        (u1 != u2) implies (\n            all u3 : User | \n                (u3 in u2.follows and not u3 in u1.follows) implies \n                (u3 in u2.suggested)\n        )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall x, s: User | x in s.suggested implies (some y: User | s not in x.follows and s in y.follows and y in x.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1, u2, u3 : User | (u2 in u1.follows and u3 in u2.follows) implies (not (u3 in u1.follows) and u3 in u1.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u,u2 : User | u2 in u.suggested iff u2!=u and (some z : User | z in u.follows and z not in u2.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\t\n  \tall u1, u2: User | some u3 : User | u2 in u1.suggested implies u2 not in u1.follows and u2 in u3.follows \n  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u :User| no (u.suggested & (u.follows + u)) and no(u.suggested-(User- u.follows.^(follows))) and u not in u.suggested.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User, followers_following: u.follows.follows-u | followers_following-u.follows = u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1,u2 : User | u2 in u1.suggested implies u1.follows.follows in u2.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u1,u3:User | some u2:User | (u3 in u1.follows and u2 in u3.follows and u2 not in u1.follows) iff u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall disj u1,u2,u3:User | (u3 in u1.follows and u2 in u3.follows and u2 not in u1.follows) iff u3 in u1.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested  not in follows.u.follows \n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested in follows.u.follows && u.suggested not in u.follows\n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested in follows.u.follows -  u.follows\n  \n  \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | u.suggested not in (u.follows.follows - u.follows - u)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u1,u2,u3 : User | \n  \t\tu1 != u2 and u1 != u3 and u2 != u3 and\n  \t\tu1 not in Influencer and\n  \t\tu2 not in Influencer and\n  \t\tu3 not in Influencer and\n  \t\tu3 in u2.follows and \n  \t\tu2 in u1.follows \n  \t\timplies u3 in suggested.u1\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1: User | all u2 : User| some u3: User |\n  \t\tu1 in follows.u2 implies\n   \t\t\tu3 in follows.u2 and not u3 in follows.u1 and u3 in u1.suggested\n}",
                    "{\n    \n    all u1: User | \n        all u2: User | \n            (u1 in follows.u2) implies \n                (some u3: User | \n                    (u2 in follows.u3) and \n                    not (u3 in follows.u1) and \n                    u3 != u1 and \n                    u3 in u1.suggested)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all  x,y: User | y!=x and y in x.suggested implies y in x.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all  x,y: User | y!=x and y in x.suggested implies y in x.follows.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  all  x,y: (User-Influencer) | y!=x and y in x.suggested implies y in x.follows.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested | \n  \t\t\ts in f.follows and f!=s implies s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested |\n  \t\t\ts in f.follows and s!= u implies s not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested |\n  \t\t\ts not in u.follows and s!= u implies s in f.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in f.follows \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s:f.follows | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested and s not in s.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | some f: u.follows, s:f.follows | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested and u not in s.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | some f: u.follows, s:f.follows | \n  \t\t\t s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested and u not in s.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | some f: u.follows, s:f.follows | \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\timplies\n  \t\t\ts in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested| \n  \t\t\tu not in f.follows and s not in u.follows \n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows, s: u.suggested| \n  \t\t\tu not in f.follows and s not in u.follows and u not in u.suggested\n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, f: u.follows - u , s: u.suggested | \n  \t\t\ts in f.follows and s not in u.follows \n  \n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User , s: u.suggested | some f: u.follows |\n  \t\t\tu not in f.follows and s in f.follows and s not in u.follows \n  \n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User, s: u.suggested | \n  \t\t\tu not in (u.follows).follows and s in (u.follows).follows and s not in u.follows \n  \n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t all u: User,s: u.suggested, f: u.follows  | \n             u not in u.suggested implies s not in u.follows and s in f.follows\n\n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t all u: User,s: u.suggested, f: u.follows  | \n              s not in u.follows and s in f.follows implies u not in u.suggested \n\n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\t all u: User, s: u.suggested - u, f: u.follows  | \n             u not in u.suggested and s not in u.follows and s in f.follows\n  \t\t\n\n  \n  \t\t\t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | all u2: User-u.follows | u2 in u.^follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u,u2: User | u2 in u.suggested iff (u2 in u.^follows and u2 not in u.follows and u not in u2.follows)\n}",
                    "{\n  all disj u,u1,u2 : User | u1 in u.suggested and u1 not in u.follows \n\t// Suggested are other users followed by followed users, but not yet followed.\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u1,u3:User | u1->u3 in suggested implies (some u2:User| u1->u2 in follows and u2->u3 in follows) \n\tall disj u1,u3:User | (some u2:User| u1->u2 in follows and u2->u3 in follows)  implies u1->u3 in suggested  \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall s, u: User | (s in u.suggested implies s not in u.follows.follows)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | follows.u.follows & User - u.follows = u.suggested - u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested not in (u.follows + u)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u in User.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u,f,s : User | (f in u.follows and s in f.follows and u not in s.follows) \t  implies s in u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User |all f : u.follows| all s : f.follows - u.follows - u | u.suggested in s \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User |all f : u.follows| all s : f.follows - f - u | \t\t\tu.suggested in s and s in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | {\n        u.suggested = { s: u.follows.follows | \n            some u.follows & u.follows.follows and \n            u.follows.follows not in u.follows and \n            u.follows.follows != u\n        }\n    }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u1, u2 : User | u1 in u2.suggested implies (u2 in u1.follows and u1 not in u2.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2: User | some u3: User | (u3->u1 in suggested) implies (u1 -> u2 in follows and u2 -> u3 in follows and u3 -> u1 not in follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u1, u2: User | some u3: User | (u3->u1 in suggested) implies (u1 -> u2 in follows and u2 -> u3 in follows and u3 -> u1 not in follows and u2 != u3)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested in (User - u).^follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | u.suggested = (User - u).^follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | u.follows.follows not in u.follows + u.suggested \n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u not in u.^(follows.follows)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all x,y : User | (x not in y.follows) implies x in y.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u, u2: User | u2 in u.suggested implies u2 not in u.follows and u2 not in u.follows.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall disj u,s,f:User | s in u.suggested and f in u.follows implies \n  \t\ts not in u.follows and s in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u:User | all s:User | some f:User | s in u.suggested implies\n  \t\ts!=u and s not in u.follows and s in f.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n    some user: User | \n        some suggested: User | \n            suggested in (user.follows.follows) and \n            not (suggested in user.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User | ((u.follows.follows - u) & u.suggested != none)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all  disj u: User, u1: User |   (u1 in u.follows.follows and u1 != u and #(u.follows & u.suggested)=0) => u1 in u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n  \t\tsome s: User |\n  \t\t\ts in u.suggested iff \n  \t\t\t\t(s not in u.follows and\n  \t\t\t\t some u2: User |\n                  u2 in u.follows and\n                  s in u2.follows)\n  \t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User |\n  \t\tsome s: User |\n  \t\t\t(s in u.suggested) iff \n  \t\t\t\t(s not in u.follows + u and\n  \t\t\t\t some u2: User |\n                  u2 in u.follows and\n                  s in u2.follows)\n  \t\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | not no u.suggested implies u.suggested in u.follows.follows and u.suggested not in u.follows\n  \tall i:Influencer | i.suggested in i.follows.follows and i.suggested not in i.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u:User | not no u.suggested implies u.suggested = u.follows.follows - u and u.suggested not in u.follows\n  \tall i:Influencer | not no i.suggested implies i.suggested = i.follows.follows - i and i.suggested not in i.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n    all u: User |\n        u.suggested = { u1: User | u1 in (User - u) - u.follows + (u.follows.follows & (User - u)) }\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall us,u : User |\n  us in u.suggested implies (us != u and u in u.~follows.~follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u: User | u not in u.suggested\n\tall disj u1, u2: User | some u3: User | u1 in u2.suggested implies (\n  \t\tu1 not in u2.follows and (\n          u3 in u1.follows and u2 in u3.follows))\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, s: User - u | s in u.suggested implies (some u2: User - u | u2 in u.follows and s in u2.follows )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u: User, s: User - u | s in u.suggested iff (some u2: User - u | u2 in u.follows and s in u2.follows )\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u, u1, u2 : User | (u!=u1 and u1!=u2 and u!=u2) and u in follows.u1 and u not in follows.u2 and u1 in follows.u2 implies u in suggested.u2 and u not in u.suggested\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | some f : u.follows.follows | u -> f in suggested implies f not in (u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows.follows | u.suggested = u - f\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows.follows | u.suggested = f - u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all f : u.follows.follows | u.suggested = f - u.follows + u\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User.suggested | all f : u.follows.follows | u in f and u not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n\tall u : User | all s : u.suggested | all f : u.follows.follows | u in f and u not in u.follows\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u,u1,u2 : User | u!=u1 and u1!=u2 and u != u2 and u in suggested.u2 iff (u in follows.u1 and u not in follows.u2 and u1 in follows.u2)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : User | u.suggested = s\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \tall u : User | all s : User - u | u.suggested = (s & u.follows)\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u: User | u.suggested in u.follows.follows implies u.follows.follows not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n   all u, u1: User | u->u1 in follows and u.suggested in u1.follows implies u1.follows not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n   all u, u1: User | u->u1 in follows and u.suggested in u1.follows iff u1.follows not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n   \n  \n     all u, u1: User | u.suggested in u1.follows iff u->u1 in follows and u1.follows not in u.follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  all u : User | u.suggested in (follows.User - u.follows)\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | not u in u.suggested and u.suggested in u.follows.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | not u in u.suggested \n  \tand not u.follows in u.suggested \n  \tand u.suggested in u.follows.^follows\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | (not u in u.suggested \n  \tand not u.follows in u.suggested \n  \tand u.suggested in u.follows.^follows) or no u.suggested\n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | (\n    not u in u.suggested \n  \tand not u.follows in u.suggested \n  \tand u.suggested in u.follows.follows\n  ) \n\t\n}",
                    "{\n\t// Suggested are other users followed by followed users, but not yet followed.\n  \n  \n  \n  \n\n  all u : User | \n  some u.suggested implies (\n    not u in u.suggested \n  \tand not u.follows in u.suggested \n  \tand u.suggested in u.follows.follows\n    and u.suggested in User\n  ) else no suggested\n\t\n}"
                ]
            },
            {
                "description": "A user only sees ads from followed or suggested users",
                "pred": "this/inv8",
                "oracle": "{\n  // A user only sees ads from followed or suggested users.\n  all u: User | (u.sees & Ad) in (u.follows.posts + u.suggested.posts)\n}",
                "erroneous": [
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\t\n  \tall u : User |\n  \t\tall a : Ad |\n  \t\t\ta in u.sees iff\n  \t\t\t\t(some y : User | (y in u.follows + u.suggested) and a in y.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall x:User | x.sees-(Photo-Ad) in x.follows + x.suggested\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in Ad & ( u.follows.posts + u.suggested.posts)\n}",
                    "{\n      all u: User, p: Photo | (p in u.sees) implies ((p in Ad) or (p in u.follows.posts) or (p in u.suggested.posts))\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees = ((u.follows.posts + u.suggested.posts) & Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u.sees = u.follows.posts + u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User | ((u.suggested + u.follows).posts & Ad) in u.sees\n\n}",
                    "{\n    // A user only sees ads from followed or suggested users.\n  \tall u: User | all a: Ad | a in u.follows.posts or a in u.suggested.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | (u.sees & Ad) in (u.follows.posts & u.suggested.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User | u.sees  & Ad = (u.follows.posts + u.suggested.posts) \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | (posts.(u.sees & Ad) - u) in (u.follows + u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User, s: u.sees | all u1: u.follows, u2: u.suggested | (s in u1.posts) or (s in u2.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tUser.sees in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n\n\n\n\n\n\n\n\n\n\n     all a : Ad | posts.a in sees.a.(follows+suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User | all p: u.posts | p not in u.sees\n  \tall u: User | ((u.suggested + u.follows).posts & Ad) in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | some f: u.follows| some s: u.suggested| a in u.sees implies (a in f.posts or a in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | all f: u.follows| all s: u.suggested| a in u.sees implies (a in f.posts or a in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts + u.suggested.posts) in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | all a : Ad | (a in u.sees) implies (a in u.follows.posts or a in u.suggested)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all a: Ad, x, y: User | x->a in sees implies (y->a in posts and (y in x.follows or y in x.suggested))\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User, seg: u.follows | u != seg implies Ad in seg.sees or Ad in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u.sees = u.follows.posts + u.suggested.posts & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u: User, su: User |\n        su in u.suggested =>\n            su not in u.follows and\n            some f: u.follows | su in f.follows\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1:User, p:Photo | u1.sees in Ad implies posts.p in u1.follows or posts.p in u1.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all x : User, y : Photo | x->y in sees and y in Ad implies some z: User | x->z in follows or x->z in suggested\n  }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts & u.suggested.posts) in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts + u.suggested.posts - u.posts) in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u.posts not in u.sees and ((u.follows.posts + u.suggested.posts) <: Ad ) in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | all a : Ad | (a in u.sees) and (a in u.suggested.posts or a in u.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u1, u2 : User, y : Ad | y in u2.posts and y in u1.sees implies u2 in follows.u1 or u2 in suggested.u1  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts) in u.sees & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \t\n\tall u : User | all ad : Ad | ad in u.sees implies posts.ad in (u.follows & u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad in (u.follows + u.suggested).sees & Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | some a : Ad | u -> a in sees implies a in u.follows.posts or a in u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts & u.suggested.posts - u.posts) in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | u.sees - Ad - u.posts in (u.follows.posts + u.suggested.posts )\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u:User | u.sees = (Photo-Ad) + (Ad & (u.follows.posts + u.suggested.posts))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\t\n  \tall ad: Ad, u: User| ad in u.follows + u.suggested\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | (\n    a in u.sees implies posts.a in u.follows\n  )\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n   all u: User | some Ad & (u.sees - u.posts) implies u.follows.posts in Ad and u.suggested.posts in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n   all u : User | ( u.sees & Ad ) in u.follows.posts or ( u.sees & Ad )  in u.suggested.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees not in ((Ad + u.posts) - (u.follows.posts + u.suggested.posts)) or u.sees in none\n }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees not in ((Ad + u.posts) - (u.follows.posts + u.suggested.posts))\n }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees not in (Ad - (u.follows.posts + u.suggested.posts))\n }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | (posts.(u.posts & Ad) - u) in (u.follows + u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User, p: u.follows.posts + u.suggested.posts | p in u.sees => (u in Ad) and u not in u.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad = u.follows + u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User |some a : Ad |a in u.sees implies a in u.follows.posts+ u.suggested.posts-u.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, p : Photo | u in sees.p and p in Ad implies all z : User | z!=u and z in posts.p implies u in follows.z or z in suggested.u\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts) in u.sees & Ad - u.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u:User| u in u.follows and Ad in u.posts implies some u.sees or\n  \tu in u.suggested and Ad in u.suggested.posts implies some u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User | ((u.suggested + u.follows).posts) in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n     all a : Ad | a in (sees.a).(follows+suggested).posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x: User, y: Photo | y in x.sees and y in Ad implies posts.y = x.follows + x. suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  \n  all u : User | all s : u.sees - Ad | one posts.s & u.follows or one posts.s & u.suggested\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User | u.sees.posts & Ad = u.follows.posts & Ad+ u.suggested.posts & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u.sees = u.follows.posts & u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u:User | u.sees in Ad implies (u.sees in u.suggested.posts or u.sees in u.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | Ad in u.sees implies Ad in u.follows.posts + u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, a : Ad | a in u.sees iff posts.a in a.follows or posts.a in a.suggested \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, a:u.sees & Ad | posts.a in u.follows - u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u:User|all a : Ad| a in u.sees iff a in u.follows.posts or a in u.suggested.posts \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tsome u:User | u.sees in u.follows.posts + Ad or u.sees in u.suggested.posts + Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User, s: u.sees, f: u.follows, ss: u.suggested|\n  \ts in Ad implies s in f or s in ss\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.follows.posts+u.suggested.posts :> Ad = u.sees :> Ad\n}",
                    "{\n    all u: User, p: Photo |\n        (p in Ad or (p in u.follows.posts or p in u.suggested.posts)) implies p in u.sees\n}",
                    "{\n  \tall x,y,z: User, p: Photo | (x -> p in sees implies p in Ad and y -> p in posts) or (x -> z in follows and z -> y in follows and x -> y in suggested and y -> p in posts)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, p: Photo | x -> p in sees implies p in Ad and some y: User | y -> p in posts implies (x -> y in follows or x -> y in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, p: Photo | p in Ad and x -> p in sees and some y: User | y -> p in posts and (x -> y in follows or x -> y in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \t\n  \tall a : Ad, u : posts.a | sees.a = follows.u + suggested.u \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in Ad + u.follows.posts \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n   all u: User | some Ad & u.sees implies u.follows.posts in Ad and u.suggested.posts in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User, Ad: Ad | Ad in u.follows.posts or Ad in u.suggested.posts implies Ad in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u:User, a:Ad | a in u.sees implies posts.Ad in u.follows or posts.Ad in u.suggested\n}",
                    "{\n    all u : User, seg : u.follows |\n        u != seg implies \n            all ad : Ad | \n                ad in u.sees implies \n                    (ad in seg.sees or ad in seg.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u:User | u.sees = u.follows.posts + (u.follows.follows - u.follows - u).posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u:User, a:Ad | a in u.follows.posts and a in u.suggested.posts \n  \t\timplies a in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \nall u: User, a: Ad | all f: u.follows| all s: u.suggested| a in f.posts or a in s.posts implies a in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | some f,s: User | all ad: Ad | f in u.follows and s in u.suggested and (ad in u.sees) implies (ad in u.follows.posts or ad in s.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in Ad & u.follows.posts + u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  all u,z : User, a : Ad |\n  \ta in u.sees iff\n  \t\t(z in u.follows or z in u.suggested) and a in z.posts and z != u\n  \n  \n  \n  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  all u : User, a : Ad | some z : u.follows + u.suggested |\n  \ta in u.sees iff\n  \t\ta in z.posts and z != u\n  \n  all u : User | some y : User | some a : y.posts |\n  \ta in Ad and a in u.sees implies \n  \t\t(y in u.follows or y in u.suggested)\n  \t\n  \n \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all user : User | user.sees in (user.follows.posts & Ad & user.suggested.posts & Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees = (u.follows.posts & u.suggested.posts <: Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x: User, y: Photo | y in x.sees and y in Ad implies y = (x.follows + x. suggested).posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u1, u2 : User, y : Ad | (y in u2.posts and y in u1.sees) implies (u1 in follows.u2 or u2 in suggested.u1)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \tall u : User, p : Photo | u in sees.p and p in Ad implies some z : User | z in posts.p implies u in follows.z or z in suggested.u\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | sees.(u.sees & Ad) in (u.follows + u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u: User, f : u.follows, s: u.suggested | u.sees in f or u.sees in s\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | some u.sees + Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u not in u.follows\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts & u.suggested.posts + u.posts) in Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts) in Ad implies u.sees = (u.follows.posts + u.suggested.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts & u.posts) in Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | u.posts - (u.follows.posts + u.suggested.posts) in Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts + u.follows.follows.posts) = u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts + u.follows.follows.posts - u.posts) = u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | u.sees - Ad in (u.follows.posts + u.suggested.posts - u.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts) - u.posts in u.sees & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts  - u.posts) in u.sees & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | (u.follows.posts + u.suggested.posts) in (u.posts & Ad)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts + u.sees.posts) in Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts + u.sees.posts - u.posts) in Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User, p : Ad - u.posts| (u.follows.posts + u.suggested.posts) in p\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows.posts + u.suggested.posts) - u.posts <: Ad in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | ((u.follows.posts + u.suggested.posts) <: Ad in u.sees) and no u.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | ((u.follows.posts + u.suggested.posts) <: Ad in u.sees) and u.sees not in u.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts + u.suggested.posts)) in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts + u.suggested.posts) <: Ad ) = u.sees <: Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts + u.suggested.posts) ) = u.sees <: Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts <: Ad = u.sees) or (u.suggested.posts <: Ad = u.sees))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts <: Ad = u.sees <: Ad) or (u.suggested.posts <: Ad = u.sees))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and ((u.follows.posts <: Ad = u.sees <: Ad) or (u.suggested.posts <: Ad = u.sees <: Ad))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.posts & u.sees = none) and u.sees = (u.follows.posts + u.suggested.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all a: Ad | some u1: User| a in u1.sees implies some u2 : User | a in u2.posts and u2 in {u1.suggested + u1.follows}\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User | all p: u.posts | p not in u.sees\n  \tall u: User | Ad - ((u.suggested + u.follows).posts & Ad) not in u.sees\n  \tall u: User | ((u.suggested + u.follows).posts & Ad) in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | some f: u.follows| some s: u.suggested| a in u.sees implies (f.posts in Ad or s.posts in Ad)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | some f: u.follows| some s: u.suggested| a in u.sees iff (a in f.posts or a in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \nall u: User, a: Ad | some f: u.follows| some s: u.suggested| a in f.posts or a in s.posts implies a in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | all f: u.follows| some s: u.suggested| a in u.sees implies (a in f.posts or a in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User, a: Ad | some f: u.follows| all s: u.suggested| a in u.sees implies (a in f.posts or a in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall ad: Ad, u: User| ad in u.sees implies all v: u.follows + u.suggested - u | ad in v.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\t\n  \tall ad: Ad, u: User| ad in (u.follows + u.suggested).sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\t\n  \tall ad: Ad, u: User| ad in (u.follows + u.suggested - u).posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n\n\n\n\n\n\n\n\n\n\n     all a : Ad | posts.a in sees.a[follows+suggested]\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1,u2 : User, a : Ad | a in u1.sees implies u2 in u1.follows or u2 in u1.follows.follows\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1,u2 : User, a : Ad | a in u1.sees and a in u2.posts implies u2 in u1.follows or u2 in u1.follows.follows\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x: User, y: Photo | y in x.sees and y in Ad implies y.posts = x.follows + x. suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | all a : Ad | a in u.sees => (some u : User | a in u.posts => a in u.suggested or a in u.follows) \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | all us : u.sees | us in Ad implies (us in u.follows or us in u.suggested.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User | u.sees.posts & Ad = u.follows.posts + u.suggested.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u: User | u.sees = follows.u.posts + u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all u : User | u.sees = (Photo-Ad) + (Ad & u.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, a : Ad | a in u.sees iff posts.a in u.follows or posts.a in a.suggested \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, a : Ad | a in u.sees iff posts.a in u.follows or posts.a in u.suggested \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, a : u.sees & Ad | posts.a in u.follows + u\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | all p : u.sees | p in u.follows.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, ad : Ad | (ad in u.sees) implies (ad in follows.u.posts) or (ad in suggested.u.posts)\n  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | some a : Ad | (a in u.sees) and (a in u.suggested.posts or a in u.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all p : User.sees & Ad | p in User.follows.posts or p in User.suggested.posts \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all p : User.sees & Ad | p in User.follows.posts \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in (Ad & (u.follows.posts + u.follows.follows.posts))\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | Ad in u.sees iff Ad in u.follows.posts or Ad in u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | some a: Ad| a in u.follows.posts \n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | all a : Ad | a in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u:User | u.sees in u.follows.posts + Ad or u.sees in u.suggested.posts + Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tone u:User | u.sees in u.follows.posts + Ad or u.sees in u.suggested.posts + Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tsome u:User | u.sees in follows.u.posts + Ad or u.sees in suggested.u.posts + Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User | all p : Photo | p in Ad and p in u.follows or p in u.suggested\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User | all p : Photo | p in Ad and p in u.follows.posts or p in u.suggested.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | no (Ad - u.follows.posts - u.suggested.posts) - u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User| all x: u.follows| all  g : u.suggested| u.sees = (x.posts + u.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User| all x: u.follows| all g : u.suggested| u.sees = (x.posts + g.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User| all x: u.follows.posts| all  g: u.suggested.posts| Ad in u.sees => Ad in x or Ad in g\n}",
                    "{\n  // A user only sees ads from followed or suggested users.\n  all u: User, p: Photo | p in u.sees implies (p in u.follows.posts or p in u.follows.suggested.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u: User | all p: Photo | p in u.sees => (p in u.follows.posts + u.suggested.posts => Ad in p)\n\n}",
                    "{\n    // A user only sees ads from followed or suggested users.\n    all u: User, p: Photo |\n        (p in Ad && some u1: u.follows | p in u1.posts) ||\n        (p in Ad && some u1: u.suggested | p in u1.posts) ||\n        (p not in Ad && some u1: u.follows | p in u1.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User - Influencer, p : Photo | p in u.sees & Ad implies p in u.follows.posts & u.suggested.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User - Influencer, p : Photo | p in u.sees implies (p in Ad or some f: u.follows | p in f.posts) or some s: u.suggested | p in s.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (Ad - (u.follows + u.suggested).posts) not in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all a : Ad | sees.a = follows.posts.a + suggested.posts.a + posts.a\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \n  all a : Ad | sees.a = follows.posts.a + suggested.posts.a - posts.a\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | some a : Ad | a in u.sees implies some f : u.follows + u.suggested | u != f implies a in f.posts \n \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | some a : Ad | a in u.sees implies some f : u.follows + u.suggested | u != f and a in f.posts \n \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1,u2: User | all p : u1.sees | p in u2.posts implies p in Ad and (u2 in u1.follows or u2 in u1.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, us : User.sees | some f : u.follows, s : u.suggested | us in Ad implies us in f.posts or us in s.posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall ad: Ad, u1, u2: User | ad in u1.posts implies u2 in u1.follows or u2 in u1.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, a : Ad | a = u.follows.posts or a = u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees = u.follows.posts or u.sees = u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u : User | u . sees & Ad in (u . follows . posts & u . suggested . posts) - u .posts\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad = (follows.u + u.suggested).sees & Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad in (follows.u + u.suggested).sees & Ad\n}",
                    "{\n  \tall x,y,z: User, p: Photo | x -> p in sees implies (p in Ad and y -> p in posts) or (x -> z in follows and z -> y in follows implies x -> y in suggested and y -> p in posts)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, a: Ad | x -> a in sees and one y: User | y -> a in posts and (x -> y in follows or x -> y in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, a: Ad | x -> a in sees and some y: User | y -> a in posts implies (x -> y in follows or x -> y in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, p: Photo | x -> p in sees implies p in Ad and one y: User | y -> p in posts implies ( x -> y in follows or x -> y in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, p: Photo | x -> p in sees implies p in Ad and some y: User | y -> p in posts and ( x -> y in follows or y -> x in suggested)\n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x: User, p: Photo | some y: User | y -> p in posts and ( x -> y in follows or x -> y in suggested ) and x -> p in sees implies p in Ad \n \n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\tall x,y: User, a: Ad | y -> a in posts and ( x -> y in follows or x -> y in suggested ) and x -> a in sees \n \n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User |some a : Ad |a in u.sees implies a in u.follows or a in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u1, u2 : User, y : Ad | y in u2.posts and y in u1.sees implies u2 in follows.u1 or u2 in suggested.u1 or u2 in Influencer\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u1, u2 : User, y : Ad | y in u2.posts and y in u1.sees implies (u2 in follows.u1 or u2 in suggested.u1) and u1!=u2  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall a : Ad, u : sees.Ad | a in (u.follows.posts + u.suggested.posts)\n  \n  \t\t\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u:User, a:Ad | Ad in u.sees implies Ad in (u.follows.posts + u.suggested.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u:User, a:Ad |  (u.sees & Ad) = (u.follows.posts + u.suggested.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\t\n  \tall u : User |\n  \t\tall a : Ad |\n  \t\t\ta in u.sees iff\n  \t\t\t\t(some y : User | y in u.follows or y in u.suggested and a in y.posts)\n\n}",
                    "{\n  // A user only sees ads from followed or suggested users\n  all u : User, a : Ad |\n    a in u.sees iff \n      some y : User | \n        y in (u.follows & u.suggested) and a in y.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | (u.sees in u.follows.posts) or (u.sees in u.suggested.posts)\n }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees in (Ad - u.follows.posts & Ad - u.suggested.posts)\n }",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | u.sees not in (Ad - u.follows.posts + Ad - u.suggested.posts)\n }",
                    "{\n  // A user only sees ads from followed or suggested users.\n  all u: User | all a: Ad | a in u.sees implies some u.follows + u.suggested & posts.a\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad = u.follows || u.sees & Ad = u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | some u2 : posts.(u.sees) | u2 in u.follows or u2 in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | some ad: Ad | ad in u.sees implies (some f: User | u in f.follows or u in f.suggested and ad in f.posts)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User {\n\t\tu.follows.posts & Ad in u.sees\n\t\tu.suggested.posts & Ad in u.sees\n\t\t(Ad - u.follows.posts & Ad - u.suggested.posts & Ad) not in u.sees\n\t} \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | (u.follows+ u.suggested) in posts.(u.sees & Ad)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | posts.(u.posts & Ad) in (u.follows + u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | (posts.(u.posts & Ad) - u) = (u.follows + u.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User | all s: u.sees | u.sees in Ad implies s in (u.follows + u.suggested).posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1,u2:User, a:Ad | u2 in posts.Ad and a in u1.sees \n  \t\timplies u2 in u1.follows or u2 in u1.suggested and u1!=u2 \n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1,u2:User, a:Ad | u2 in posts.Ad and a in u1.sees and u1!=u2 \n  \t\timplies u2 in u1.follows or u2 in u1.suggested \n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u1:User, a:Ad | \n  \t\ta in u1.sees iff\n   \t\t\t(posts.a in u1.follows or posts.a in u1.suggested)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u: User, seg: u.follows | u != seg implies Ad in seg.posts or Ad in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall u : User, a : Ad, u2 : User.follows + User.suggested| a in u.sees implies (a in u2.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u:User | u.sees = u.follows.posts + (u.follows.follows - u.follows - u).posts & Ad\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u:User | \n  \tu.sees = (u.follows.posts + (u.follows.follows - u.follows - u).posts) & Ad\n}",
                    "{\n  all u : User, a : Photo| a in Ad and a in u.sees implies (some u1: User | u1 in u.follows and a in u.posts) or (some u2: User | u2 in u.suggested and a in u2.posts)\n  \n\t// A user only sees ads from followed or suggested users.\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\n  all u, u1 : User, p : Photo |  u != u1 and u in follows.u1 or u1 in suggested.u\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\n  all u, u1 : User, p : Photo |  u != u1 and u in follows.u1 or u1 in suggested.u implies p in Ad\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees & Ad in follows.u.posts + u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \t\n  \tall u: User | u.sees & Ad = ( u.follows.posts + u.suggested.posts + Influencer.posts ) & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall a: Ad | lone u: sees.a.follows + sees.a.suggested | Ad in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall a: Ad | lone u: sees.a.follows + sees.a.suggested - posts.a | Ad in u.sees\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n      all x: User | (sees in (x.follows + x.suggested)->Ad)\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n          all x: User | (sees.Ad in (x.follows + x.suggested))\n\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n          all x: User | (sees.Ad in (x.follows + x.suggested + x))\n\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | all f,s: User | all ad: Ad | f in u.follows and s in u.suggested and (ad in u.sees) implies (ad in u.follows.posts or ad in s.follows.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u: User | all f,s: User | all ad: Ad | u != f and u != s and f in u.follows and s in u.suggested and (ad in u.sees) implies (ad in f.posts or ad in s.posts)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  all u : User, a : Ad, z : u.follows + u.suggested |\n  \ta in u.sees iff\n  \t\ta in z.posts and z != u\n  \n  \n \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  all u : User, a : Ad | some z : u.follows + u.suggested |\n  \ta in u.sees iff\n  \t\ta in z.posts and z != u\n  \n  \n \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  \n  \n  \n  \n  all u : User | some y : User | some a : y.posts |\n  \ta in Ad and a in u.sees implies \n  \t\t(y in u.follows or y in u.suggested)\n  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \t\n  \t\n  \n  \n  \n  \n  all u : User | some y : User | some a : y.posts |\n  \ta in Ad and u != y and a in u.sees implies \n  \t\t(y in u.follows or y in u.suggested)\n  \n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees not in (u.follows.posts & u.suggested.posts & Photo - Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u, u2: User | all a: Ad | a in u.sees implies a in u2.posts and u2 in u.follows or u2 in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u, u2: User | all a: Ad |( u != u2 and a in u.sees) implies a in u2.posts and u2 in u.follows or u2 in u.suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u:User, a:Ad| u.sees in a implies ((posts.a in u.follows) or (posts.a in u.suggested))\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, p : Ad | \n  \tu.sees = u.follows & u.suggested \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, p : Photo | \n\tp in u.sees implies (p in u.follows.sees or p in u.suggested.sees)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User, p : Photo | \n\t p in u.sees implies (p in u.follows.sees or p in u.suggested.sees or p in Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n    all u: User, su: User |\n        su in u.suggested =>\n            su not in u.follows and\n            some f: User | f in u.follows.follows and su not in f.follows\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n   all u: User, su: User |\n        su in u.suggested =>\n            su not in u.follows and\n            some f: User | f in u.follows.follows and su in f.follows\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n     all u: User, su: User |\n        su in u.suggested =>\n            su not in u.follows and\n            some f: User | f in (u.follows.follows - u.follows) && su in f.follows\n\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall disj u1, u2: User, p: Ad | p in u1.sees implies (\n      p in u2.posts and (u2 in u1.follows or u2 in u1.suggested))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall p: Photo | p in User.posts\n  \tall disj u1, u2: User, p: Ad | p in u1.sees implies (\n      p in u2.posts and (u2 in u1.follows or u2 in u1.suggested))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall p: Ad | p in User.posts\n  \tall disj u1, u2: User, p: Ad | p in u1.sees implies (\n      p in u2.posts and (u2 in u1.follows or u2 in u1.suggested))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall p: Ad | p in User.posts\n  \tall p: Photo, u: User | p in u.posts implies p not in u.sees\n  \tall disj u1, u2: User, p: Ad | p in u1.sees implies (\n      p in u2.posts and (u2 in u1.follows or u2 in u1.suggested))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  \tall p: Ad | p in User.posts\n  \tall p: Ad, u: User | p in u.posts implies p not in u.sees\n  \tall disj u1, u2: User, p: Ad | p in u1.sees implies (\n      p in u2.posts and (u2 in u1.follows or u2 in u1.suggested))\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x, z : User| some p : Photo | x != z and (x in follows.z or x in suggested.z) implies p not in Ad\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x, z : User| some p : Photo | x != z and z in posts.p and x in sees.p\n  \n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x, z : User| some p : Photo | x != z and z in posts.p and x in sees.p and (x in follows.z or x in suggested.z) implies p not in Ad\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall x, z : User| all p : Photo | x != z and z in posts.p and x in sees.p and (x in follows.z or x in suggested.z) implies p not in Ad\n  \n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | some a : Ad | u -> a in sees implies a in u.follows.posts - u.posts or a in u.suggested.posts\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u,u1 : User, a : Ad | u != u1 and u in sees.a iff u in follows.u1 or u1 in suggested.u\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u,u1 : User, a : Ad | (u != u1 and u in sees.a) iff (u in follows.u1 or u1 in suggested.u)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u,u1 : User, a : Ad | u in sees.a iff u != u1 and u in follows.u1 or u1 in suggested.u\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u,u1 : User, a : Ad | u1 in posts.a and u in sees.a iff u != u1 and u in follows.u1 or u1 in suggested.u\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n \tall u : User, p : Photo | u in sees.p and p in Ad implies (some z : User | z in posts.p implies u in follows.z or u in suggested.z)\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | Ad & u.sees = u.follows & Ad + u.suggested + Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | Ad & u.follows.posts not in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | Ad & u.follows.posts + u.posts not in u.sees\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n  all u : User | u.sees & Ad = u.follows.posts & Ad + u.suggested & Ad\n\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u, u1: User | Ad in u.sees iff u!=u1 and u->u1 in follows or u->u1 in suggested\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in (u.follows.posts & Ad)\n}",
                    "{\n\t// A user only sees ads from followed or suggested users.\n\tall u : User | u.sees in  ( u.suggested.posts & Ad)\n}"
                ]
            }
        ]
    },
    {
        "example": "Production line",
        "model": "sig Workstation { workers : set Worker, succ : set Workstation } one sig begin in Workstation {} one sig end in Workstation {} sig Worker {} sig Human extends Worker {} sig Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {}",
        "id": "dyj49tEp7j6aWAQQX",
        "requirements": [
            {
                "description": "Workers are either human or robots",
                "pred": "this/inv1",
                "oracle": "{\n\t// Workers are either human or robots\n all w: Worker | w in Human or w in Robot\n}",
                "erroneous": [
                    "{\n\t// Workers are either human or robots\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n all w: Worker | w in Human and w in Robot\n}",
                    "{\n\t// Workers are either human or robots\n  all w:Workstation | w.workers in Robot or w.workers in Human\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall e : Worker | e=Human or e=Robot \n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in Human + Robot and some w.workers\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w = Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tWorker in Human or Worker in Robot\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w in Human\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Workstation | w.workers = Human + Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot) and some w.workers and no Worker\n}",
                    "{\n\t// Workers are either human or robots\n\tWorkstation.workers = Human + Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall u: Worker | Human in u or Robot in u\n}",
                    "{\n\t// Workers are either human or robots\n  \tWorkstation.workers + Workstation.^succ.workers in Human or Workstation.workers + Workstation.^succ.workers in Robot\n  \t\n}",
                    "{\n\t// Workers are either human or robots\n\tWorker-(Human+Robot) & Workstation.workers = none\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | (w.workers not in Human) or (w.workers not in Robot)\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ, w: ws.workers | w in Human or w in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w not in Human and w not in Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Worker | w in Human or w !in Robot\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Workstation | Human in w.workers  or Robot in w.workers\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | Worker !in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | (Human in Worker implies Human in w.workers) \n\tor (Robot in Worker implies Robot in w.workers) and lone w.workers and Worker in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | (Human in Worker implies Human in w.workers) \n\tand (Robot in Worker implies Robot in w.workers) and lone w.workers and Worker in w.workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot)\n  \tall h: Human | h in workers.h\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Workstation | w.workers in (Human + Robot)\n  \tall H: Human | some w: Workstation | H in w.workers\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation, w: ws.workers | w in Human and w not in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation| (ws.workers in Human and ws.workers not in Robot) or (ws.workers not in Human and ws.workers in Robot)\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ | ws.workers in Human or ws.workers in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall ws: Workstation.^succ, w: ws.workers | ws in Human or ws in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  \tall w: Workstation | w.workers + w.^succ.workers in Human or w.workers + w.^succ.workers in Robot\n  \t\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation.workers | w = Human or w = Human\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation | w.workers = Human or w.workers = Human\n}",
                    "{\n\t// Workers are either human or robots\n\tall w : Workstation | w.workers = Human or w.workers = Robot\n}",
                    "{\n\t// Workers are either human or robots\n  not Worker in (Worker - Human - Robot)\n}",
                    "{\n\t// Workers are either human or robots\n\tHuman + Robot in Workstation.workers\n}",
                    "{\n\t// Workers are either human or robots\n  all h: Human, r: Robot | Workstation->h in workers or Workstation->r in workers\n\t\n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w in Robot\n\t\n}",
                    "{\n\t// Workers are either human or robots\n\tall disj w,a : Worker | (w = Human implies a = Human) or (a = Robot implies w \t\t= Robot)\n}",
                    "{\n\t// Workers are either human or robots\n\tall disj w,a : Worker | w.(~workers) =a.(~workers)implies((w = Human implies \t  a = Human) or (a = Robot implies w = Robot))\n}",
                    "{\n\t// Workers are either human or robots\n\tsome w : Worker | w = Human or w = Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall w: Worker | w in Human or w = Robot\n}",
                    "{\n\t// Workers are either human or robots\n\tall wo: Workstation | (Human in wo.workers implies Robot not in wo.workers) and \t\t\t\t\t\t  (Robot in wo.workers implies Human not in wo.workers)\n}",
                    "{\n\t// Workers are either human or robots\n\tsome Human+Robot & Workstation.workers \n}",
                    "{\n\t// Workers are either human or robots\n  all w : Worker | w =  Human - Robot\n\t\n}"
                ]
            },
            {
                "description": "Every workstation has workers and every worker works in one workstation",
                "pred": "this/inv2",
                "oracle": "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation | some ws.workers\n  \tall w: Worker | one ws: Workstation | w in ws.workers\n}",
                "erroneous": [
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all wst : Workstation | some wst.workers and one workers.wst \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t(all w : Workstation | some w.workers) and (all w1 : Worker | w1 in Workstation.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \t\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker, k: Workstation | w in k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all wst : Workstation , w : Worker| some wst.workers and one workers.wst \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | some wo.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w:Worker | w in Workstation.workers\n  \t\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \tall w: Worker, k: Workstation | w in k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | some(w.workers)\n  \tall w : Worker | lone(workers.w)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall u: Worker | one w: Workstation | u in w.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tall w : Worker | w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | some w.workers and one ~workers.w\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers and (all w: Worker | one s: Workstation | w in s.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | lone wo: Workstation | w in Workstation.workers and w in wo.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker, k: Workstation | some k.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall ws: Workstation | ws.workers in Workstation and all w: ws.workers | w in ws\n\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | some w1 : Worker | w1 in w.workers\n  \tone w : Workstation | all w1 : Worker | w1 in w.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation |\n\t\tone ws.workers and\n\t\tall w : Worker | w in Worker and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s : Workstation, w: Worker | some s.workers and some workers.w \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s: Workstation | all w: Worker | w in s.workers\n  \tall w: Worker | one s: Workstation | w in s.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wt : Workstation | one w : Worker | w in wt.workers\n  \tone wt : Workstation | all w : Worker | w in wt.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tsome w1: Worker | Workstation.workers = w1\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and lone ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t(all w: Workstation | some w.workers)\n\t&& (all w: Worker | one (Workstation->Worker).w)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation | some ws.workers\n\tone Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tone workers.Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker |  w in Workstation.workers\n  \tsome w: Worker | lone ws: Workstation | ws.workers = w\n  }",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | #(w.workers) > 1\n  \n    all w: Worker | one work : Workstation | w in work.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t(all w: Workstation | some w.workers)\n\t&& (all w: Worker | one (Workstation->workers).w)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers implies #x.workers > 1 \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t\n\t\n\tone x: Workstation, y: Worker | some x implies y in x.workers\n\n\tall x: Workstation, y: Worker | some y implies one x\n  \n\n  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers implies y in x.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall x : Workstation | some Worker \n    all x : Worker | one Workstation\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation one -> one Worker)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation | some wks : ws.workers | no (wks & (Workstation - ws).workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all wo : Workstation | (lone w : Worker | wo-> w in workers )\n\n  all w : Worker | (one wo : Workstation | wo -> w in workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker | some w2: Worker |  w in Workstation.workers and Workstation.workers = w2\n  \tsome w: Worker | lone ws: Workstation | ws.workers = w\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all w : Workstation | some w.workers\n  all w : Worker | one s : Workstation | w in s.workers implies w not in (Workstation-s).workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human)  > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Workstation, u: Worker | (u in w.workers) implies (u in Human or u in Robot)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | one ws1 : Workstation | some w1 : Worker | w1 in ws1 and w in ws\n}",
                    "{\n\t\n\tall ws: Workstation | ws.workers != none and all w: ws.workers | w in ws.workers and w in Human + Robot\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  workers in Workstation some -> one Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker |  one (ws.workers)  and some workers.w \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation, u: Worker | some w.workers or one workers.u\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation | #ws.workers>0 and no ws1: Workstation | ws1 != ws and #(ws.workers & ws1.workers) =0\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation, we : Worker | some w.workers and lone we.~workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers implies #workers.y=1\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation lone -> one Worker )\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers in (Workstation some -> lone Worker)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall k: Workstation | some k.workers\n  \tsome w: Worker, k1: Workstation, k2: Workstation | (w not in k1.workers) and (w not in k2.workers)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | some workstation.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wo: Workstation, wor: Worker | one wo.workers and one workers.wor\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all w:Workstation | some ws:Worker | ws in w.workers \n  all ws:Worker | one w:Workstation | w.workers in ws\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall s : Workstation, w : Worker | some Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tsome Workstation.workers\n  \tall w : Human | w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and some ws.workers and some ws.succ.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w : Worker, ws : Workstation | ws in workers.w and ws.workers in w and some ws.succ.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall x : Workstation | some Worker \n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\n  all w : Worker, s : Workstation | some s.workers and one workers.w\n  all s : Workstation | s.succ in Workstation-s\n  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws : Workstation |\n\t\tone ws.workers and\n\t\tall w : Worker | w in Worker-Robot and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | w in Human or w in Robot\t\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall wk : Workstation | all w : Worker | some wk.workers and (w in wk.workers <=> w not in wk.workers.^(succ)) and (wk not in wk.succ)\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation | x.workers != none\n  \tall x: Worker | some y: Workstation | x in y.workers implies\n  \t\t\t\t\t\t\t\t\tx not in (Workstation - y).workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation | ws.workers in Worker\n\tall w: Worker | one Workstation.workers\n\tall sw: Workstation.succ | sw.workers in Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | one ws1 : Workstation | some w1 : Worker | w1 in ws1.workers and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone ws : Workstation | all w : Worker | all ws1 : Workstation | some w1 : Worker | w1 in ws1.workers and w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tone ws : Workstation | all w : Worker | w in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall wt : Workstation | some w : Worker | w in wt.workers\n  \tsome wt : Workstation | all w : Worker | w in wt.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\t\n  \tsome w: Worker | lone ws: Workstation | ws.workers = w\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker | some w2: Worker |  w in Workstation.workers and Workstation.workers = w2\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w: Worker | some w2: Worker | lone w3: Workstation |  w in Workstation.workers and w3.workers = w2\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human) > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n  \tno w: Worker | some ws: Workstation | w not in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \tall w: Workstation | #(w.workers) > 0 and #(w.workers & Human) > 0 \n  \tall disj w1,w2: Workstation |  #(w1.workers & w2.workers) = 0\n  \tno w: Worker | lone ws: Workstation | w not in ws.workers\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | one w2 : Workstation | all ws : Worker | some w.workers and w2.workers = ws\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Worker | lone x:Workstation| w in Workstation.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker | one (ws.workers)\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  \n  all ws : Workstation, w : Worker |  some (ws.workers)  and one workers.w and some ws.succ\n\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall ws: Workstation, w: Worker | one ws1: Workstation | (ws -> w in workers) implies w in ws1 \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall w : Workstation | #(w.workers) > 1\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers) \n  all w: Worker | one ws: Workstation | w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n  all ws: Workstation, w: Worker | (ws in ws.succ) implies (w in ws.workers) \n  all w: Worker | some ws: Workstation | w in ws.workers\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tWorkstation.workers != none implies Workstation.workers = Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tworkers.Worker = Workstation and #workers = #Worker\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tone x: Workstation| one y: Worker | y in x.workers and x in workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | one x.workers iff one workers.y  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation, y:Worker | some x.workers iff one workers.y  \n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | some x.workers and one workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | x in x.workers implies some x.workers and one workers.y\n}",
                    "{\n\t// Every workstation has workers and every worker works in one workstation\n\tall x: Workstation| one y: Worker | x in workers.y implies some x.workers and one workers.y\n}"
                ]
            },
            {
                "description": "Every component is assembled in one workstation",
                "pred": "this/inv3",
                "oracle": "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one c.workstation\n}",
                "erroneous": [
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one w: Workstation | c in w.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | some c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    all c : Component | one Workstation \n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | lone c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone Component.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component one -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c:Component | c.workstation = Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component lone -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | one w : Workstation | c.workstation in w\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone x: Workstation|all c:Component | c in workstation.x\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone w: Workstation | all c: Component | c in c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone c : Component | one w : Workstation | w in c\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c: Component | #c.workstation = 2\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n    workstation in Component some -> Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  \tall c : Component, p : Product | p.parts in c.workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall p:Product | p in Component and one(p.workstation)\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | c.workstation not in (Component-c).workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component | all w1, w2 : Workstation | w1 in c.workstation implies w2 not in c.workstation and w1 != w2\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tworkstation in Component one -> one Workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n  lone Component.workstation\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall p: Product | all c: p.parts | c.workstation = p.parts.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tone c : Component | one w : Workstation | w in c.workstation\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c : Component | one w : Workstation | c.parts in w.succ\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component, w : Workstation | c.workstation in w\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n  all c : Component | c.workstation in Workstation.succ\n\n}",
                    "{\n\t// Every component is assembled in one workstation\n\tall c: Component | one Component.workstation\n}"
                ]
            },
            {
                "description": "Components must have parts and materials have no parts",
                "pred": "this/inv4",
                "oracle": "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts\n    all m: Material | no m.parts\n}",
                "erroneous": [
                    "{\n  // Components must have parts and materials have no parts\n  all c: Component, m: Material | some c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts and all m: Material | no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | some p.parts implies p in Component \n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall o: Component | some o.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t(some Component.parts) and (no Material.parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Material | p.parts not in Product\n  \tall p: Component | p.parts in Product\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p : Product | p in Component and some p.parts\n  \tall m : Product | m in Material and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall m:Material |\n  \t\tm.parts not in Product.parts\n  \n  \tall c:Component |\n  \t\tsome p:Product.parts |\n  \t\t\tp in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.parts in Product and no m: Material | m.parts in Product\n\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\t\n  \t\n  \tall c: Component | c.parts in (Product - c)\n  \tall m:Material | m.parts not in (Product)\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, m:Material | some p:Product | p in c.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | c.parts != none and all m: Material | no parts.m\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | p.parts in (Component-Material)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \t\n  \tall c: Component | c.*parts in (Product - c)\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c : Component | some parts.c\n  \n  all m : Material | no parts.m\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t\tall c : Component , m : Material | some c.*parts and no m.parts \n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c: Component, m: Material | #c.parts>0 and #m.parts =0 and c not in c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | some c.parts\n\tno Product.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c:Component | some p: Product | p in c.parts\n  \tall c:Material | some p: Product | p not in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p : Product, m : Material, c : Component | p in c.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tno (iden & parts) and parts in (Component -> some Product)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p : Product | parts.p = Component\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, p: Product | c in p.parts\n  \t all m: Material, p: Product | not m in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t\n  \t \n  \n  \tall c: Component, p: Product | c in p implies c in p.parts\n  \t all m: Material, p: Product | m in p implies m not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tsome (Product & Component - Dangerous).parts and no (Product & Material - Dangerous).parts \n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some p : Product | p in parts.c and p not in parts.m\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component, m: Material | c in c.parts and m not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\tall c : Component, m : Material, p : Product | one p2 : Product | c not in c.parts and c not in parts.c and p not in m.parts and p2 in c.parts\n}",
                    "{\n  all p : Product | p not in p.parts and #(p.parts)>0 implies p in Component \n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tparts in (Component -> set Product -iden)\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material, p : Product | one p2 : Product | p not in m.parts and p2 in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\t\n    Product not in Material.parts\n  \tProduct in Component.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product| (p = Component implies #(p.parts)>0 and p not in p.parts) and\n  \t(p = Material implies p.parts = none)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | lone c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | all m : Material | some c.parts - c and no m.parts\t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \t#(Component & Product.parts) != 0\n  \t#(Material & Product.parts) = 0\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  no parts.Material\n  all c:Component | some c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall p : Product | p.parts in Component\n  \tall p : Product | not p.parts in Material\n  \t\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some parts\n  \tall m: Material | not some parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, x: Workstation, p:Product | c in workstation.x implies (c in parts.p and Material not in parts.p)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p:Product | p in Material implies not one p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tno p:Product | p.parts in Material\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Component | some(c.parts)\n\tsome(Component <: parts) and no (Material <: parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | c.parts != none\n  \tall c : Material | c.parts != none\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: (Material + Component) | (c in Material) implies some c.parts else no c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some p : Product | c in parts.p and m in parts.p \n}",
                    "{\n  all c : Component | one p : Product | all m : Material | p in c.parts and p not in m.parts\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n  all c : Component | one p : Product | all m : Material | p in c.parts and p not in m.parts and c not in c.parts and m not in m.parts\n\t// Components must have parts and materials have no parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n\t\n  \n  \tall c : Component | some Component.parts\n  \tall m : Material | no Material.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Product | some p: c.parts | p in Product implies c in Component\n  \tall prod:Product | one p:prod.parts | p not in Product implies prod in Material\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component, m : Material | some c.parts\n    all m : Material | no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component| one wt :Workstation | wt in c.workstation\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.parts in (Product - c)\n  \tall m:Material | m.parts not in (Product - m)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c: Component | c.^parts in (Product - c)\n  \tall m: Material  | m.parts not in (Product)  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \tall p:Product | p not in p.^parts\n  \t\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \t\n  \tall c: Component | c.^parts in (Product - c)\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n \tall p:Product | p.parts in (Product-p)\n  \t\n  \t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \t#(Component & Product.parts) != 0\n  \t#(Material & Product.parts) != 0\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c : Component | all m : Material | some c.parts - c and no m.parts - m\t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \tall c : Component, p : Product | p.parts in c\n  \tall m : Material, p : Product | m not in p.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n  \tall c:Component | some p: Product | c.parts = p\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | some p:Product | p in p.parts and p not in m.parts\n  \tall c:Component | some p: Product | p in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | some c.parts\n  \tall m: Material | one m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product, c: Component, m: Material |\n  \t\tsome c.parts implies no m.parts\n  \t\t\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | c-> c in parts\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | (some c1 : Component | c-> c1 in parts)\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  \n  all c : Component | (some c : Component | c-> c in parts)\n  all m : Material | no m.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product | some p2: Product | p != p2 and (p in Component implies p2 in p.parts) or (p in Material implies p2 not in p.parts)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product | some p2: Product | p in Material implies p2 not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall disj p, p2 : Product | p in Material implies p2 not in p.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Product| (p = Component implies p.parts != none) and\n  \t(p = Material implies p.parts = none)\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  all c : Component, m : Material | some c.parts\n\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c: Component | all m: Material | c in c.parts and no m.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n  some Component.parts and no Material.parts and all c:Component| c not in c.parts \n\n}",
                    "{\n\t// Components must have parts\n  all c: Component | lone(c.parts)\n  \n  all m: Material | no m.parts \n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall c:Component, m:Material | c.parts != none and m.parts = none\n  \tall c:Component | c not in c.parts\n}",
                    "{\n\t// Components must have parts and materials have no parts\n\tall p: Material |\n  \t\tp.parts = none \n  \n  \tall p: Component |\n  \t\tsome (p.parts - p)\n  \n  \tProduct = Material + Component\n  \t\t\n}"
                ]
            },
            {
                "description": "Humans and robots cannot work together",
                "pred": "this/inv5",
                "oracle": "{\n\t// Humans and robots cannot work together\n\tall w: Workstation, h: Human, r: Robot | (h in w.workers) implies (r not in w.workers)\n    \n  \t\n  \t\n}",
                "erroneous": [
                    "{\n\t// Humans and robots cannot work together\n  \tall w:Workstation | no (w.workers & Human & Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) implies (Robot not in w.workers)\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n    all w: Workstation, workers: w.workers | workers in Human or workers in Robot \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | some w : Worker | w in Human implies ws in workers.w or \n  \tw in Robot implies ws in workers.w\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno disj w1, w2: Worker | w1 in Human and w2 in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | w.workers in Human implies w.workers not in Robot \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human & Robot) not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall y1,y2: Worker, x: Workstation | (y1 in x.workers) and(y1 in Human) implies (y2 not in x.workers) and (y2 not in Robot)  \n\n  \n\n  all r: Robot, h:Human, x:Workstation | x in workers.r implies x not in workers.h\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h:Human, r:Robot |some workers.h implies no workers.r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | no w.workers & (Human + Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) <=> (Robot not in w.workers)\n  \t\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | w.workers = Human or w.workers = Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\tall ws: Workstation | one h: Human| (h in ws.workers) implies ws.workers in Human\n}",
                    "{\n\t\n  \tall ws: Workstation + Workstation.succ | one p:ws.workers | p in Human implies ws.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tWorkstation.workers in Human or Workstation.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws: Workstation | ws.workers not in (Human + Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | some w : Worker | w in ws.workers implies w in Human or w in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | all w : Worker, r : Robot | (wo in workers.w implies wo not in workers.r)\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w1,w2:Worker, wk:Workstation | w1 in wk.workers and w2 in wk.workers implies \n w1 in Human and w2 in Robot or w1 in Robot and w2 in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | one x : Worker| (x in w.workers and x in Human) implies w.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tone w: Workstation | all h: Human, r: Robot | h&r not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | Human in w.workers or Robot in w.workers\n\t\n    \n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj w1, w2: Worker | (w1 in Human and w2 in Robot) implies no workers.w1&workers.w1\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | some h: Human | all r: Robot | h in w.workers implies r not in w.workers \n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | all wrk: w.workers | wrk in Human\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w : Worker | (w in Human) iff (w not in Robot) \n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | (w.workers = Worker - Human) or (w.workers = Worker - Robot)\n\t\n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some r: Robot | r in w.workers implies all wor: Worker | wor in w.workers and wor in Robot\n  \tall w : Workstation | some r: Human | r in w.workers implies all wor: Worker | wor in w.workers and wor in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human | all r: Robot |one w:Workstation|  h in w.workers implies r not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall x: Workstation | x.workers in Human implies x.^succ.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | Human in w.workers => no Robot & w.workers else w.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\tall ws: Workstation | some p: Worker | (p in ws.workers and p in Human) or (p in ws.workers and p in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tHuman in Workstation => Robot not in Workstation\n  \tRobot in Workstation => Human not in Workstation\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Workstation | some w.workers & Robot => no w.workers & Human and no w.succ.workers & Human\n  all w: Workstation | some w.workers & Human => no w.workers & Robot and no w.succ.workers & Robot\n  \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w : Workstation |  some (w.workers&Robot) implies no(w.workers&Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers = h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n    \n    \n    \n  \tall h: Human, r: Robot, w: Workstation | w.workers != h & r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Worker | all s: Workstation | w in Human implies (s.workers in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w implies not Robot in w\n    all w : Workstation.workers | Robot in w implies not Human in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | all w1, w2: Worker | w1 in ws.workers and w2 in ws.workers \timplies ((w1 = Robot and w2 = Robot) or (w1 = Human and w2 = Human))\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | ws.workers not in Human and ws.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | all w: Worker | w in ws.workers and (w in Robot iff not w in Human)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | all  w1: Worker, w2 : Worker | w1 in ws.workers and w2 in ws.workers and (w1 in Robot and w2 in Robot ) or (w1 in Human and w2 in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation | \n  \t\t(all w: ws.workers | w in Robot)\n\t\tor\n\t\t(all w: ws.workers | w in Robot)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | Human in w.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human not in w.workers) <=> (Robot not in w.workers)\n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) => (Robot in w.workers)\n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | (Human in w.workers) => !(Robot in w.workers)\n    all w: Workstation | (Robot in w.workers) => !(Robot in w.workers)\n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome w: Workstation | (w.workers = Worker - Human) or (w.workers = Worker - Robot)\n  \t\n\t\n    \n  \t\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some r: Robot | r in w.workers implies all wor: Worker | wor in w.workers and wor in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some r: Robot | r in w.workers implies all human: Human | human not in w.workers\n  \tall w : Workstation | some r: Human | r in w.workers implies all robot: Robot | robot not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation| (some w:Human | w in ws.workers implies workers.w not in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | (some w:Worker | w in Human and w in ws.workers implies all w1:Worker | w1 in Robot and w1 not in ws.workers) \n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w:Human | (some ws : Workstation | w in ws.workers implies Robot not in ws.workers)  \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human, r: Robot | no workers.(h + r)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human, r: Robot | Workstation.workers not in (h + r)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome Workstation.*(succ.workers) & Human iff\n  \t\tno Workstation.*(succ.workers) & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome begin.*(succ.workers) & Human iff\n  \t\tno begin.*(succ.workers) & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall  ws:Workstation | some h:Human| (h in ws.workers) implies ws.workers in Human\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall  ws:Workstation | some h:Human| (h in ws.workers) implies ws.workers in Human\n    all  ws:Workstation | some r:Robot| (r in ws.workers) implies ws.workers in Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Workstation | Human in w.workers => Robot not in w.workers else w.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tsome p1,p2: Worker | all w : Workstation | (p1 in w.workers) and (p2 in w.workers) iff (p1 in Human and p2 in Robot) or (p1 in Robot and p2 in Human)  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tno h: Human, r: Robot | some w: Workstation | w.workers = h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n    \n  \n\n\tWorkstation.workers = Human + Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n  \tall ws:Workstation | some ws.workers & Worker iff no ws.workers & Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w1:Human ,w2:Robot | some ws:Workstation | w1 in ws.workers implies w2 not in ws.workers\n  \n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | Human in ws.workers implies no (Robot & ws.workers)\n  \tall ws : Workstation | Robot in ws.workers implies no (Human & ws.workers)\n  \n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Worker | all wk: Workstation | some wk.workers + Human + Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall disj u1, u2 : Worker, w : Workstation | u1 in w.workers implies u2 not in w.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\tall ws: Workstation | one h: Human| one r:Robot| (h in ws.workers) implies ws.workers in Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\tall ws: Workstation | one h: Human| (h in ws.workers) implies ws.workers in Human\n  \tall ws: Workstation | one r: Robot| (r in ws.workers) implies ws.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\t\n  \tall ws: Workstation | one r: Robot| (r in ws.workers) implies ws.workers in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \t\n  \t\n\tall ws: Workstation | one p: Worker | (( p in ws.workers and p in Human) implies ws.workers in Human ) and ((p in ws.workers and p in Robot) implies ws.workers in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tHuman in Workstation.workers => Robot not in Workstation.workers\n  \tRobot in Workstation.workers => Human not in Workstation.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  no disj h1, h2: Human | h1.workstation = h2.workstation\n\tno disj r1, r2: Robot | r1.workstation = r2.workstation\n}",
                    "{\n\t// Humans and robots cannot work together\n  all ws: Workstation |\n\t\tall wr: ws.workers |\n\t\t\t(wr in Robot => no ws.succ.workers & Human) and\n\t\t\t(wr in Human => no ws.succ.workers & Robot)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno disj h1, h2: Human | workers.h1 & workers.h2 != none\n    no disj r1, r2: Robot | workers.r1 & workers.r2 != none\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w: Human | w.workers in Robot and no w: Robot | w.workers in Human\n\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w: Human | w.workers in Robot and no w: Robot | workers.w in Human\n\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj w1, w2: Worker | (w1 in Human and w2 in Robot) or (w1 in Robot and w2 in Human)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno w : Workstation |  no (w.workers & Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall h: Human | all r: Robot | one workers.h implies no workers.r\n  \tall h: Human | all r: Robot | one workers.r implies no workers.h\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers in h + r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall disj h: Human, r: Robot | Workstation.workers = h or Workstation.workers = r\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno h: Human, r: Robot | one w: Workstation | h & r in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n  \n\tall h : Human , r : Robot | some (workers.h & workers.r)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Workstation | workers in w -> Human or workers in w -> Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w: Worker | w in Human \n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers, r : Robot | some h : Human | h in w implies not r in w\n    all w : Workstation.workers, r : Human | some h : Robot | r in w implies not h in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation.workers | Human in w implies no w - Human\n    all w : Workstation.workers | Robot in w implies no w - Robot\n}",
                    "{\n  all ws : Workstation| all disj w,w1 : Worker | w in ws.workers and w1 in ws.workers and( w in Robot implies w1 in Robot) or (w in Human implies w1 in Human)\n\t// Humans and robots cannot work together\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws: Workstation | one h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws: Workstation | all h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tone ws: Workstation | all h: Human | h in ws.workers implies !(Robot in ws.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tone ws: Workstation | (Human in ws.workers implies !(Robot in ws.workers)) and\n  \t(Robot in ws.workers implies !(Human in ws.workers))\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tsome ws: Workstation | (Human in ws.workers implies !(Robot in ws.workers)) and\n  \t(Robot in ws.workers implies !(Human in ws.workers))\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | no w1, w2: Worker | w1 in ws.workers and w2 in ws.workers\n\tand w1 = Robot and w2 = Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall ws:Workstation | no disj w1, w2: Worker | (w1 & w2) in ws.workers and\n  \tw1 = Robot and w2 = Human\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall wo : Workstation | some r : Robot | r in wo.workers implies no (Human & wo.workers)\n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | w.workers in Human and w.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n\n  all ws : Workstation |  ws.workers in Human implies ws.workers in Robot \n  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall w : Workstation | some(Robot & w.workers) implies Human not in w.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall ws : Workstation | ws.workers in Human || ws.workers not in Robot\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w: Workstation | all h: Human | all r: Robot | h in w.workers implies r in w.workers \n\n}",
                    "{\n\t// Humans and robots cannot work together\n\tone ws : Workstation | (ws.workers = Human) or (ws.workers = Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n  \tall w : Worker | ((w.workers in Human) iff (w.workers not in Robot)) and ((w.workers in Robot) iff (w.workers not in Human))\n}",
                    "{\n\t// Humans and robots cannot work together\n\t(all ws:Workstation | all w:Worker | w in ws.workers and w in Human) \n\t\tor\n\t(all ws:Workstation | all w:Worker | w in ws.workers and w in Robot)\n  \t\n}",
                    "{\n\t// Humans and robots cannot work together\n\tno ws:Workstation | all w:Worker | w in ws.workers and (w in Human or w in Robot)\n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | some w : Worker, r : Robot | wo in workers.w\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n\tall wo : Workstation | some w : Worker, r : Robot | wo in workers.w implies r not in workers.w\n  \n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | w.workers = Human - Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Worker, wo : Workstation | w in Human and w in wo.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w : Workstation | no w.workers & Human + Robot\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  all w: Worker, wst: Workstation | Human in wst.workers implies Robot not in wst.workers\n\n}",
                    "{\n\t// Humans and robots cannot work together\n  \n  all h: Human, r: Robot, wst: Workstation | h in wst.workers iff r not in wst.workers\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n\tall x:Workstation | some y: Worker | some x.workers implies (x in Robot or x in Human)\t\n}",
                    "{\n\t// Humans and robots cannot work together\n\t\n\tall x:Workstation | some y: Worker | some x.workers implies (y in Robot or y in Human)\t\n}"
                ]
            },
            {
                "description": "Components cannot be their own parts",
                "pred": "this/inv6",
                "oracle": "{\n\t// Components cannot be their own parts\n\tall c: Component | c not in c.^parts\n}",
                "erroneous": [
                    "{\n  // Components cannot be their own parts\n  all c: Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n    all c:Component | c not in c.*(parts)\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts=c.parts-Component\n  \n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | c not in c.parts and c not in c.parts.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n  \tone c:Component | c not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | no c.parts\n  \n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Product | c not in c.parts\n  \n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | c.parts != c\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall x,y,z: Component| (y in x.parts and z in y.parts ) implies x not in (z.parts) \n\n}",
                    "{\n\t// Components cannot be their own parts\n  \n\t\n Component not in Component.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts not in c\n}",
                    "{\n\t// Components cannot be their own parts\n\tsome c:Component | c not in parts.c\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | c not in c.parts\n  \tall a,b : Component | a in b.parts implies b not in a.parts\n  \n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts not in Component\n}",
                    "{\n\t// Components cannot be their own parts\n  \tno c: Component | no p: Product | p in c.parts and p = c\n\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some c.parts\n\tall c:Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | c not in Product.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | no p.*parts\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | all p: c.parts | c not in p iff p not in parts.c\n\t\n  \n \n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component, d: Dangerous | c not in Component and d not in Dangerous\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.parts & p) implies p in Component \n}",
                    "{\n\t// Components cannot be their own parts\nno disj c, p: Component | c in p.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Product | not c->c in parts\n\tall c1,c2 : Product | (c1!=c2 and c1->c2 in parts) implies not c2->c1 in parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c: Component | \n  \t\tsome c2: Component |  c not in c2.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tComponent.parts not in Component\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c : Component | Component not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some c.parts\n\tone c:Component | c not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \n\tone c:Component | c not in c.parts\n  no Component.parts\n \n}",
                    "{\n\t// Components cannot be their own parts\n  \n\tall c1, c2:Component | c1=c2 iff c1 not in c2.parts\n  \n \n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some p: c.parts | c not in p iff p not in parts.c\n\t\n  \n \n}",
                    "{\n\t// Components cannot be their own parts\n  all c:Component | some p: c.parts | c not in p and p not in parts.c\n\t\n  \n \n}",
                    "{\n\t// Components cannot be their own parts\n     all c : Component | one c & Component.parts \n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c not in c.parts\n  \tall c1 : Component | all c2 : Component | c1 in c2.parts implies c2 in c1.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \tall c1 : Component | all c2 : Component | c1 in c2.parts implies c2 in c1.parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tComponent.parts != Component\n}",
                    "{\n\t// Components cannot be their own parts\n\tone c: Component | c not in c.^(parts)\n}",
                    "{\n\t// Components cannot be their own parts\n  \tComponent not in Component.^parts\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p:Product | p.parts != p\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.parts & p) implies (p in Component or p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.parts & p) implies (p in Component and p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.^parts & p) implies (p in Component and p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p : Product | (no p.^parts & p) implies (p in Component or p in Dangerous)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | c.parts = c.^parts-c \n}",
                    "{\n\t// Components cannot be their own parts\n  \tlone c: Component | c not in c.parts\n\n}",
                    "{\n\t// Components cannot be their own parts\nall c1,c2 : Component | (c1!=c2 and c1->c2 in parts) implies not c2->c1 in parts\n\n}",
                    "{\n\t// Components cannot be their own parts\n\t(Component <: parts) not in iden\n}",
                    "{\n\t// Components cannot be their own parts\n\t(Component <: parts :> Component) not in iden\n}",
                    "{\n\t// Components cannot be their own parts\n\tno *(Component <: parts :> Component) & iden\n}",
                    "{\n\t// Components cannot be their own parts\n\tno (Component->Component & ^parts)\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | no (p & p.parts) iff p in Component\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product |\n  \t\tsome c: Component | p=c implies p not in c.parts\n}",
                    "{\n\t// Components cannot be their own parts\n  \n  all p : Product, c : Component  | p->c not in parts implies p = c\n\n}",
                    "{\n\t// Components cannot be their own parts\n\tall c : Component | some p : Product | p.parts not in c\n  }",
                    "{\n\t// Components cannot be their own parts\n  \tall c: (Component + Dangerous) | c.parts & c = none\n}",
                    "{\n\t// Components cannot be their own parts\n\tall p: Product | p in p.parts\n}"
                ]
            },
            {
                "description": "Components built of dangerous parts are also dangerous",
                "pred": "this/inv7",
                "oracle": "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | some (c.parts & Dangerous) implies c in Dangerous\n}",
                "erroneous": [
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (o.parts in Dangerous) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (o.^parts in Dangerous) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component| some p:Product | (p in Dangerous and p in c.parts) implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.^parts) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts) implies (o in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | some p: c.parts | p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component | Dangerous in c.^parts implies Dangerous in c \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component | some e:c.^(parts)| e in Dangerous implies c in Dangerous }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component, p : Product | c in p.parts and p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | (c in Dangerous) implies (c.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | Dangerous in c.parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c.parts in Dangerous \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts) implies o = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | (c in Dangerous) implies (c.^parts in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous implies some p: parts.c| p in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component, d: Dangerous | d in c.^parts => c = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous iff some p: c.parts | p in Dangerous\n  \t\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (c in Dangerous) implies (c.~parts in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c, c1 : Component | (c1 in c.parts and c1 in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous implies some p: c.parts| p in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\tDangerous = {p: Product | some p.parts & Dangerous}\n\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all d : Dangerous | d.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some p : c.parts| p in Dangerous.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c implies Dangerous in ^parts.c\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some Dangerous & ^parts.c implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies all p : ^parts.c |\n  Dangerous in p\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c.^parts => c = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | (some x: c.parts | x in Dangerous) implies (Dangerous in c)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | some pp:p.parts | pp in Dangerous implies p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component |\n  \t\tone p:c.parts|\n  \t\t\tp in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | (c in Dangerous) and (c.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\n  \tall c:Component | all p: c.parts| p in Dangerous iff c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component | c.*parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component |\n  \tone p:c.^parts |\n  \t\tp in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (some c: Component | c.parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\n  \tDangerous in Component implies Dangerous.^parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one d : Dangerous | d in c.parts => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Product | (c.^parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | c in Dangerous implies c.parts in (Dangerous + Material)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component |  (parts.c in Dangerous) implies c in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component, p : Product | (c.parts in Dangerous) iff (p in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | c in Dangerous iff c.^parts in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  some c : Component.parts | all c1 : Component | c1 in c and c in Dangerous implies c1 in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | Dangerous in c implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | some d: Dangerous | d.parts in c.parts implies d in c \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tDangerous.^parts = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c: Component | c in Dangerous iff some p: parts.c | p in Dangerous\n  \t\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\n  \tall c:Component | some p: parts.c| p in Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall o: Component | (Dangerous in o.parts)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \t\n  \tall c:Component | some p: c.parts| p in Dangerous iff c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t\n\tall c:Component | some (c.^(parts) & Dangerous) }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t\n\tall c:Component | some (c.parts & Dangerous) }",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some d : Dangerous | d in c.^parts <=> c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | (c in Dangerous) implies (Dangerous in c.^(parts))\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    \n  all c: Component | some p: c.parts | p in Dangerous implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component & Dangerous | Dangerous in c.parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    all c : Component | Dangerous in c.~parts implies Dangerous in c\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one d : Dangerous | d in c.^parts => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | c in Dangerous iff Dangerous in c.^parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | c in Dangerous iff some Dangerous & c.^parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | all p: c.parts | p in Dangerous and c in Dangerous \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | all p: c.parts | (p in Dangerous and c in Dangerous) or (c in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some c1 : Component | (c1 in c.^parts and c1 in Component) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c, c1 : Component | (c1 in c.^parts and c1 in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some p : c.parts&Dangerous | c in Dangerous\n  \n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | Dangerous in c.parts implies c in Dangerous\n\t\n  all c : Component | lone p : Product | p in c.parts and p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n\t\n  all c : Component | lone p : Product | p in c.parts and p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome d: Dangerous | some c: Component| d in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n    ((Component - Dangerous) -> Dangerous) not in parts\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | not (c.^parts in Dangerous) implies c  in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (some c: Component | c.^parts in Dangerous) implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tno c: Component | some c.parts & Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | (p in Dangerous) <=> some p2: Product | p2 != p and p2 in p.parts and p2 in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tDangerous & Component.^parts = Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\t\tall c:Component | ^parts.c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall p: Product | Dangerous in p.^parts => p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | p in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | p.parts in Dangerous implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c:Component | c in Dangerous implies parts.Product in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | no c.*parts & Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  all c : Component | no c.^parts & Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.parts implies c in d\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.parts implies c = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c:Component, d:Dangerous| d.parts in c.^parts implies c = Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | Dangerous in c.parts implies c.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | one d: Dangerous| d in c.parts implies c.parts in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | c.parts in Dangerous.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | all p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | one p : Dangerous.parts | p in c.parts implies c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some p : Dangerous.parts | p in c.parts iff c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some ( c.^(parts.parts) & Dangerous ) implies c in Dangerous\n\t\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies (Dangerous in parts.c)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | (Dangerous in c) implies ^parts.c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c : Component | c in Dangerous iff c.parts in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component | Dangerous in c.parts implies Dangerous in Component\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome c: Component | c.parts in Dangerous => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tsome c: Component | some (c.parts & Dangerous) => c in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some d : Dangerous | d in c.parts implies c in d.parts\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component | some d : Dangerous | Dangerous = c.parts implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall p : Product | p in Dangerous \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \tall c : Component, p : Product | (c.parts in Dangerous) iff (p.parts in Dangerous)\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  all c: Component|one c.parts & Dangerous implies c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c: Component | some d: Dangerous | d in c.parts =>\n  \t\tall p: c.parts | p in Dangerous\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  some c : Component.parts | all c1 : Component | c1 in c \n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n  \n  some c : Component | c in Dangerous\n\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component, p : Product | c in p.parts implies (c in Dangerous and p in Dangerous)\n}",
                    "{\n\t// Components built of dangerous parts are also dangerous\n\tall c : Component | some (c.parts & Dangerous) implies no (c.parts & (Product - Dangerous))\n}"
                ]
            },
            {
                "description": "Dangerous components cannot be assembled by humans",
                "pred": "this/inv8",
                "oracle": "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: (Component & Dangerous) | no c.workstation.workers & Human\n}",
                "erroneous": [
                    "{\n\t// Dangerous components cannot be assembled by humans\n    \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Human not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d:Dangerous| d.workstation.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component | (c in Dangerous) implies (c.workstation.workers in Human)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Robot in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t\n  all c:Component| c.workers in Human implies c in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation |\n  \t\tws.workers in Human => c not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation | c in Dangerous implies no (w.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component | some c.parts & Dangerous => no c.workstation.workers & Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all h : Human, p : Product | p in Dangerous implies no workers.h\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component| all w: Worker| c in Dangerous iff w in Human\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Robot in o.workstation.workers)\n  \tall o: Component | (o in Dangerous) implies (Human not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall x: Workstation | workstation.x in (Component & Dangerous) implies x.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n    workers.Human & Dangerous.parts.workstation = none\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | no c.workstation.workers & Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | (c in Dangerous) implies all w: Worker | w in Worker - Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d:Dangerous| Human not in d.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous implies no (c.workstation.workers)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all r: Robot | all w: Workstation |( c in Dangerous and w in c.workstation )implies r in w.workers\n}",
                    "{ \n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all wo: Workstation |all p: Product | all w: Worker| p in Dangerous and p in c.parts and wo in c.workstation and w in wo.workers implies w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall o: Component | (o in Dangerous) implies (Human not in o.workstation)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | Human not in work.workers implies c in Dangerous \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | c in Dangerous iff Human not in work.workers and Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n        all w : Workstation, c : (Component & Dangerous) | w.workers in Robot\n\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tHuman not in (parts.Dangerous).workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t(parts.Dangerous).workers not in Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \t((Dangerous.workstation).workers) not in Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component| all w: Worker| w in Human implies c in Dangerous\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | some wo: Workstation | (c in Dangerous implies wo.workers not in Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tHuman not in Dangerous.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall d: Dangerous | d in Component and d.workstation.workers in Robot\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation, r : Robot | c in Dangerous implies w.workers in r\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p: Product, ws: Workstation | some h: Human |\n  \t\th in ws.workers => p not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p: Product, ws: Workstation | some h: Human |\n  \t\t(h in ws.workers) and (ws in p.workstation) => (p not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d : Dangerous | no Human \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | all ws : c.workstation | ws.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | c in Dangerous => (c.workstation.workers & Human) = 0\n}",
                    "{\n  // Dangerous components cannot be assembled by humans\n  all w: Workstation | Dangerous in workstation.w.parts implies no w.workers & Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component| all w: Worker| c in Dangerous implies w in Human\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t\n  \t\n\tall o: Component, h: Human | some r: Robot | (o in Dangerous) implies (h not in o.workstation.workers)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | c in Dangerous iff Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | some work: c.workstation | Human not in work.workers implies c in Dangerous \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  some c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | c in Dangerous implies Human not in work.workers and Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | all work: c.workstation | c in Dangerous iff Robot in work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | some work: c.workstation | c in Dangerous iff (Human not in work.workers and Robot in work.workers)\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \n  \n  all c:Component | some work: c.workstation | c in Dangerous iff no Human & work.workers\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:Workstation | Dangerous in c.^parts implies w.workers not in Human \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:Workstation | Dangerous in c.^parts implies Human not in w.workers \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c:Component, w:c.workstation | Dangerous in c.^parts implies Human not in w.workers \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | (c in Dangerous) implies all w: Worker | w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  no d:Dangerous | no (Human & (d.^parts & Component).workstation.workers)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in\t(workers.Human))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in (Workstation - workers.Human))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|\n  \tc in Dangerous and c.workstation not in (Workstation - workers.Robot))\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t(all c: Component|all ws: Workstation|\n  \tc in Dangerous and c.workstation in ws and no ws.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c:Component | (c in Dangerous) implies (c.workstation in Robot)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | ws.workers in Robot implies p in Dangerous\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | p in Dangerous implies ws.workers in Robot  \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall p : Product, ws : Workstation | p in Dangerous and ws.workers in Robot  \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n    all c:Dangerous | some (c.workstation.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous iff no Human & c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous iff c.workstation.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | (c.^parts in Dangerous) implies Robot in c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | (c.^parts in Dangerous) implies c.workstation.workers in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component | no h : Human | c in Dangerous => h in c.workstation.workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, ws : Workstation | (c.parts & Dangerous) not in (ws.workers & Human)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall  d: Dangerous | some w : Workstation| w = d.workstation and w.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c: Dangerous | no w: Worker | w in Human and c.workstation in w\n\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d: Dangerous | Human not in Dangerous.parts\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t\n  \tall c: Component, h: Human | c in Dangerous => Human not in c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation, h: Human|\n  \t\t(h in ws.workers) implies (some c: Component |c->ws in workstation implies c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\t\n  \tno h : Human | h not in (Dangerous.workstation).workers \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d:Dangerous, ws:Workstation |  Human not in ws.workers implies ws in d.workstation\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall d:Dangerous, ws:Workstation | ws in d.workstation and Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c: Component | c in Dangerous implies c.workstation.workers != Human\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | Dangerous in c implies\n  no Human & c.workstation.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation, r : Robot | c = Dangerous implies w.workers in r\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, w : Workstation.workers | c in Dangerous implies Robot in w.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation | some h: Human |\n  \t\th in ws.workers => c not in Dangerous\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component, ws: Workstation | some h: Human |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation | some h: Human, c: Component |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws: Workstation, h: Human | some c: Component |\n  \t\t(h in ws.workers and ws in c.workstation) => (c not in Dangerous)\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all p: Product | all w: Worker| p in Dangerous and p in c.parts implies w in Robot\n}",
                    "{ \n\t// Dangerous components cannot be assembled by humans\n\tall c: Component | all wo: Workstation |some p: Product | all w: Worker| p in Dangerous and p in c.parts and wo in c.workstation and w in wo.workers implies w in Robot\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : (Component & Dangerous) | ws in d.workstation implies Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : Dangerous | ws in d.workstation implies Human not in ws.workers\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall ws : Workstation | some d : Dangerous | ws in d.workstation implies ws.workers not in Human\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation.workers in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  \tall c : Component, h : Human | (c.workstation.workers not in Human) iff (c in Dangerous)\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, p: Product, h: Human, ws: Workstation | p in Dangerous implies (not h in ws.workers) \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, p: Product, h: Human, ws: Workstation | c->p in parts and p in Dangerous implies (not h in ws.workers) \n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component, h : Human, wo : Workstation | c in workstation.wo\n  \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | Dangerous in c implies Human not in c.workstation\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c : Component | Dangerous in c implies Human not in c.workstation.workers\n\n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n  all c: Component, wst: Workstation | c in Dangerous implies wst.workers not in c.workstation \n}",
                    "{\n\t// Dangerous components cannot be assembled by humans\n\tall c : Component | c in Dangerous => c.workstation.workers = Human\n}"
                ]
            },
            {
                "description": "The workstations form a single line between begin and end",
                "pred": "this/inv9",
                "oracle": "{\n\t// The workstations form a single line between begin and end\n  \n  \tall w : Workstation | w in begin.*succ\n  \n  \tall w : Workstation - end | one w.succ\n  \n  \tno end.succ\n\t\n}",
                "erroneous": [
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \t(Workstation-begin) in begin.*succ\n  \tall w:Workstation | w not in w.*succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.^succ\n  \tall w: Workstation | no w.succ implies w in begin\n  \tall w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all ws : Workstation | ws in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | (ws in begin.^succ or ws = begin) and (end in ws.^succ or ws = end) and ws not in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: (Workstation+begin+end) | w in begin.*succ and w not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w1 : Workstation, w3 : Workstation | all w2 :  Workstation - w1 - w3 |  w2 & w3 in w1.^succ && w2 & w1 in w3.^succ && #(w2.succ) = 1\n  \t \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one begin.^succ & w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tbegin.^succ = Workstation - begin\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.*succ and end in ws.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n    no end.succ\n    Workstation = begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \t\n  \tall w: Workstation - end | one s: Workstation | s in w.succ\n  \t\n  \tall e: end | all w: Workstation | w not in e.succ\n  \t\n  \tall b: begin | all w: Workstation | b not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in end) implies one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  Workstation in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | one begin.succ & w and one w.^succ & end and (w not in w.^succ or w in end)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation = begin.*succ\n  \tWorkstation = end.*(~succ)\n  \t\n  \tall ws:Workstation - end - begin | one ws.succ and one ws.~succ\n  \n  \tall ws:Workstation | ws not in ws.^succ\n  \n  \tone end.~succ\n  \tno end.succ\n  \n  \tone begin.succ\n  \tno begin.~succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = end or some w.succ) and (w != end implies one w.succ) and (w != begin implies one w.~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws not in ws.^succ\n  \tall ws1, ws2 : Workstation | ws1 != ws2 implies ws1 in ws2.^succ or ws2 in ws1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ\n  \tno end.succ\n  \tall s: Workstation - end | one s.succ\n  \tall s: Workstation - begin | one s.~succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | (e in ws.*succ or e=ws) and (ws in b.*succ or b=ws) and ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | e in ws.^succ and ws in b.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.~succ and one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno succ.begin\n  \tno end.succ\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ)   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | w not in end implies one w.succ\n  no end.succ\n  all w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w in begin.*succ\n  \n      \n      all w : Workstation - end | one w.succ\n  \n      \n      \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\t(all ws: Workstation| ws not in ws.^succ) and\n\tend in begin.^succ\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | some sub:Workstation| sub in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend not in ^succ.Workstation\n  \tall s: Workstation | s not in s.^succ\n  \tall w: Workstation - begin - end |\n  some w.^succ and some ^succ.w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation - end | one w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end | one(W.succ) and W.succ != W \n  \t\n  \tall W : Workstation - begin| one (succ.W) and succ.W != W\n\t\n  \tend.succ   = none\n  \tsucc.begin = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \t\n  \tall ws : Workstation | ws not in ws.succ\n  \tall ws:Workstation -end | one ws.succ\n  \tall b : begin, ws : Workstation | b not in ws.succ\n  \tall e : end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \tall w : begin | some w2 : Workstation | w!=w2 implies some w.succ and no succ.w\n  \tall w : end | some w2 : Workstation | w!=w2 implies some succ.w and no w.succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | (w in end or w in begin)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | e in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  not (begin.succ = end) and begin.^(succ) = end  or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsucc in (Workstation one -> one Workstation) and end in begin.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: begin | one w2: Workstation | w2 in ws.succ\n  \n  \tall ws: end | no w2: Workstation | w2 in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ & iden\n  \tall w : Workstation-end | one w.succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | some (begin & end) implies some w.succ\n  all w: Workstation| one (begin & end) implies no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation|ws in begin+end or ws in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | end in w implies begin in succ.w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ) and end in (ws.*succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation| one(W.succ) and W.succ != W\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x :Workstation - end | one x.succ\n  \tall x : end | no x.succ\n  \tall x :begin | no succ.x\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    \n    all w : Workstation | lone w.succ and w not in w.^succ\n    Workstation.succ = Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | some su:ws.succ | ws = begin implies su = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no begin & end\n\t&& all w: (Workstation - end) | one w.succ\n  && all w: (Workstation - begin) | one succ.w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and end in w + w.^succ\n  \tno begin.~succ\n  \tno end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws not in ws.^succ\n  \tall ws : Workstation | begin = ws or (begin in succ.ws)\n  \tall ws : Workstation | end = ws or (end in ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \tall w : begin | some w2 : Workstation | w!=w2 implies (some w.succ and no succ.w)\n  \tall w : end | some w2 : Workstation | w!=w2 implies (some succ.w and no w.succ)\n  \tsome begin <: ^succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | (ws not in end implies #ws.succ=1) and ws not in ws.succ\n  \tone ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    all wo : Workstation | wo.succ not = none => wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all s: Workstation | lone s.succ\n    all s: Workstation | s in begin.*succ\n    \n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tall w:Workstation | w in begin implies (lone w.succ and no succ.w)\n\tall w:Workstation | w in end implies (no w.succ and lone succ.w)\n\tall w:Workstation | w not in (begin + end) implies (one w.succ and one succ.w and w not in w.succ and w not in succ.w)\n\tsome b: Workstation | b in begin implies b.^succ in end\n  \n  \n  \n  \n  \n \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | (w in end or w in begin or w in w1.succ) and w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: (Workstation+begin+end) | no begin.^succ & w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all ws:Workstation | one b:begin | one e :end | ws in b.succ and e in ws.succ \n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws.succ != ws\n  \tend in begin.*succ \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin + begin.^succ = Workstation and end.succ = none\n  no ws : Workstation | ws.succ = ws\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \t\n  \tsucc in (Workstation - end) one -> one (Workstation - begin)\n        and \n    ^succ in begin one -> one end \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tall e: end, b: begin | ((e = b) and (#Workstation =< 1)) or (e in b.^succ)\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.succ and one w.~succ\n    no begin.~succ and no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - end | one w.succ\n    all w: Workstation - begin | one w.~succ\n  \tWorkstation = begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ and all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | (e = b) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | begin in ws.^succ and end in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno begin & Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | wStart not in w.^succ\n  \tall wStart: (Workstation & begin)-end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w not in w.succ\n  \n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n    \n    all w : Workstation | w -> w not in succ\n\n    \n    one w1 : Workstation | begin -> w1 in succ\n\n    \n    one w2 : Workstation | w2 -> end in succ\n\n    \n    all w : Workstation - begin - end |\n        (one w1 : Workstation | w -> w1 in succ) and\n        (one w2 : Workstation | w2 -> w in succ)\n\n    \n    all w : Workstation | w in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | e in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wk : Workstation | one wk.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  begin.*succ = Workstation\n  no ws : Workstation | ws->ws in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tWorkstation in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tall w : Workstation | w not in w.succ\n  \n\tall w : Workstation - begin | one succ.w\n  \n\tall w : Workstation - end | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tall e: end, b: begin | ((e = b) and (#Workstation =< 1)) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tall e: end, b: begin | (e = b implies no e.succ) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation-end | one w.succ \n\tbegin != end implies begin.^succ = Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and no(begin & end) and (not(w in w.succ) and not(w in succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | (one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and (not(w in w.succ) and not(w in succ.w))) or (one(Workstation) and no(w.succ) and no(succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    (Workstation = begin and no(begin.succ)) or \n  \t(all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | ((w in end) and (w not in w.succ) and (end in begin.succ)) or ((w in begin) and (w not in w.succ)) or (w in w1.succ) or ((w in begin) and (w in end) and (end in begin.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | ((w in end) and (w not in w.succ) and (end in begin.succ)) or ((w in begin) and (w not in w.succ)) or (w in w1.succ) or ((w in begin) and (w in end) and (w not in w.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one Workstation => no succ else one begin.succ and one succ.end and (all w: Workstation - begin - end | one w.succ and one succ.w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation | (one begin&w) implies (no end&w)\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t{begin = end iff one Workstation} and begin != end implies all w : Workstation - {begin + end} | w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | lone w.succ\n\tno end.succ\n  \n  \tbegin not in Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation - end | lone w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno s: Workstation | s -> s in workstation\n  \tall s: Workstation - begin - end {\n      \tone s.~workstation.parts.workstation\n  \t}\n\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - end |\n        lone w.~succ and (w in begin.~succ or one w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - end | ws in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tlet line = Workstation - begin - end {\n        all ws: line | one ws.succ and ws.succ in line\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n  \tall w : Workstation - begin | one s : Workstation | w in s.succ\n  \tbegin = end => no s : Workstation | s in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or begin = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end in begin.^(succ) or begin = end) and all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation\n  (end = begin.^(succ) or begin = end) and begin.succ != begin \n  and all ws : Workstation | ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t// \n\tall w : Workstation | w in begin + begin.^succ and end in w + w.^succ and one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone b : begin | all wt : Workstation |\n  \t\t\tb=wt or wt in b.^succ\n\t\n  \tone e : end| all wt : Workstation |\n  \t\t\te=wt or e in wt.^succ\n  \t\n  \tall wt : Workstation |\n\t\t\twt not in wt.succ and lone wt.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - end | one w.succ\n    all w: Workstation - begin | one w.~succ\n  \tWorkstation = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | e in b.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ and all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wk : Workstation | one wk.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and wStart not in end implies wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | one ws.succ iff ws in begin-end\n  \tall ws: Workstation | no (ws & ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one begin.succ and one succ.end and all w: Workstation - begin - end | one w.succ and one succ.w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ or (lone Workstation)\n  \t\n}",
                    "{\n all ws: Workstation | lone ws1 : Workstation | ws not in ws.^succ and ws1 !=ws and ws1 in ws.succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1 : Workstation | one  w2 : Workstation , w3 : Workstation | w1 in w2.succ && w3 in w1.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone wt : Workstation | all wts : Workstation | wt not in wts.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome wo: Workstation | begin in wo and end in wo.*succ and no succ.wo\n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome w : Workstation | begin in w implies end in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin and w not in end) implies some w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  #w.succ = 1 and (w != begin implies w in begin.*succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall ws: Workstation - begin | ws in begin.*succ \n     \n    no end.succ \n    no ws: Workstation | ws in ws.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \n\t\n  all w : Workstation | end in w.^succ and (w = begin or w in begin.^succ)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin & end != none implies #(begin.succ) = 0\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.*succ\n  \tiden not in succ\n  \tall wo : Workstation | wo.succ not = none => begin not = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc - iden = succ\n  \tWorkstation in begin.*succ\n  \tbegin.succ not = none => end in begin.^succ\n  \tiden not in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tWorkstation in (begin.*succ & *succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome wo: Workstation | begin in wo and end in wo.*succ\n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation - begin = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  no w: Workstation - begin | one w.~succ\n  \n  \n  no w: Workstation - end | one w.succ\n\n  \n  all w: Workstation - end | lone w.succ\n\n  \n  all w: Workstation - begin | lone w.~succ\n  \n  all w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    succ in Workstation -> lone Workstation\n    one w : Workstation | no w.succ\n    all w : Workstation | not w in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one begin.succ\n  all w: Workstation | w not in end implies one w.succ\n  no end.succ\n  all w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | no (begin & end) implies lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | lone w.succ implies no (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | one w.succ implies one begin\n  all w: Workstation| one (begin & end) implies no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tone e: end, b: begin | e = b\n  \tone e: end, b: begin | (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tall e: end, b: begin | (e = b and no e.succ) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tbegin != end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tall w: begin.^succ | w not in w.^succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)) or (one c1:Workstation | (c1 in begin) and (c1 in end))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,e : Workstation | e in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n  \tall e : end | no e.succ\n    all w : Workstation | w not in end implies one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W &begin)\n  \tand (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    Workstation = begin or (all ws : Workstation | ws in (begin <: begin.*succ :> end + begin + end) and ws not in ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (one w:Workstation | w in end) and (one w:Workstation | w in begin) and (all w:Workstation | some succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | w1 in w.succ or w1 in begin or w1 in end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation |some w1: Workstation |(w in end or w in begin or w in w1.succ) and (w not in w.succ) and end in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ )\n\t(all w:Workstation | w not in end implies one w.succ)\n\t(all w:Workstation,b:begin | w in b.*(succ))\n\t\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation |some w1: Workstation |(w in end or w in begin or w in w1.succ) and (w not in w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | begin != end and (x != begin and x != end implies \n  \t\t\t\t\t\t\tx in begin.^succ and end in x.^succ)\n \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x != begin and x != end implies \n  \t\t\t\t\t\t\tx in begin.^succ and end in x.^succ\n \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tall w: Workstation | w not in w.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | (w in begin or w in end or (w in begin.^succ and w in ^succ.end)) and w not in w.^succ and lone w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    (all w : Workstation - begin - end | w in begin.^succ and w in ^succ.end and some w.succ) and\n  \t(all b : begin - end   | no succ.b and some b.succ) and\n  \t(all e : end   - begin | no e.succ and some succ.e) and\n\t(all r : begin & end   | no succ.r and no r.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) or (ws in begin and one ws.succ and ws not in ws.succ and end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation |some w2: Workstation | w2 not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  one w : Workstation | begin in w\n  one w : Workstation | end in w and no w.succ\n  all w : Workstation | (one begin&w) iff no end&w\n  all w : Workstation-begin-end | one succ.w and one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | one su:ws.succ | ws in begin implies su in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ) and some(succ.ws) and end in (ws.*succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w : Workstation | w in begin implies some(w.succ)\n  all w : Workstation | (w not in end) and ( w not in begin) implies one(w.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno (end.succ)\n    no ( succ.begin )\n  \t\n  \t\n  \n  \t\n  \n  \tall w : Workstation| w not in w.^(succ)\n  \n  \tall w: Workstation| lone(w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall c:Component | all parts: c.parts | c.workstation in parts.workstation.succ and c.workstation not in parts.^workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation|ws in begin+end or ws in begin.^succ and ws not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end iff one Workstation\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w: Workstation - end.succ | w in w.succ\n    all w: Workstation - begin.succ | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | w not in w.^succ\n  \tbegin = end iff one Workstation\n\tbegin != end implies all w : Workstation - {begin + end} | w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wt : Workstation | one wts : Workstation | wt not in wts.^succ and wt!=wts\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (all w : Workstation | w not in w.succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t all w : Workstation | one ww : Workstation| ww in w.^succ - w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2: Workstation | w1 in w2.^succ or w2 in w1.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies {\n      \tone Workstation\n      \tno end.succ\n  \t}\n      \n  \tbegin != end implies {\n      \tone begin.succ\n      \tno end.succ\n      \t\n      \tall w : Workstation-end-begin | one w.succ  \n      \tWorkstation.succ = Workstation - begin\n    }\n  \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin.succ = end) and all ws: Workstation - end |\n        one ws.succ and ws.succ in Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ and (begin in w implies end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tsome w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  some w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w)  \n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - end |\n        (w in begin.~succ or one w.succ)\n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | one w.succ and one w.~succ\n    no begin.succ and no end.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all disj ws1, ws2 : Workstation | ws1.succ != ws2.succ\n  all ws : Workstation | ws.succ != ws\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin.succ = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin = end\n  all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end in begin.^(succ) or begin = end) and begin.succ != begin and all ws : Workstation | ws in begin.^(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation\n  all ws : Workstation | ws.succ != ws\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end = begin.^(succ) or begin = end) and begin.succ != begin \n  and all ws : Workstation | ws in (begin + begin.^(succ))\n}",
                    "{\n\tall w : Workstation | not w->w in succ\n\n\tall w:Workstation | w in begin implies (some w2:Workstation | w->w2 in succ)   \n\tall w1,w2,w3:Workstation | (w1 in begin and w1->w2 in succ and w1->w3 in succ) implies (w2=w3) \n\n\tall w:Workstation | w in end implies (some w2:Workstation | w2->w in succ)  \n\tall w1,w2,w3:Workstation | (w1 in end and w2->w1 in succ and w3->w1 in succ) implies (w2=w3) \n\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall b : begin, w : Workstation | not b->w in succ  \n\tall e : end, w : Workstation | not w->e in succ \n\n\tall b : begin, w : Workstation | w!=b implies w in ^succ.b \n\tall e : end, w : Workstation | w!=e implies e in ^succ.w \n\n\tall w : Workstation | not w in ^succ.w  \n\n\tall x,y,z: Workstation  | (x->y in succ and x->z in succ) implies y=z \n\tall x,y,z: Workstation  | (y->x in succ and z->x in succ) implies y=z \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no begin.succ \n    no end.workers \n\n    \n    all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno succ.begin\n  \n\tno end.succ\n  \n  \tall w : Workstation | w not in w.succ\n  \t\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \n  \tend in begin.*succ\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | end in w.^succ or begin in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end implies end in wstation.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no begin & end and\n  one begin and one end and\n    (all w: Workstation - begin - end | one w.succ) and\n    (all w: Workstation - begin - end | one w.~succ) and\n    no w: Workstation | w in w.^succ and\n    begin.^succ = Workstation - begin - end and\n    end.~^succ = Workstation - begin - end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\tall ws: Workstation | ws in begin.*(succ) or ws in end.~(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \n  \n    no begin.~succ\n    \n    \n    no end.succ\n    \n    \n    no w: Workstation | w in w.^succ\n    \n    \n    Workstation = begin.*succ + end.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w:Workstation | no succ.begin\n  \tall e:end | no e.succ\n  \tone succ.end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end and some begin.succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,wb : Workstation | (wb in begin and w!=wb) implies w in wb.^(succ)\n  all w : Workstation | w not in w.^(succ)\n  all w : Workstation | w not in end implies lone w.succ\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n  \tall w: Workstation | no w.succ implies w in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in succ.w\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in succ.w\n  \t\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (some w2: Workstation | w2->w in succ))\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w -> w not in succ\n  \n    all w : Workstation | (one w1:Workstation | begin->w1 in succ) and (one w2: Workstation | w2->end in succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \t^succ in begin -> end\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation = begin.*succ + end\n  \n  no end.succ\n  \n  all w: Workstation | lone w.succ and lone w.~succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno (begin & Workstation.succ)\n  \tall w : Workstation | one (w.succ & end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies ws1 not in ws1.succ and ws2 not in ws2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ\n  \tno end.^succ\n  \tall w : Workstation | w in begin + begin.^succ\n  \tall w : Workstation | w not in w.^succ\n  \tall disj w1, w2 : Workstation | no w1.succ & w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end ) or wk in begin and wk in end \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end )\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ and ( wk in begin implies wk not in end ) \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ and ( wk in begin implies wk not in end ) \n  all wk : Workstation | wk in begin implies some ( wk.^(succ.succ) & end )\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - begin | ws in begin.^succ\n\tall ws: Workstation - end | end in ws.^succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\t(all ws: Workstation| ws not in ws.^succ) and\n\t(end in begin.^succ or end in begin.succ or begin = end)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | no succ.begin and no end.succ and no (w & w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1, w2: Workstation | w1 in w2.^succ or w2 in w1.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n\tone w : Workstation | no w2 : Workstation | w in w2.succ\n  \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,e : Workstation | e in b.*succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | #w.succ = 1 implies w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (#w.succ + #w.~succ = 1 or #w.succ + #w.~succ = 2) and \t Workstation in w.*succ + w.~*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | (#w.succ = 1 and #w.~succ = 0) and Workstation in \t\tw.*succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no succ.begin\n  no end.succ\n  some Workstation.succ\n  all e: begin | end in e.*(succ)\n  \n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | some w.succ implies (w not in begin and w not in end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in begin and w not in end) implies one w.succ\n  all w: Workstation | w not in w.^(succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | ( w!= end implies #w.succ = 1) and (w != begin implies w in begin.*succ) and w.succ != w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| ws in begin.*succ and ws not in end.^succ or ws in begin&end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n  \tend.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end or\n\tall ws: Workstation | (#ws.succ = 1 iff ws not in end) and ws not in ws.^succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | \n  \t\tws not in ws.succ and\n  \t\t(ws not in end implies #ws.succ = 1) and\n  \t\tbegin not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | ws not in end implies (#ws.succ=1 and ws not in ws.succ)\n  \tone ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | (ws not in end implies #ws.succ=1) and ws not in ws.succ and\n  \t\t\t\t\t\t\t(ws not in begin implies ws in Workstation.succ)\n  \tone ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tbegin.^succ = Workstation - begin\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tone Workstation\n  \t\t=> no succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation-begin in begin.^succ\n    \n  \t\n  \tall wo : Workstation-begin-end | one wo.succ and wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.*succ = end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend = begin.^succ and begin != end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | ws.succ != ws) and end = begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w: Workstation {\n      no succ.w\n      all k: Workstation - w | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone first: Workstation, latest: Workstation {\n      no succ.first\n      no latest.succ\n      all k: Workstation - first - latest | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone first: Workstation, latest: Workstation {\n      no succ.first\n      no latest.succ\n      all k: Workstation - first | one k.succ\n    }   \n}",
                    "{\n\t// The workstations form a single line between begin and end\n    succ in Workstation -> lone Workstation\n    one w : Workstation | no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ and end != begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(succ in (Workstation lone -> lone Workstation)) and (end in begin.^succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2: Workstation | w1 not in w1.^succ and (w1 in w2.^succ or w2 in w1.^succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in (Workstation lone -> lone Workstation)\n\tand (all w: Workstation | w  in begin.*succ) \n\t\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  some ws : Workstation | ws.*succ = Workstation\n  no ws : Workstation | ws->ws in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\tbegin != end\n  begin.*succ = Workstation\n  no ws : Workstation | ws->ws in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n\tbegin = end iff one Workstation\n  begin.*succ = Workstation\n  no ws : Workstation | ws->ws in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj a, b: Workstation | a.succ = b implies a not in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  \tall ws: Workstation | ws not in end implies one ws.succ\n  \tall ws: Workstation | ws in begin implies ws.*succ = Workstation\n  \tall disj a, b: Workstation | a.succ = b implies a not in b.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | no (begin & end) implies one w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | lone w.succ implies one (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | lone w.succ iff no (begin & end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | one w.succ implies no (begin & end)\n  all w: Workstation| no w.succ implies one w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | one w.succ implies one (begin & end)\n  all w: Workstation| no w.succ implies one w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | one w.succ implies some (begin & end)\n  all w: Workstation| one (begin & end) implies no w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | some (begin & end) implies some w.succ\n  \n  \n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  all w: Workstation | some (begin & end) implies lone w.succ and w not in w.^succ\n  \n  \n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.succ\n  \tone e: end, b: begin | ((e = b) and (#Workstation > 1)) or (e in b.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tbegin != end\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | w not in w.^succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \t\n  \tall w: begin.^succ | w.succ not in w.succ.^succ\n  \tno end.succ\n  \tall w: Workstation | lone w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \t\n  \tall w: begin.^succ | w.succ not in w.succ.^succ\n  \tno end.succ\n  \tall w: Workstation - end | one w.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - end | one w.succ and w not in w.^succ\n  \tall w: Workstation - begin | one succ.w\n  \n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | one begin.succ & w and one w.^succ & end\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation-end | one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies begin in begin.^succ\n  \tall w : Workstation-end | one w.succ\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies begin in begin.^succ\n  \tbegin = end implies no begin.succ\n  \tall w : Workstation-end | one w.succ\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n  \tbegin != end implies (all w : Workstation-end | one w.succ) and (end in begin.^succ) and (all w : Workstation | w not in w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and not(w in w.^succ) and lone(succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and lone(succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ) and lone(succ.w) and not(w in w.succ) and not(w in succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation | one w.succ and begin.^succ = Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation-end | one w.succ \n\tbegin != end implies begin.^succ = Workstation - begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w) and w in begin implies not w in end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation | lone(w.succ + workstation.w) and lone(succ.w + workstation.w) and not(w in w.succ) and not(w in succ.w) and (w in begin implies not w in end)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin = end implies one Workstation and no begin.succ\n\tbegin != end implies all w : Workstation-end | one w.succ \n  \tbegin != end implies no end.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | one(begin) and one(end) and ((w in begin) implies lone(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies lone(succ.w)) and (not(w in w.succ) and not(w in succ.w))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | (one(begin) and one(end) and ((w in begin) implies one(w.succ)) and (not(w in begin + end) implies (one(w.succ) and one(succ.w))) and  ((w in end) implies one(succ.w)) and (not(w in w.succ) and not(w in succ.w))) or one(Workstation)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (one disj c1, c2:Workstation | (c1 in begin) and (c2 in end) and (c1.^succ = Workstation - c1) and no(c2.succ)) or (one c1:Workstation | (c1 in begin) and (c1 in end) and no(c1.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ and b not in m.^succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and b not in e.^succ implies e in m.^succ and b not in m.^succ\n  \tall w : Workstation | w not in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all b : begin, e : end | b not in e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall b,m,e : Workstation | m in b.^succ and e in m.^succ implies e in b.^succ\n  \tall w : Workstation | w not in w.succ\n    all w : Workstation | w in begin implies w not in end\n    all b : begin, e : end | b not in e.succ\n  \tall e : end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall W : Workstation | some (W.succ) implies one (W.succ) and no (W.succ & W)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall W : Workstation | some (W.succ) implies one (W.succ) and no (W.succ & W &begin)\n  \tand (one begin.succ) and (no end.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W)\n  \tand (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\nall W : Workstation - (begin & end)| one (W.succ) and no (W.succ & W) and no (W.succ & begin) and (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\nall W : Workstation - (begin & end)| no(W.succ & W) and no(W.succ & begin) and (no end.succ)\n\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand no(end.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand end != begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W\n\tand end != begin and no(end.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n    all W : Workstation - end| one(W.succ) and W.succ != W and no(end.succ) and\n   no(begin & W.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \n\t\n  all w : Workstation | ((one w.succ => end in w.^succ) or w = end) and (w = begin or w in begin.^succ)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin = end or one (begin.^succ :> end)) and begin not in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(begin = end or no(Workstation - begin.^succ :> end)) and begin not in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation =  (begin <: begin.*succ :> end + begin + end) and Workstation.^succ != Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation =  (begin <: begin.*succ :> end + begin + end) and Workstation.^succ != Workstation and no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation.succ = Workstation - begin\n  \tsucc.Workstation = Workstation - end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \t\n  \t\n  \tall w:Workstation | (w not in begin and w not in end) implies w in succ.w  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w,w1 : Workstation | (w in end or w in begin) and (w not in w.succ) and (end in begin.succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | no b.succ and b in end) or (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ ) or (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ ) and (all w:Workstation | w not in end implies one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t(all b:begin | b in end implies no b.succ )\n\t(all w:Workstation | w not in end iff one w.succ)\n\t(all w:Workstation,b:begin | w in b.*(succ))\n\t\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w in end) or (w in begin) or \n(w in Workstation.succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x: Workstation | x != end implies end in x.^succ\n  \tno succ.begin \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tend in Workstation.succ\n  \tall w: Workstation | w not in w.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tall w: Workstation | w not in (w.^succ - end)\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin not in Workstation.succ\n  \tsome w: Workstation | w.succ = end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | w in begin or w in end or (w in begin.^succ and w in ^succ.end and w not in w.^succ and one w.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    (all w : Workstation - begin - end | w in begin.^succ and w in ^succ.end and some w.succ) and\n  \t(all b : begin | no succ.b and lone b.succ) and\n  \t(all e : end   | no e.succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \tws not in ws.succ and\n  \tone ws & begin iff one end & ws.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) and (ws in begin and one ws.succ implies end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws: Workstation|\n  \t(ws in begin and no ws.succ implies ws in end) and (ws in begin and one ws.succ and ws not in ws.succ implies end in (ws.^succ - ws)))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  one Workstation or one begin.succ and one succ.end and (all w: Workstation - begin - end | one w.succ and one succ.w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tone Workstation\n  \t\t=> no succ\n  \telse (one begin.succ and one succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tone Workstation\n  \t\t=> no succ\n  \telse (\n      \t(all w: Workstation | lone w.succ and w not in w.succ)\n\n\n\t\tand (no end.succ) and (no succ.begin)\n    )\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation |some w2: Workstation | w2 not in w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: (Workstation+begin+end) | one begin.*succ & w\n  \tend in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj w1, w2: Workstation | w1 != w2 and w1 in begin.*(succ) and w2 in begin.*(succ) implies w1 in w2.*(succ) or w2 in w1.*(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | w = begin or lone w.succ\n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ) and some(succ.ws)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: (Workstation-begin-end) | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ) and (begin != end) implies some(succ.end)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tno(succ.begin) and no(end.succ)   \n  \t(begin != end) implies some(succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws not in (ws.^succ)\n  \tall ws: (Workstation-begin-end) | some(ws.succ)\n  \tno(succ.begin) and no(end.succ)   \n  \t(begin != end) implies some(succ.end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w1 : Workstation | w1 in begin implies one(w1.succ)\n  all w2 : Workstation | (w2 not in end) and (w2 not in begin) implies one(w2.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | w in end implies no(w.succ)\n  all w1 : Workstation , wb: begin | w1 in wb.*(succ)\n  all w2 : Workstation | (w2 not in end) and (w2 not in begin) implies one(w2.succ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w:Workstation - begin | w in begin.^succ && one begin.succ\n  \tno end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall c:Component | all parts: c.parts | c.workstation in parts.workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| ws in begin or ws in begin.^succ & end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | begin != end implies end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation\n\tall w : Workstation | not begin in w.^succ\n\tall w : Workstation | begin != end implies end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| (ws in begin.^succ and ws not in end.^succ) or (ws in begin&end and ws not in ws.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation| (ws in begin.^succ and ws not in end.^succ) or (ws in begin&end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n    begin != end iff all w : Workstation | w != begin and w != end implies w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end iff one Workstation\n\tbegin != end implies all w : Workstation - {begin + end} | w in begin.^succ and end in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w: Workstation | w in w.succ and (w not in end.succ implies w not in begin.succ)\n}",
                    "{\n  \n  all ws : Workstation | (ws = begin and ws.succ = end)\n  or\n  (ws = end and ws.succ = begin)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all ws:Workstation | one b:begin | one e :end | ws in b.succ or e in ws.succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall disj w1, w2 : Workstation | w1 in begin.succ.*succ and w2 in end.succ.*succ implies w1 in w2.succ.*succ or w2 in w1.succ.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation \n\t\n  \tbegin not in Workstation.succ  \n  \tend in Workstation.succ\t\n  \t\n  \tno end.succ\n \t\t\n  \tall w : Workstation-end | one w.succ and w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies one Workstation\n  \tbegin != end implies {\n      \tall w : Workstation-end-begin | one w.succ \n  \t\tall w : Workstation-end-begin | w not in w.succ \n    \tall w : Workstation-end-begin | one s : Workstation | s.succ = w\n    }\n  \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end implies {\n      \tone Workstation\n      \tno end.succ\n  \t}\n      \n  \tbegin != end implies {\n      \tone begin.succ\n      \tno end.succ\n      \t\n      \tall w : Workstation | w not in w.^succ  \n    }\n  \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or (begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    begin.^succ = end or (one Workstation and begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    #Workstation > 1 => begin != end and begin.^succ = end \n  \telse (one Workstation => begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    #Workstation > 1 => begin != end and begin.^succ = end and no end.succ\n  \telse (one Workstation => begin = end and no succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \t#Workstation > 1 => ^succ in begin one -> one end\n  \telse (one Workstation => begin = end and no succ)\n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno begin & end\n    all w : Workstation | lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    lone begin.succ and no end.succ\n    all w : Workstation | lone w.succ and w not in w.^succ\n    \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | one b: begin, e: end | e in ws.^succ and ws in b.^succ or ws = b and ws = e\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.^succ and end in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws in begin.^succ and end in ws.^succ and one ws2 : Workstation | ws.succ = ws2\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tlet line = begin.*(succ) & Workstation\n    {\n        all ws: Workstation | ws in line and (ws != ws.succ) \n        one last: line | last.succ = end and last not in last.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws in begin => one ws.succ or ws in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | begin in w implies w not in w.succ and end in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome w : Workstation | begin in w iff end in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.succ and one w.succ and (begin in w implies end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome w : Workstation | w not in w.^succ and lone w.succ and (begin in w and end in w.*succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n  \tsome w : Workstation | w.succ = Workstation-w and begin in w and end in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ and lone w.succ\n  \tsome w : Workstation | w.^succ = Workstation-w and begin in w and end in w.^succ\n  \tsome w : Workstation | end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in *succ.wo and end in wo.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome wo: Workstation | begin in *succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tsome w: Workstation  | begin not in *succ.w\n    some wo: Workstation | begin in *succ.wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tsome w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w : Workstation | succ.w + w.succ + w = Workstation\n\tall w: Workstation  | begin not in succ.w\n    some wo: Workstation | begin in wo and end in wo.*succ \n  \tsome wo: Workstation | end in wo and no wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w) or (begin not in w and end not in w)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  some w : Workstation | (no succ.w and begin in w) or (no w.succ and end in w) or (begin not in w and end not in w)  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | begin in w implies no succ.w and end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | lone w.succ and lone succ.w and w+w.^succ+^succ.w = Workstation\n  all w : Workstation | begin in w implies no succ.w or end in w implies no w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | lone w.succ and lone succ.w\n\tall w : Workstation | begin in w implies no succ.w \n\tall w : Workstation | end in w implies no w.succ \n}",
                    "{\n    // The workstations form a single line between begin and end\n    all w: Workstation - begin - end | lone w.~succ and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      let line = Workstation - begin - end | all w: line | one w.succ and w not in w.succ\n\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no ws: Workstation | ws not in begin.*succ || ws not in end.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - end | some ws.succ\n    all ws: Workstation - begin | lone ws.succ\n    end not in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tall w : Workstation - end | some s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tall w : Workstation - end | some s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ\n  \tno w : Workstation | w in end.succ\n  \tno w : Workstation | begin in w.succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - begin | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | end in w.^succ\n  \tall w : Workstation - end | one s : Workstation | s in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation - end | one s : Workstation | s in w.succ\n  \tall w : Workstation - begin | one s : Workstation | w in s.succ\n  \tbegin = end => no s : Workstation | s in begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in Workstation lone -> lone Workstation\n\tend in begin.*succ\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc in Workstation lone -> lone Workstation\n\tend in begin.*succ\n  \tno succ.begin\n  \tno end.succ\n  \tall w: Workstation | w.succ != w\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all disj ws1, ws2 : Workstation | ws1.succ != ws2.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin != end and begin + begin.^succ = Workstation and end.succ = none\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  begin + begin.^succ = Workstation\n  all ws : Workstation | lone ws.succ and ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | ws = begin or ws = end\n\tall ws: Workstation | ws != end implies one ws.succ\n  \tall ws: Workstation | ws != begin implies no ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies one ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws != begin or ws != end implies (some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws = begin and ws = end implies one Workstation\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | some ws2: Workstation | ws in ws2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws = begin implies ws not in ws.succ\n  \tall ws: Workstation | ws != begin and ws != end implies ( some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws = begin implies lone ws.succ\n  \tall ws: Workstation | ws = end implies no ws.succ\n  \tall ws: Workstation | ws not in ws.succ\n  \tall ws: Workstation | ws != begin and ws != end implies ( some ws2: Workstation | ws in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin.succ = end or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ.^(succ) = end  or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ != begin\n  begin.^(succ) = end or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.succ != begin\n  (begin.^(succ) = end and no (Workstation - begin.^(succ))) or begin = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin.^(succ) = end or begin = end or all ws : Workstation | ws.succ != ws and ws in begin.^(succ) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (end in begin.^(succ) or begin = end) and begin.succ != begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end implies one Workstation or begin.^(succ) = end\n  all ws : Workstation | ws.succ != ws and ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  (begin.^(succ) = end and no end.succ) or (begin = end)\n\n  all ws : Workstation | ws in (begin + begin.^(succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  (all ws : Workstation | ws = begin or ws in begin.^(succ)) and begin.^(succ) = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  (all ws : Workstation | ws = begin or ws in begin.^(succ)) and (begin.^(succ) = end or begin = end)\n}",
                    "{\n\tall w:Workstation | w in begin implies (some w2:Workstation | w->w2 in succ)   \n\tall w1,w2,w3:Workstation | (w1 in begin and w1->w2 in succ and w1->w3 in succ) implies (w2=w3) \n\n\tall w:Workstation | w in end implies (some w2:Workstation | w2->w in succ)  \n\tall w1,w2,w3:Workstation | (w1 in end and w2->w1 in succ and w3->w1 in succ) implies (w2=w3) \n\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  \n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) \n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) \n\n\tall w : Workstation | not w->w in succ  \n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) \n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) \n\n\t\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation | w1!=w3 and w1->w2 in succ and w2->w3 in succ)\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  \n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  \n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  \n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) \n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) \n\n\tall w : Workstation | not w->w in succ  \n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) \n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) \n\n\t\n\t\n\n\tall x:Workstation | some y,z:Workstation | (not x in begin and not x in end and y!=z and y!=x and z!=x) implies (y->x in succ and x->z in succ) \t\n\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  \n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  \n\n\t\n\tall w1,w2:Workstation | (w1!=w2 and ((w1 in begin and w2 in end) or (w1 in end and w2 in begin))) implies ((w1->w2 in succ)or(w2->w1 in succ)) \n\n}",
                    "{\n\tsome w1,w2 : Workstation | w1 in begin and w2 in end  \n\tall w1,w2 : Workstation | (w1 in begin and w2 in begin) implies (w1=w2) \n\tall w1,w2 : Workstation | (w1 in end and w2 in end) implies (w1=w2) \n\n\tall w : Workstation | not w->w in succ  \n\tall w1,w2:Workstation | (w1 in begin and w2!=w1) implies (not w2->w1 in succ) \n\tall w1,w2:Workstation| (w2 in end and w1!=w2) implies (not w2->w1 in succ) \n\n\t\n\tall w2:Workstation | (not w2 in begin and not w2 in end) implies (some w1,w3: Workstation |w1->w2 in succ and w2->w3 in succ)\t\n\n\tall w1,w2,w3:Workstation | (w1->w2 in succ and w1->w3 in succ) implies (w2=w3)  \n\tall w1,w2,w3:Workstation | (w2->w1 in succ and w3->w1 in succ) implies (w2=w3)  \n\n\t\n\tall w1,w2:Workstation | (w1!=w2 and ((w1 in begin and w2 in end) or (w1 in end and w2 in begin))) implies ((w1->w2 in succ)or(w2->w1 in succ)) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n  \n  all w : Workstation | not w in ^succ.w  \n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\n  \tall b:begin,e:end| b!=e implies (e in ^succ.b)\n  \n  all w : Workstation | not w in ^succ.w  \n  \n \tall b : begin, w : Workstation | not w->b in succ  \n\tall e : end, w : Workstation | not e->w in succ \n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w = end) or (some w.succ)\n    all w: Workstation | (w = begin) or (some w1: Workstation | w in w1.succ)\n    no w: Workstation | w in w.succ\n\n}",
                    "{\n    \n    all w : Workstation | \n        (w in begin.succ implies one w.succ) and \n        (w in end.succ implies no w.succ) \n}",
                    "{\n  \n\n  \n  no w: Workstation | w in begin.succ\n\n  \n  no w: Workstation | end in w.succ\n\n  \n  all w: Workstation - begin - end |\n    one p: Workstation | p in w.succ\n\n  \n  all w: Workstation - begin - end |\n    one s: Workstation | w in s.succ\n\n  \n  \n  all w1, w2: Workstation | \n    (w1 in w2.succ) implies (w1 != begin and w1 != end and w2 != begin and w2 != end)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = begin or w in begin.^succ) and (w = end or end in w.^succ) and lone w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | some w.succ implies some begin <: *succ :> end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin | some w.succ \n  \tall w : Workstation-end | some succ.w \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.^succ\n  \tall w : Workstation-begin | some w.succ and no succ.w\n  \tall w : Workstation-end | some succ.w and no w.succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: begin | lone w2: Workstation | w2 in ws.succ\n  \n  \tall ws: end | no w2: Workstation | w2 in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - begin - end | one w.succ and one w.~succ and w in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno begin.~succ and no end.succ\n  \tall w: Workstation - end | one w.succ and one w.~succ\n    all w: Workstation - begin | one w.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation - begin - end | one w.succ and one w.~succ\n  \tone begin.succ and no begin.~succ \n  \tone end.~succ and no end.succ \n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ = end or all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ in end or all workstation: Workstation - begin - end | \n        one p: Workstation | prev.p = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    no end.succ\n  \tno succ.begin\n    begin.succ in end or all workstation: Workstation - begin - end | \n        one p: Workstation | p.succ = workstation and\n        one s: Workstation | workstation.succ = s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no end.succ\n  no succ.begin\n  begin = end or \n    all workstation: Workstation | \n        one workstation.succ and workstation !in workstation.succ\n}",
                    "{\n\tall b : begin | b.~succ = Workstation\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.succ\n\n  \tall b : begin |\n  \t\tend in b.*succ and\n  \t\tno succ.b and no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  \tno succ.begin\n  \n\tno end.succ\n  \n  \tall w : Workstation | w not in w.succ\n  \t\n  \tall w : Workstation-begin-end | some w.succ and some succ.w\n  \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | end in w.*succ or begin in w.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, e: end | {\n      w not in w.succ\n      e in w.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.^succ\n      b not in e.succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in e.succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in w.~succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation, b: begin, e: end | {\n      w not in w.succ\n      e in w.*succ\n      b not in b.~succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | (w = end or some w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tno w : Workstation | w in w.succ\n  \n  \tall w : Workstation | w in begin.*succ\n  \n  \tall w : Workstation - end | one w.succ\n  \n\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w = end or w.^succ in w.^succ.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin implies end in wstation.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin or wstation in end\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tone wstation: Workstation | wstation not in wstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n  \tall wstation: Workstation | no wstation.succ implies wstation in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall wstation: Workstation | wstation in end implies no wstation.succ\n  \tall wstation: Workstation | wstation in begin and wstation not in end \n  \t\timplies end in wstation.^succ\n  \tall wstation: Workstation | no (wstation.succ & wstation)\n  \tall wstation: Workstation | no wstation.succ implies wstation in end\n  \tall wstation: Workstation | some wstation.succ and no succ.wstation\n  \t\timplies wstation in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  let ws = Workstation {\n        some begin and some end and\n        \n        no (begin & end) and\n        \n        ws = begin.^succ + end.~^succ and\n        \n        no w: ws | w in w.^succ\n    }\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tsome succ and\n    no w: Workstation | w in w.^succ and\n    begin.^succ = Workstation - begin and\n    end.~^succ = Workstation - end and\n    (all w: Workstation - begin - end | one w.succ) and\n    (all w: Workstation - begin - end | one w.~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  \n      (begin.succ = end) and\n        (all w: Workstation - end | some w.succ) and\n        (all w: Workstation - begin | some w.^succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | (w not in begin and w not in end) implies one w.succ\n  all w: Workstation | w not in w.^(succ)\n  all b: begin | no succ.b\n  all e: end | no e.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies one succ.end and some begin.succ\n  \tend in begin.^succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tall e:end | no e.succ\n  \tsome Workstation-end-begin implies end in begin.^succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \t\n  \tall ws:Workstation - begin - end | ws in begin.^succ\n  \tall w: Workstation | w not in w.^succ\n  \tall w: Workstation - end | lone w.succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno succ.begin\n  \tno end.succ\n  \tend in begin.^succ or end in begin\n  \t\n  \tall w: Workstation | w not in w.^succ\n  \tall w: Workstation - end | lone w.succ\n  \t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | \n  \tall wStart: (Workstation & begin) |\n  \tsome wEnd: (Workstation & end) | \n  \t\twStart not in w.succ and \n  \t\twStart not in wStart.succ and\n  \t\twStart not in end \n  \t\t\timplies wEnd in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wStart: (Workstation & begin) | wStart not in wStart.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wStart: (Workstation & begin) | wStart not in wStart.^succ\n  \tall wStart: (Workstation & begin) | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | wStart not in w.^succ\n  \tall wStart: (Workstation & begin) | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | all wStart: (Workstation & begin) | \n \t\twStart not in w.^succ\n  \tall wStart: (Workstation & begin) - end | one wEnd: (Workstation & end) |\n  \t\twEnd in wStart.succ\n  \tall w: Workstation | no w.succ implies w in begin\n  \tone w: Workstation | w not in w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation & end | no ws.succ\n  \tall ws: (Workstation & begin) - end | some ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation & end | no ws.succ\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | no ws.succ iff ws in end\n  \tall ws: Workstation | some ws.succ iff ws in begin-end\n  \tone ws: Workstation | ws not in ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation | workstation not in workstation.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      all w : Workstation | \n        (w != end implies one w.succ) and \n        (w != begin implies one v : Workstation | w in v.succ)\n\n    \n    all w : Workstation | w in begin.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n      all w : Workstation | \n        (w != end implies one w.succ) and \n        (w != begin implies one v : Workstation | w in v.succ)\n\n    \n    all w : Workstation | w = begin implies w in begin.succ\n\n}",
                    "{\n    \n    all w : Workstation |\n        (w = begin implies (some w1 : Workstation | w -> w1 in succ)) and\n        (w = end implies (some w2 : Workstation | w2 -> w in succ)) and\n        (w != begin and w != end implies (some w1 : Workstation | w -> w1 in succ) and (some w2 : Workstation | w2 -> w in succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n    all w : Workstation | ( w = begin implies (some w1:Workstation | w->w1 in succ)) and (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w -> w not in succ\n  \n    all w : Workstation | ( w = begin implies (one w1:Workstation | w->w1 in succ)) or (w = end implies (one w2: Workstation | w2->w in succ) ) \n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n    \n    all w : Workstation | w -> w not in succ\n\n    \n    one w1 : Workstation | begin -> w1 in succ\n\n    \n    one w2 : Workstation | w2 -> end in succ\n\n    \n    all w : Workstation - begin - end |\n        (some w1 : Workstation | w -> w1 in succ) and\n        (some w2 : Workstation | w2 -> w in succ)\n\n    \n    all w : Workstation | w in begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  Workstation = begin.*succ + end\n  \n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  succ in begin -> end\n  \n  no end.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tno (end & Workstation.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tall w : (Workstation - begin) | one (w.succ & end)\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tend in Workstation.^succ or begin = end\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \t(end not in end.^succ and end in Workstation.^succ) or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not in Workstation.^succ\n  \tbegin.^succ = end\n  \tall w : Workstation | w not in w.succ\n  \tend in Workstation.^succ or lone Workstation\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \t\n  \tall w : Workstation | w not in w.succ and lone w.succ\t\n  \tend in Workstation.^succ or lone Workstation\t\t\t\n  \tno end.succ\t\t\t\t\t\t\t\t\t\t\t\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t\n  \tall w : Workstation | w not in w.succ and lone w.succ\t\n  \tno end.succ\t\t\t\t\t\t\t\t\t\t\t\t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin.^succ = Workstation - begin\t\t\t\t\t\t\n  \tall w : Workstation | w not in w.succ and lone w.succ\t\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one w2: Workstation - end - begin | w2 in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation, s:ws.succ | begin in s and end in s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one s:ws.succ | begin in s and end in s\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | \n        one ws.succ or ws = end \n    \n    \n    no ws: Workstation | ws in begin.~succ\n\n    \n    all ws: Workstation | ws in begin.*succ\n}",
                    "{\n  all disj ws, ws1: Workstation | ws not in ws.^succ and ws in ws1.succ or ws1 in ws.succ\n\t// The workstations form a single line between begin and end\n\n}",
                    "{\n all ws: Workstation | lone ws1 : Workstation | ws not in ws.^succ and ws1 !=ws and ws1 not in ws1.^succ and ws1 in ws.succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n all disj ws,ws1: Workstation| ws not in ws.^succ and ws1 not in ws1.^succ\n\n// The workstations form a single line between begin and end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in ws1.succ and ws2 not in (ws2.succ + ws1.succ))\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in (ws1.succ + ws2.succ) and ws2 not in ws2.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | (begin in ws1 and end in ws2) implies (ws1 not in (ws1.succ + ws2.succ) and ws2 not in ws2.succ and ws2 in ws1.succ)\n}",
                    "{\n    \n    all w : Workstation - end | #w.succ = 1\n    \n    \n    no end.succ\n    \n    \n    begin in Workstation.*succ\n    \n    \n    all w : Workstation | w in begin.*succ or w = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation, wss: Workstation - ws |\n  \t\tws in begin => ws not in wss.succ\n  \n  \tall ws: Workstation |\n  \t\tws in end => no ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation, wss: Workstation - ws |\n  \t\tws in begin => ws not in wss.succ\n  \n  \tall ws: Workstation |\n  \t\tws in end => no ws.succ\n  \n  \tall ws: Workstation - end |\n  \t\tone ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : Workstation | begin in w + w.~succ\n  \t\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : begin.^succ | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | w not in w.^succ\n  \tall w : end.~succ | begin in w + w.~succ\n  \tall w : begin.^succ | end in w + w.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all wk : Workstation | one wk.succ\n  all wk : Workstation | wk in begin iff some ( wk.^(succ.succ) & end )\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall wk : Workstation | wk in begin iff no (wk.~succ)\n\tall wk : Workstation | wk in end iff no wk.succ\n\tall wk : Workstation | wk in begin.*succ\n\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w : Workstation | no (w & w.succ) no succ.begin and no end.succ and some begin.succ and some succ.end\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x : begin | no succ.x\n  \tall x :Workstation - end | one x.succ\n  \tall x: end | no x.succ and x not in begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall x : begin | no succ.x\n  \tall x :Workstation - end | one x.succ\n  \tall x: end | no x.succ\n  \tall x : Workstation | some Workstation -x implies no begin & end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w1 : Workstation | one w2 : Workstation | w1 in w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | no w.succ\n\tsome w : Workstation | no w2 : Workstation | w in w2.succ\n  \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | one (w & begin) implies (some (w.succ) and one (w & end)) \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w1 : Workstation | all w2 :  Workstation - w1 |  w2 in w1.^succ\n  \tall w : Workstation | #(w.succ) < 2\n  \tone w1 : Workstation | all w2 :  Workstation - w1 |  w1 in w2.^succ\n  \t \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | no (w.succ & begin) and one (w.succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | #w.succ = 0 implies Workstation in w.*(~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | #w.succ = 0 implies Workstation in w.^(~succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | w.~succ = none and Workstation in w.*succ \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | let succ = w.^succ | Workstation in w+succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tone w : Workstation | let succ = w.^succ | Workstation in succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w : Workstation | #w.succ = 1 implies (w not in w.^succ and Workstation in \t   w.^succ + w)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall w: Workstation | one b: begin |one e: end | b in w.succ and e in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n \tall w: Workstation | one b: begin |one e: end | b in w.*succ and e in w.succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \none Workstation.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n\tone Workstation-end.succ \n  \t\n  \tno succ.end\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n  no succ.begin\n  no end.succ\n  some Workstation.succ\n \n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1 : Workstation | some ws2 : Workstation | ws2 in begin implies ws1 in ws2.^(succ)\n  \n  all w : Workstation - end | one w.succ\n  \n  no end.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin) and (w not in end) implies one w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall w: Workstation | (w not in begin) and (w not in end) implies one w.succ\n  \tall w: Workstation | w not in w.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one b:Workstation | one e:Workstation |\n  \t\tws in b.^succ and e in b.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | one b:begin |\n  \t\tb.^succ & ws.^succ = ws.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.^succ\n  \tWorkstation in end.^(~succ)\n  \t\n  \tall ws:Workstation - begin - end | one s:Workstation | one p:Workstation |\n  \t\ts = ws.succ and p = ws.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tWorkstation in begin.^succ\n  \tWorkstation in end.^(~succ)\n  \t\n  \tall ws:Workstation - end - begin | one s:Workstation | one p:Workstation |\n  \t\ts = ws.succ and p = ws.~succ\n  \n  \tall ws:Workstation | ws not in ws.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  #w.succ = 1 and w != begin implies w in begin.*succ\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all w: Workstation |  w!= end implies #w.succ = 1 and (w != begin implies w in begin.*succ)\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation - begin |\n  \t\tws in begin.^(succ) and \n  \t\tWorkstation - begin.^(succ) = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws1, ws2: Workstation | ws2 not in ws1.succ.^succ\n  \tend.succ = none\n  \tbegin & end = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws.succ != none iff ws != end\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and ws.succ != none iff ws != end\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ != w2.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#begin.succ = 1\n  \t#end.succ = 0\n\tall ws: Workstation | ws not in ws.^succ and (ws.succ != none iff ws != end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws: Workstation | end in ws.*succ and (ws.succ != none iff ws not in end)\n  \tall disj w1, w2: Workstation | w1.succ & w2.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin = end or\n\tall ws: Workstation | ws.succ != none iff ws not in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall ws: Workstation | \n  \t\tws not in ws.^succ and\n  \t\tws not in end implies #ws.succ = 1\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws:Workstation | #ws.succ=1 and ws not in ws.succ\n  \tone disj ws1,ws2:Workstation | ws1 in begin and ws2 in end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.*(succ)\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin.succ != end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tall ws : Workstation | ws in begin.^(succ) \n  \tall wsend : Workstation | end in wsend.^(succ)\n  \tbegin & end != none\n}",
                    "{\n\t// The workstations form a single line between begin and end\nend in begin.*succ\n  all ws : Workstation | ws != end implies one ws.succ\n  all ws : Workstation | ws != begin implies one pre : Workstation | ws in pre.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.*succ\n  \tbegin in *succ.end\n  \tall wo : Workstation | wo.succ not = none => begin not = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc not in iden\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tsucc - iden = succ\n  \tWorkstation in begin.*succ\n  \tbegin.succ not = none => end in begin.^succ\n  \tall wo : Workstation | wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tend in begin.^succ\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tbegin not = end => end in begin.^succ\n  \tall disj wo1, wo2 : Workstation | wo1.succ not = none => wo2 in wo1.^succ and wo1 not in wo1.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \tend in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \t#Workstation = 1 => begin = end and succ = none->none\n  \t#Workstation != 1 => end in begin.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    all wo : Workstation | (wo.succ not = none => wo not in wo.^succ) and wo.succ = none => wo = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    all wo : Workstation | (wo.succ != none => wo not in wo.^succ)\n  \tone wo : Workstation | wo.succ = none => wo = end\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation in begin.*succ\n    \n  \t\n  \tall wo : Workstation-begin-end | one wo.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tWorkstation-begin in begin.^succ\n    \n  \t\n  \tall wo : Workstation-end | one wo.succ and wo not in wo.^succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  all b : begin | some succ.b\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tend in begin.^succ and end.succ = none\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \tall w: Workstation | w != end implies one w.succ and w != begin implies one succ.w\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  ^succ = (Workstation -> Workstation) - (end -> Workstation) - iden\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  *succ = iden + (Workstation -> end) and no end.succ and no succ.begin\n\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\tbegin != end implies end in begin.*succ else no begin.succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | ws.succ != ws) and end = begin.*succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | (one ws2 : Workstation | ws.succ = ws2) or ws = end) and no ws : Workstation | ws.succ = begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t(all ws : Workstation | (one ws2 : Workstation | ws != ws2 and ws.succ = ws2) or ws = end) and no ws : Workstation | ws.succ = begin\n}",
                    "{\n\t// The workstations form a single line between begin and end\n\t\n  no w: Workstation - begin | some w.~succ\n  \n  \n  no w: Workstation - end | some w.succ\n\n  \n  all w: Workstation - end | lone w.succ\n\n  \n  all w: Workstation - begin | lone w.~succ\n}",
                    "{\n\t// The workstations form a single line between begin and end\n  \n  all w: Workstation - end | lone w.succ\n\n  \n  all w: Workstation - begin | lone w.~succ\n  \n  all w: Workstation | w not in w.succ\n}"
                ]
            },
            {
                "description": "The parts of a component must be assembled before it in the production line",
                "pred": "this/inv10",
                "oracle": "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.parts & Component | c.workstation in p.workstation.^succ\n}",
                "erroneous": [
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p in succ.{c.workstation}\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | c.workstation in p.workstation.^succ\n }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.parts.workstation.^succ\n}",
                    "{\n    // The parts of a component must be assembled before it in the production line\n    all c: Component, p: c.parts | p.workstation in c.workstation.~succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c : Component | c.parts.workstation in c.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  \tall c : Component, p : c.parts, ws1 : p.workstation, ws2 : c.workstation | ws1 in ws2.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts |\n        all ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts | \n  \t\tp.workstation in (^succ).c.workstation\n  \n  \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation in c.parts.workstation.*succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | all p: c.parts | \n        some ps, pc: Workstation | \n            ps in p.workstation and \n            pc in c.workstation and \n            ps in pc.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall a, b: Component | a in b.parts implies b in a.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | let\n\t\tws = c.workstation,\n\t\tprevParts = (ws.succ.parts - c.parts) | \n\t\tprevParts not in ws.parts\n\n}",
                    "{\n    \n    \n    all c : Component , p : c.parts | \n            some wsPart, wsComponent : Workstation | \n                p in workstation.wsPart and \n                c in workstation.wsComponent and\n                wsComponent in wsPart.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | c.parts not in c.workstation.^succ\n\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in  c.parts.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.^parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts |\n        some ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \n\tall c:Component | no (workstation.(c.workstation.^succ) & c.^parts)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : (c.parts) | no( c.workstation.succ & p.workstation.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.parts | one ws2: Workstation | ws2 in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation in p.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: (c.parts & Component) | c.workstation in p.workstation.*succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p: Component, c: Component | p in c.parts implies some ws1, ws2: Workstation |\n      ws1 in p.workstation and ws2 in c.workstation and ws1 in ws2.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p.workstation not in c.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != begin => all c1 : parts.c & Component | c1.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != begin => all c1 : c.^parts & Component | c1.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\nall c : Component |\n      all p : c.parts |\n          some w : Workstation\n            |\n              p.workstation in w.^succ and w in c.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c : Component | (c.parts.workstation) not in (c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies no c1.workstation & c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all p : c.parts | c.workstation in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c : Component | c.workstation in c.parts.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.^parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | c.workstation in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation in c.workstation.*(~succ) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != end => all c1 : parts.c & Component | no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | one c.workstation.succ => (all c1 : parts.c & Component | c1.workstation = begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  \n  all c : Component | c.workstation != begin => all p : c.parts & Component | p.workstation = end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n  all c : Component | parts.c in c.workstation.^succ.parts\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all comp : c.parts | c.parts.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.^parts).workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, w : Workstation| c in workstation.w implies c.^(parts) in (workstation.(^(succ).w)).^(parts)\n \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.^succ or lone Workstation or no c.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | c.workstation != none implies c.parts != none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | all c1 : c.parts & Component | one c1.workstation and c1.workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | all c1 : c.^parts & Component | one c1.workstation and c1.workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != end => all c1 : parts.c & Component | c1.workstation != c.workstation and c1.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | c.workstation != c1.workstation and (c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | one c.workstation implies all c1 : c.^parts & Component | c1.workstation = end \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != begin implies (all c1 : (^parts).c & Component | c1.workstation != c.workstation)\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | ((c.workstation in p.workstation.succ) or (c.workstation in end and p.workstation in begin)) or c.workstation = p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | no c1.workstation or c1.workstation = begin)\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | some c.workstation => all c1 : parts.c & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p: Component, c: Component | p in c.*parts => c.workstation in p.workstation.^succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.parts.^workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.^succ in c.parts.workstation.^succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.parts.workstation not in c.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.parts.workstation.^succ not in c.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation.*succ\n  Component.workstation != Component.parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c1,c2:Component | c1 in c2.parts => c2.workstation in c1.workstation.^parts\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in c.*parts.workstation.^succ or c.parts in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation in c.workstation \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tno Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | parts.c in Component implies c.~parts.workstation in c.workstation.succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in end and ws_p in ws_c.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (begin.^succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | c2 in c1.^parts => c2 in c1.workstation.^~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all p: Product | all parts: p.parts | some w: Workstation | parts in w\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (all p: c.parts | p in workstation.(*succ.(c.workstation)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.^succ or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no c.parts or c.parts in Material or c.parts.workstation not in c.workstation.^succ or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies ws in ((c.parts).workstation  & (c.parts).workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall p : Product | all main : Product | p in main.^(parts.parts) implies  \t\t\tmain.workstation in p.*(succ)\n  \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ) implies c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.(~parts).workstation.^(~succ) in c.workstation.~succ implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.workstation in c.parts.workstation.succ or c.parts = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | #c.parts != 0 implies c.workstation in c.parts.workstation.*succ \n         \n}",
                    "{\n    \n    all c: Component, p: Product |\n        p in c.parts implies \n            \n            all ws1: Workstation, ws2: Workstation |\n                ws1 in p.workstation and ws2 in c.workstation and ws1 != ws2 implies ws1 in ws2.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.^parts.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^(Component <: parts. Component <:workstation) in ^succ.(c.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies no p.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | some c.workstation implies some p.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.^parts).workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation in (c.*parts).workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, w: c.workstation | all p: c.parts | w in p.^succ\n }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | none = (c.workstation).workers => none = (c.workstation).succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in (c.parts & Component).workstation.^succ and c.workstation not in (c.parts & Component).workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^parts in workstation.^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (c.parts + c.workstation) in (c.parts + c.workstation.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no(parts.c.workstation & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation != begin => some c.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (c.parts & Component).workstation != end => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | all c1 : c.parts & Component | one c1.workstation => no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | no c1.workstation))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (c.workstation != end => (all c1 : parts.c & Component | no c1.workstation or c1.workstation = begin))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (c.workstation != end => (all c1 : parts.c & Component | c.workstation != c1.workstation and (no c1.workstation or c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation.succ => (all c1 : parts.c & Component | c.workstation != c1.workstation and (no c1.workstation or c1.workstation = begin)))\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (c.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and no c1.workstation) or (c.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and no c1.workstation) or (no c.workstation and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (no c.workstation and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c1.workstation = begin) or (c.workstation = end and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component, c1 : parts.c & Component | (one c.workstation.succ and c.workstation != begin and c1.workstation = begin) or (c.workstation = end and one c1.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation = begin => all c1 : c.parts & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | c.workstation = begin => all c1 : parts.c & Component | c1.workstation = begin or no c1.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | some c1 : c.parts & Component | some c1.workstation implies no c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n   all c: Component | {\n        all p: c.parts | {\n            all w1, w2: c.workstation |\n                w1 in w2.succ implies p.workstation in w2\n        }\n    }\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation = end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | one c.workstation implies (all c1 : (^parts).c & Component | c1.workstation = end and c1.workstation != begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  \n  all c : Component | c.workstation != begin => all p : c.parts & Component | p.workstation in end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  \n  all c : Component | some p : c.parts & Component | p.workstation != end implies c.workstation = begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (c.workstation in Workstation - end) implies (all c1 : (^parts).c & Component | c1.workstation = begin)\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | c1.workstation = begin)\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n  all c : Component | (one c.workstation) implies (all c1 : (^parts).c & Component | no c1.workstation)\n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | (c.workstation in p.workstation.succ) or (c.workstation in begin and p.workstation in end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n    all c: Component | all p: c.parts | (c.workstation in p.workstation.succ) or (c.workstation in end and p.workstation in begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component| (c.parts) in (workstation.( ^(succ).(c.workstation) )).parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | not c.parts.workstation in c.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tno c: Component | c.workstation in c.parts.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component | all p: parts.c | c.workstation in p.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c : Component | c.workstation not in begin implies c.parts.workstation in end\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t(all c: Component|\n  \tc.parts.workstation in end iff c.workstation in begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p: Component, c: Component | p in c.*parts => c.workstation in p.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n  all c: Component | \n    all p: c.parts | \n      (p = c or p in c.^succ)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all wsfromParts:c.^parts.workstation.^succ | c.workstation in wsfromParts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all wsfromParts:c.^parts.workstation.^succ | c.workstation in wsfromParts-c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | all p:c.parts | c.workstation not in p.^workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | all p:c.^parts.workstation | c.workstation not in p\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | Workstation in *succ.c.workstation \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | Workstation in *succ.(c.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.^parts.workstation not in (begin + end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | lone ws:c.^parts.workstation | c.workstation in ws\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.parts.workstation.*succ in c.workstation.*succ\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation.succ in c.parts.workstation.*succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | c.workstation not in c.parts.workstation.*succ \n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no (c.workstation.*succ & c.parts.workstation.*succ)\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.^succ in c.parts.workstation.*succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.*parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation.*succ in c.^parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | no c.parts or some (c.parts & Component) => c.workstation not in c.parts.workstation.^succ\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.parts.workstation.*succ not in c.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation\n\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c:Component | some (c.parts & Component) => c.workstation in c.parts.workstation.^succ && c.workstation not in c.parts.workstation\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.workstation not in begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | some c.parts implies c.workstation not in begin\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | some c.parts implies c.workstation in end\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1, c2 : Component | all w1, w2 : Workstation | w1 in c1.workstation and w2 in c2.workstation and c2 in c1.^parts implies w2 in w1.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | Workstation in c.workstation => all p: c.parts | Workstation in c\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.^parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws1: Workstation | ws1 in c.workstation => all p: c.*parts | one ws2: Workstation | ws2 in p.workstation or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (c.workstation in Workstation) => all p: c.parts | p in Material or some ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | (Workstation in c.workstation) => all p: c.parts | p in Material or some ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.^parts | p in Material or one ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.*parts | p in Material or one ws: Workstation | ws in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.parts | ws in p.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | one ws: Workstation | ws in c.workstation => all p: c.parts | ws in p.workstation.^succ or p in Material\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | all w1, w2: Workstation | w1 in c1.workstation and w2 in c2.workstation and c2 in c1.^parts => w1 in w1.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tsome Component.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c in Component.parts implies end not in c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | parts.c in Component implies c.~parts.workstation in c.workstation.~succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c1, c2: Component | c1 in c2.parts implies some ws: c1.workstation | ws in c2.workstation.*(succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n      all c: Component, p: c.parts | one ws1, ws2: c.workstation | ws1 in p.workstation and ws2 in c.workstation and ws1 in ws2.^succ\n\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation.succ in p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | c.workstation.succ in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: Component |\n  \t\tp in c.^parts => p.workstation in c.workstation.~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: Component |\n  \t\tp in c.^parts => p.workstation in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation = begin or c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p : c.parts | some ws:Workstation |\n  \t\tws in p.workstation\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    \tws_p in ws_c.^succ and ws_p in begin.^succ and ws_c in begin.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_p in begin.^succ and ws_c in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_c in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation, ws_p: p.workstation |\n    ws_p in ws_c.^succ and ws_p in end.^succ\n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_c: c.workstation | one ws_e : end |\n    ws_e in ws_c.^succ \n}",
                    "{\n  \t// The parts of a component must be assembled before it in the production line\n  \tall c: Component, p: c.parts, ws_p: p.workstation | one ws_e : end |\n    ws_e in ws_p.^succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (p.workstation.^succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component, p: c.parts | p.workstation in (begin.*succ & c.workstation)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts | \n        some ws : c.workstation, wp : p.workstation |\n            wp not in ws.^succ\n  \n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts & Component | \n  \t\tsome c.workstation & p.workstation\n  \n  \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t\n    all c : Component, p : c.parts & Component | \n  \t\tc.workstation = p.workstation\n  \n  \n}",
                    "{\n    \n    all c : Component | \n        all p : c.parts | \n            p.workstation in c.workstation.~succ and\n            \n            c.workstation in p.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: c.parts | \n  \t\tsome c.workstation implies some (c_parts.workstation & end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: (c.parts & Component) | \n  \t\tsome c.workstation implies some (c_parts.workstation & end)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all c_parts: (c.parts & Component) | \n  \t\tsome c.workstation implies \n  \t\t\tsome (c_parts.workstation & end) and no (c_parts.workstation & begin)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component | all p: c.parts |\n        lone ps: Workstation | \n            ps in p.workstation and \n            lone pc: Workstation | \n                pc in c.workstation and \n                ps in pc.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c: Component, w: Workstation | w in c.workstation implies ( c.parts.workstation in *(succ).w)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.*parts | c.workstation in p.workstation.^succ\n}",
                    "{\n    \n    \n    all c : Component, p : c.parts | \n        some wsPart, wsComponent : Workstation | \n            p in workstation.wsPart and \n            c in workstation.wsComponent and \n            wsComponent-> wsPart in succ\n}",
                    "{\n    \n    \n    all c : Component, p : c.parts | \n        one w : Workstation | \n            p in workstation.w and \n            c in workstation.w\n}",
                    "{\n    \n    \n    all c : Component, p : c.parts | (one w : Workstation |  p in workstation.w and c in workstation.w)\n\n\tall c : Component, p : c.parts | c in p.*succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.parts.workstation not in c.workstation.succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | no c.parts or c.parts in Material or c.parts.workstation not in (c.workstation + c.workstation.^succ) or lone Workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or c.parts.workstation not in (c.workstation + c.workstation.^succ) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or no (c.parts.workstation & (c.workstation + c.workstation.^succ)) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | (no c.parts or c.parts in Material or no (c.parts.workstation & c.workstation.^succ) or lone Workstation) and one c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | all w: c.workstation | w in p.workstation.succ or c.workstation = p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | all p: c.parts | p in Component \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in c implies before c in ws\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies once ws in (c.parts).workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in c.workstation implies once ws in ((c.parts).workstation  & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in (c.parts).workstation implies ws in (c.workstation  & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | (ws in (c.parts).workstation) or (ws in (c.parts).workstation.^succ) implies before ws in (c.workstation & c.workstation.^succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in ((c.parts).workstation & (c.parts).workstation.^succ) implies before ws in c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in Component and ws in (c.parts).workstation implies ws in (c.workstation & c.workstation.^succ) \n  }",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | c.parts in Component and ws in (c.parts).workstation and ws in (c.parts).workstation implies ws in c.workstation \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component, ws:Workstation | ws in (c.parts).workstation and ws in (c.parts).workstation.^succ implies ws in c.workstation \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\t  all c: Component, ws: Workstation, p: c.parts | ws in p.workstation or ws in p.workstation.^succ implies ws in c.workstation\n}",
                    "{\n  // The parts of a component must be assembled before it in the production line\n  all c: Component, p: c.parts&Component |\n    all ws_part: p.workstation, ws_c: c.workstation |\n      ws_part in begin.^succ and ws_part in ws_c.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n\tall disj c1, c2 : Component | c2 in c1.parts implies c2.workstation in (c1.workstation.*succ - c1.workstation.^succ) \t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\n\tall disj c1, c2 : Component | c2 in c1.parts implies c2.workstation in (c1.workstation.*succ - c1.workstation.^succ - c1.workstation) \t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | all p : c.parts | p in Component implies p.workstation not in c.^workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall p : Product | all main : Product | p in main.^(parts.parts) implies  \t\t\tmain.workstation in p.workstation.^(succ.succ)\n  \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c:Component | one c.workstation \n\t\t\t\t\timplies\n\t\t\t\t\t(all p:c.^parts | one p.workstation) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component , p : ^parts.c |\n  \t\tp.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component , p : parts.c |\n  \t\tp.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation in ^succ.c.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component, p : c.parts | c.workstation in ^succ.(c.workstation)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall x: Component, w : x.workstation, y: x.parts & Component | y.workstation in (w.succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1.parts in c2.^parts implies c1.workstation not in c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1.parts in c2.parts implies c1.workstation not in c2.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.^succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component, c2 : Component  | c1 in c2.parts implies c1.workstation not in c2.workstation.^succ and (c1 != c2)\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  some c1 : Component | all c2 : c1.^succ | some p : c2.parts |  p in c1 \n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  all c1 : Component , c2 : Component | c1 in c2.parts implies c2.workstation in c1.workstation.succ\n\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.(~parts).workstation in c.workstation.~succ \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.*(~succ) iff c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component | c.workstation in c.(~parts).workstation.^(~succ) implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.(~parts).workstation.^(~succ)-c.workstation in c.workstation.~succ-c.workstation implies \t c.(~parts) in Component\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c : Component |  c.workstation in c.parts.workstation.succ or c.parts.workstation = \tnone\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tsome c: Component, p: c.parts |\n        some ws: c.workstation, wsPart: p.workstation |\n            wsPart in ws.(~succ)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | all c:Component | m in c.parts and c.workstation = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | some c:Component | m in c.parts and c.workstation = none\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall m:Material | m in Component.parts\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.parts.workstation != none implies c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies c.workstation in c.parts.workstation.^succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies \n  \t\tc.^parts.workstation.^succ in c.workstation.^~succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component | c.^parts.workstation != none implies\n  \t\tc.workstation in c.^parts.workstation.*succ\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws: Workstation | ws in p.workstation and ws not in end)\n\t\t\tand (some ws1: Workstation | ws1 in c.workstation and ws1 in end  )\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws: Workstation | ws in p.workstation )\n\t\t\tand (some ws1: Workstation | ws1 in c.workstation and ws1 in end  )\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(#p.workstation > 0 implies (some ws: Workstation | ws in p.workstation)\n\t\t\tand some ws2: Workstation | ws2 in end and ws2 in c.workstation\n)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws1 in end and ws1 in c.workstation and\n  \t\t\t(#p.workstation > 0 implies ws2 in p.workstation) )\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation and ws2 in end and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall m: Material | m.parts = none\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 = ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \tall m: Material | m.parts = none\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws2 in ws1.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 = ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \tall m: Material | #m.parts = 0\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.^succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n \tall m: Material | #m.parts = 0\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | ws2 = c.workstation \n  \t\t\tand ws1 in p.workstation  and ws1 in ws2.*succ)\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n  \t\n\tall c: Component |\n  \t\tall p: c.parts |\n  \t\t\t(some ws1, ws2: Workstation | \n  \t\t\t\tp not in Material implies (\n  \t\t\t\tws2 = c.workstation and ws1 in p.workstation  and ws1 in ws2.*succ))\n\t\t\t\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies all p: Product | some p.workstation\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies some p.workstation or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end - begin or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n    all c: Component | some c.workstation implies (all p: Product | p in c.^parts implies p.workstation = end and p.workstation != begin or p in Material)\n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all p : p.parts | (p in Component implies (some ws : p.workstation.^~succ | ws in p.workstation)) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all p : p.parts | (p in Component implies (some ws : p.workstation.*~succ | ws in p.workstation)) \n}",
                    "{\n\t// The parts of a component must be assembled before it in the production line\n\tall p : Product | all pp : p.parts | (pp in Component implies (some ws : p.workstation.*~succ | ws in pp.workstation)) \n}"
                ]
            }
        ]
    },
    {
        "example": "Train station",
        "model": "sig Track { succs : set Track, signals : set Signal } sig Junction in Track {} sig Entry in Track {} sig Exit in Track {} sig Signal {} sig Semaphore extends Signal {} sig Speed extends Signal {}",
        "id": "cXPP9QBPTYgTX6WJ6",
        "requirements": [
            {
                "description": "The station has at least one entry and one exit",
                "pred": "this/inv1",
                "oracle": "{\n\t// The station has at least one entry and one exit\n\tsome Entry and some Exit\n}",
                "erroneous": [
                    "{\n\t// The station has at least one entry and one exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t:Track | t in Entry and t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n  \t\n  \t\n  all t: Track | some e: Entry |some x: Exit |e in t.succs and x in t.succs \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n   \n   \n   some t: Track | t in Entry and t in Exit\n\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  one Entry\n  one Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t : Track | some en : Entry, ex : Exit | en in t.*succs and ex in t.*succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tlone Entry and lone Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome Entry and one Exit\n}",
                    "{\n  // The station has at least one entry and one exit\n\tall t: Track |\n  \t\tsome en: Entry, e: Exit |\n  \t\t\ten in t.^succs and e in t.^succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome Entry\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some Entry and some Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome entry: Entry | entry in Track.succs\n  \tsome exit: Exit | exit in Track.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t : Track | t in Entry and t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tsome t : Track | t in Entry or t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | some Exit & t.*succs and t in Entry.*succs  \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n     all s : Track | Entry in s and Exit in s\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n     all s : Track | some ( s.*(succs) & Entry & Exit)\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\t\n\tsome t1: Entry, t2: Exit | t1 != t2\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | all tsucc : t.*succs | t.signals!=t.signals-Entry and t.signals!=t.signals-Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | one Entry and one Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | one en: Entry, ex: Exit | en in t.succs and ex in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t: Track | t.succs in Entry\n  \tall t: Track | t.succs in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | t in Entry  \n\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t:Track |\n  \t\tsome en:Track,e:Track |\n  \t\t\ten in t.succs and e in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome none\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsuccs in Track one -> some Entry\n  \n  \tsuccs in Track one -> some Exit\n  \n  \tsuccs in Track one -> lone Junction\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | lone en: Entry, ex: Exit | en in t.succs and ex in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\n  \tsome Exit\n}",
                    "{\n  // The station has at least one entry and one exit\n  all t: Track, ex: Exit, en: Entry | ex in t.succs and en in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tJunction =  (Entry + Exit)\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \n  some Exit and some Entry and (all e : Track | some Exit & e.*succs and some Entry & (*succs).e)\n \t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | one en: Entry | one e: Exit | en in t.^succs+t and e in t.^succs+t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tlone t : Track | t in (Entry & Exit)\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | some en: Entry | one ex: Exit | en in t.succs and ex in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome e:Entry | some x:Exit | one st: e.^succs | x in st\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | Exit in t.succs and Entry in t.succs \n}",
                    "{\n\t// The station has at least one entry and one exit\n\tlone e: Entry, x: Exit | e != x\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some Entry & Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tTrack =  (Entry + Exit)\n}",
                    "{\n some t : Track | \n    some e : Entry | e in t.succs and \n    some x : Exit | x in t.succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | all en: Entry, ex: Exit | en in t iff ex in t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all x: Track | some y: Entry | y in x.succs or x in Entry\n  \n  all x: Track | some y: Exit | y in x.succs or x in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome t:Track | Entry in t.*succs\n  \tsome t:Track | Exit in t.*succs\n}",
                    "{\n  // The station has at least one entry and one exit\n  // Tracks\n  all t: Track | Entry in t.*succs and Exit in t.*succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | one (t.^succs & Exit)\n  all t : Track | one (t.^succs & Entry)\n  \n\t\n}",
                    "{\n  // The station has at least one entry and one exit\n  // Tracks\n  all t: Track | Entry in t.*succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tone {e: Exit | e in Track}\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tone {e: Exit | one e.succs}\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tone {e: Exit | one e.succs}\n    one {e: Entry | one e.succs}\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tno {x: Entry | x = x}\n    some Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tsome t: Track | t.succs in Entry\n  \tsome t: Track | t.succs in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t: Track | t.succs in Entry + Exit\n  \t\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall s:Signal | s in Entry and s in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tsome Entry implies some Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone Entry implies some Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | some Exit & t.^succs and t in Entry.^succs  \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  (all e : Entry | some Exit & e.*succs) and (all e : Exit | some Entry & (*succs).e)\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n     some s : Track | Entry in s and Exit in s\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n     all s : Track | some ( s.^(succs) & Entry & Exit)\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t : Track | some en : Entry, ex : Exit | en in t.*succs and ex in t.*succs\n  \tall t : Track | t in Entry iff t not in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall t : Track | some en : Entry, ex : Exit | en in t.*succs and ex in t.*succs\n  \tall t : Track | t in Entry implies t not in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track | some en : Entry, ex : Exit | en not in t.*succs and ex not in t.*succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track | some en : Entry, ex : Exit | en not in t.^succs and ex not in t.^succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track, en : Entry, ex : Exit | en not in t.^succs and ex not in t.^succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track, en : Entry | en not in t and en not in t.^succs \n  \tall t : Track, ex : Exit  | ex not in t and ex not in t.^succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track, en : Entry, ex : Exit | en not in t and en not in t.^succs and ex not in t and ex not in t.^succs\n  \t\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \t\n\t\n  \tall t : Track, en : Entry, ex : Exit | !(en not in t and en not in t.^succs and ex not in t and ex not in t.^succs)\n  \t\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall e : Entry, j : Junction | some t : Track | e in t.*succs and e != j\n\tall e : Exit,  j : Junction | some t : Track | e in t.*succs and e != j\n}",
                    "{\n\tall t: Track |\n  \t\tsome en: Entry, e: Exit |\n  \t\t\ten in t.succs and e in t.succs and en != e\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome t: Track | some en: Entry, e: Exit | en in t.^succs and e in t.^succs\n}",
                    "{\n  // The station has at least one entry and one exit\n\tall t: Track |\n  \t\tsome en: Entry, e: Exit |\n  \t\t\t(t in Entry and e in t.^succs) or\n  \t\t\t(t in Exit and en in t.^succs)\n}",
                    "{\n  // The station has at least one entry and one exit\n\tall t: Track |\n  \t\tsome exe:Track |\n  \t\t\t(exe in Entry & t.^succs) or\n  \t\t\t(exe in Exit & t.^succs)\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | some (t.^succs+t & Entry) and some (t.^succs+t & Exit)\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | lone en: Entry, ex: Exit | en in t.^succs and ex in t.^succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | some en: Entry | one ex: Exit | en in t.^succs and ex in t.^succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | one en : Entry | one ex : Exit | t in en or t in ex\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | one en : Entry | one ex : Exit | t in succs.en or t in succs.ex\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t : Track | t.succs in (Entry & Exit)\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t : Track | t in Entry or t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tlone t : Track | t not in Junction\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t : Track | t in Entry \n\t\n}",
                    "{\n\tsome t : Track | t in Entry\n\tall t : Track | t not in Entry implies t in Exit\n\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tsome t : Track | t in Entry implies t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t : Track | t in Entry implies t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tlone t : Track | t in Entry implies t in Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tone t:Track | some e:Entry, ex:Exit | e in t and ex in t.succs\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n    lone (Entry + Exit)\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | t!=t.succs-Entry and t!=t.succs-Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | t not in Entry and t not in Exit and t!=t.succs-Entry and t!=t.succs-Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | (t in Entry or t in Exit) and t!=t.succs-Entry and t!=t.succs-Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | t in Entry implies some t.succs & Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some t&Entry and some t.succs&Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some t&Entry and some t.succs&Exit or some t&Exit and some t.succs&Entry\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t:Track | one e:Entry | one x:Exit | t in e.^succs or t=e and x in t.^succs or x=t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t:Track | one e:Entry | one x:Exit | (t in e.^succs or t=e) and (x in t.^succs or x=t)\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track |all suc:t.succs| some e:Exit | some et:Entry | e in t or e in suc and et in t or et in suc\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track |all suc:t.succs| some e:Exit | some et:Entry | (e in t or e in suc) and (et in t or et in suc)\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome e:Entry | some x:Exit | x in e.^succs or e=x\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some e : Entry | some x : Exit | (t + t.succs + t.^succs) in e and (t + t.succs + t.^succs) in x\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome t : Track | some e : Entry | some x : Exit | (t + t.succs + t.^succs) in e and (t + t.succs + t.^succs) in x\n}",
                    "{\n\t// The station has at least one entry and one exit\n  some en : Entry | en in Track\n  some ex : Entry | ex in Track \n  no e: Entry, ex: Exit | e = ex\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | some en : Entry | en in t\n  all t : Track | some ex : Entry | ex in t \n  no e: Entry, ex: Exit | e = ex\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | some j: Junction | some e: Exit | j in t.succs and e in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tone e: Entry, ex: Exit | e != ex\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some t => t in Entry and some t => t in Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t : Track | some t.^succs => t in Entry & Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n  \tall s: Signal | one s.~signals\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsuccs in Track one -> some Entry\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsuccs in Track one -> some Entry\n  \n  \tsuccs in Track one -> some Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all j : Junction | some e : Entry, exit : Exit | e in j.succs and exit in j.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | some e : Entry, exit : Exit, j : Junction | e in t.succs and exit in t.succs and j in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome Entry\n  \tsome Exit\n  \tno t: Track | t in Entry and t in Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t: Track | some e:Entry | e in t.succs\n  \t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tEntry in Track.succs\n  \tExit in Track.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  Track = Entry + Exit + Junction\n  \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n \tall t:Track | some en:Entry, ex:Exit | en in t or ex in t\n\n\n}",
                    "{\n  all disj t,t1 : Track | t in Entry and t1 in Exit\n\t\n}",
                    "{\n  all disj t,t1,t2 : Track |(t1 in t.succs and t2 in t.succs) and t in Entry and t1 in Exit \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall t: Track | all en: Entry, ex: Exit | en in t and ex in t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all x: Track | some y: Entry | y in x.succs or x = Entry\n  \n  all x: Track | some y: Exit | y in x.succs or x = Exit\n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tEntry != Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome t:Track | Entry in t.^succs\n  \tsome t:Track | Exit in t.^succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tsome t:Track | Entry in t.succs\n  \tsome t:Track | Exit in t.succs\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all t : Track | one (t.^succs & Exit)\n  all t : Track | one (t.^succs & Entry)\n  all t : Track | lone (t.^succs & Track)\n  \n\t\n}",
                    "{\n\t// The station has at least one entry and one exit\n  all i:Track | some disj x,y:Track | x in i.succs and y in i.succs implies x in Entry and y in Exit\n}",
                    "{\n\t// The station has at least one entry and one exit\n\tall tr: Track |\n  \t\tsome (tr.succs & Exit) and \n  \t\tsome (succs.tr & Entry)\n}"
                ]
            },
            {
                "description": "Signals belong to one track",
                "pred": "this/inv2",
                "oracle": "{\n\t// Signals belong to one track\n  all s: Signal | one t: Track | s in t.signals\n}",
                "erroneous": [
                    "{\n\t// Signals belong to one track\n\tall t1, t2 : Track | all s : Signal | s in t1.signals and s in t2.signals implies t1=t2\n}",
                    "{\n\t// Signals belong to one track\n\tall s : Signal | s in Track.signals\n}",
                    "{\n\t// Signals belong to one track\n  \tno disj t1, t2: Track | t1.signals in t2. signals\n\n}",
                    "{\n\t// Signals belong to one track\n\tall s : Signal | one t : Track | s in t\n}",
                    "{\n\t// Signals belong to one track\n\n}",
                    "{\n\t// Signals belong to one track\n\t\tone t: Track | all s:Signal | s in t.signals \n\n}",
                    "{\n\t// Signals belong to one track\n\tone(signals.Signal)\n}",
                    "{\n\t// Signals belong to one track\n\tall t : Track | all s : Signal | s in t.signals\n}",
                    "{\n\t// Signals belong to one track\n\tall t: Track | one signals.t\n}",
                    "{\n\t// Signals belong to one track\n  all t: Track | one t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  \tall t1, t2 : Track | no (t1.signals & t2.signals)\n}",
                    "{\n\t// Signals belong to one track\n  \tall t1,t2 : Track, s : Signal | (s in t1.signals or s in t1.^succs.signals) implies (s not in t2.signals or s not in t2.^succs.signals)\n\n}",
                    "{\n\t// Signals belong to one track\n\n\t#signals.Signal = 0 or #signals.Signal = 1\n\tSignal in Track.signals\n\n}",
                    "{\n\t// Signals belong to one track\n\tone(signals.Track)\n}",
                    "{\n\t// Signals belong to one track\n\tall s:Signal, t:Track | s -> t in signals\n}",
                    "{\n\t// Signals belong to one track\n\n#signals.Signal =1\n  Signal in Track.signals\n\n}",
                    "{\n\t// Signals belong to one track\n\tone t : Track | all s : Signal | s in t\n}",
                    "{\n\t// Signals belong to one track\n\tsome t : Track | all s : Signal | s in t.signals\n}",
                    "{\n\t// Signals belong to one track\n  all t : Track | no (t.signals & t.succs.signals)\n}",
                    "{\n\t// Signals belong to one track\n  \tno {s: Signal | #signals.s = 2}\n\n}",
                    "{\n\t// Signals belong to one track\n  all t : Track | lone sem : Semaphore, speed : Speed | sem in t.signals and speed in t.signals\n  \n\n}",
                    "{\n\t// Signals belong to one track\n  \tone signals.iden\n\n}",
                    "{\n\t// Signals belong to one track\n\tall t: Track | t.^signals not in t.^succs.signals \n}",
                    "{\n\t// Signals belong to one track\n\tall s: Signal | one Track\n}",
                    "{\n\t// Signals belong to one track\n  all s : Signal | one t : Track | s = t.signals\n  \n\n}",
                    "{\n\t// Signals belong to one track\n  \tno s:Signal| all t:Track| s not in t.signals\n\tno disj t1,t2:Track| t1.signals in t2.signals\n}",
                    "{\n\t// Signals belong to one track\n\tSignal in Track.signals\n  \tTrack in signals.Signal\n}",
                    "{\n\t// Signals belong to one track\n  \tall t : Track | some t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n\tsignals in ( Track -> lone Signal)\n}",
                    "{\n\t// Signals belong to one track\n\tsignals in ( Track lone-> some Signal)\n}",
                    "{\n\t// Signals belong to one track\n\tsignals in ( Track one -> some Signal)\n}",
                    "{\n\t// Signals belong to one track\n\tSignal = univ.signals\n  \tTrack = signals.univ\n    some Signal\n}",
                    "{\n\t// Signals belong to one track\n\tall t1: Track, t2: Track | some s: Signal | !(s in t1.signals && s in t2.signals)\n}",
                    "{\n\t// Signals belong to one track\n\tall s: Signal | one Track.signals\n}",
                    "{\n\t// Signals belong to one track\n\n\t#signals.Signal > 0 \n\tSignal in Track.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  \tall t1,t2 : Track, s : Signal | (s in t1.signals or s in t1.^succs.signals) implies (s not in t2.signals or s not in t2.^succs.signals)\n  \tall s : Signal | some t : Track | s in t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  \tall t1,t2 : Track, s : Signal | (s in t1.signals or s in t1.^succs.signals) implies (s not in t2.signals or s not in t2.^succs.signals)\n  \tsome s : Signal | some t : Track | s in t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  \tall t1,t2 : Track, s : Signal | s in t1.*signals and s in t2.*signals iff t1 = t2\n\n}",
                    "{\n\t// Signals belong to one track\n  all s:Signal | some disj t1,t2:Track | s in t1.signals implies s not in t2.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  some t:Track | t.signals=Signal and no (Track - t).signals \n\n}",
                    "{\n\t// Signals belong to one track\n\tall s : Signal | one t : Track | s in Track.signals\n}",
                    "{\n\t// Signals belong to one track\n\tall t: Track | t.signals not in t.succs.signals \n}",
                    "{\n\t// Signals belong to one track\n  \tone t: Track | all s: Signal | s = t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  \tone t: Track | all s: Signal | t.signals in s\n\n}",
                    "{\n\t// Signals belong to one track\n  one s: Signal | s in Track.signals\n\n}",
                    "{\n\t// Signals belong to one track\n    all s: Signal | one Track.succs\n\n\n}",
                    "{\n\t// Signals belong to one track\n  all t: Track | t.signals not in (Track - t).signals \n}",
                    "{\n\t// Signals belong to one track\n  one t:Track | all s:t.signals | s in t\n\n}",
                    "{\n\t// Signals belong to one track\n  one t:Track | all s:t.signals | s in t.signals\n\n}",
                    "{\n\t// Signals belong to one track\n  all t:Track | all s: Signal | s in t.signals or s in t.^succs.signals\n\n}",
                    "{\n  all s : Signal | all disj t, t1 : Track | s in t.signals and  (s not in t1.signals)\n\t// Signals belong to one track\n\n}",
                    "{\n\t// Signals belong to one track\n\tall t: Track, s: Signal | no (Signal - Track.signals) and s in t.signals implies s not in ((Track - t) <: Track).signals\n}",
                    "{\n\t// Signals belong to one track\n  \tall s:Signal| one t:Track| s in t.signals\n\tno disj t1,t2:Track| t1.signals in t2.signals\n}",
                    "{\n\t// Signals belong to one track\n\tone t:Track | one t.signals\n}"
                ]
            },
            {
                "description": "Exit tracks are those without successor",
                "pred": "this/inv3",
                "oracle": "{\n\t// Exit tracks are those without successor\n  \tall t : Track | t in Exit iff no t.succs\n\n}",
                "erroneous": [
                    "{\n  // Exit tracks are those without successor\n  all e: Exit | no e.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no t.succs implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e: Exit | no e.*succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno succs.Exit\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs or lone Track\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | no t.succs implies Exit in t \n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | no (t.succs-t) implies one (t & Exit)\n\n}",
                    "{\n\t// Exit tracks are those without successor\n    all t: Track | no t.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | Exit in t implies no t.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | (t not in t.succs) and (no t.succs implies t in Exit)\n}",
                    "{\n\t// Exit tracks are those without successor\n\tExit = Track - Track.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Exit | no(e.succs) and some(succs.e)\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | t in Exit and no t.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | Exit = t implies no t.succs\n\n}",
                    "{\n\t\n   \n  \tall t:Track | all t1:Track | t1 not in t.succs implies t in Exit  \n}",
                    "{\n    \n    all t: Track | no t.succs implies t in Exit-Junction-Entry\n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n  \t\n  \tno Exit.succs\n  \tsome (Track - Exit).succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | t not in t.*succs\n  all t : Track, e : Exit | e in t implies no t.succs\n  all t : Track, e : Entry, j : Junction | some e+j & t implies some t.succs\n  \n  \n  \n}",
                    "{\n\t\n   all t:Track | no succs.t implies t in Exit\n  \t\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno succs.Exit and no Exit.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | no t.succs implies Exit = t\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no t.succs iff t = Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track| some e : Exit | e in t implies no t.succs\n  \n  \n  \n  \n}",
                    "{\n\t\n   all t:Track | some t.succs implies t in Exit\n  \t\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track-Junction-Entry | no t.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t :Exit | no t & t.^succs\n\tall t :Track | no t.succs implies t in Exit and t in Exit implies no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno (succs.Exit)\n  \tsome (Exit.succs)\n  \n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Exit | lone t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Track | t in Exit implies no t.^succs and t not in Entry\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall tx, ty: Track |(tx != ty) and tx in Exit => ty not in tx.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | all tr : Track | (not tr in t.succs and not t in t.succs) implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tsome t: Exit | no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t:(Track-Exit), e:Exit | no (e.succs ) and some(t.succs)\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Exit | no t.succs\n  \tall t: Exit | (some succs.t) or (t in Exit and t in Entry)\n}",
                    "{\n\t// Exit tracks are those without successor\n    all t: Exit | no (t -> Track.succs)\n\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  no (Exit.succs) and  some(succs.Exit)\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t: Track | some t.succs => t in Exit and t not in Junction and t not in Entry\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tno Track.succs implies Track in Exit\n}",
                    "{\n  // Exit tracks are those without successor\n  all t: Track | no t.signals implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\n  \tall t:Track | t in Entry implies #t.succs =0\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | all tr : Track | not tr in t.succs implies t in Exit\n  \n  \tall t : Track | not t in t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tsome t : Track | t in Exit implies no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t:Track-Exit | some t.succs\n  all t:Track | not t in t.^(succs)\n}",
                    "{\n\t// Exit tracks are those without successor\n\tlone t: Exit | no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tone t: Exit | no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall ex : Exit | some t : Track | ex in t.*succs implies no ex.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \n  all t : Track, e : Exit | e in t implies no t.succs\n  all t : Track, e : Entry, j : Junction | some e+j & t implies some t.succs\n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Track | t in Exit implies no t.^succs and some e: Entry | e in *succs.t\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | all e : Exit | (no t.succs - t) implies e in t\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall disj t1, t2: Track | t2 not in t1.succs => t1 in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track, e : Exit | e in t iff no t.succs\n  \n  \n\n  \n  \n  \n\n  \n}",
                    "{\n\t// Exit tracks are those without successor\n\tTrack = Junction+Entry+Exit\n  \tall e:Exit | no e.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e: Exit, en: Entry|\n  \t\tno e.succs and e not in en\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t:Track | t not in t.succs\n\tall t:Track | t in Exit implies no t.succs \n  \tall t:Track | t not in t.^succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\n  \tTrack in Exit iff no Track.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall e : Entry | some(e.succs)\n\tall e : Exit | no(e.succs)\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno Exit.succs\n  \tExit not in succs.Track\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | t not in t.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | t not in t.succs and (some t.succs implies t not in Exit)\n\n}",
                    "{\n    \n    all t: Track | no t.succs implies t in Exit and t not in Entry\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t :Exit | no t & t.^succs\n\tall t :Track | no t.succs implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall et : Exit | Track not in et.succs \n}",
                    "{\n\t// Exit tracks are those without successor\n  all ex : Exit | no ex.succs and some Entry\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t:Track-Exit | some t.succs and t not in t.succs\n  \n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Exit | no t.succs & Entry\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Track - Exit | e.succs in e\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tExit = {t : Track | no succs} \n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Exit | some t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n  \t\n  \n  \tsome (Track - Exit).succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \n  all t: Track - Exit | some t.succs\n  \n  some (Track - Exit).succs\n\n}",
                    "{\n\t\n  \tall t:Track | (no t.succs or t.succs =t implies t in Exit)\n  \t\n\n}",
                    "{\n\t\n  \tall t:Track | (no t.succs or t in t.succs implies t in Exit)\n  \t\n\n}",
                    "{\n\t\n   all t:Track | one t.succs implies t in Exit\n  \t\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track - Exit | some t.succs and all e : Exit | no e.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Exit | (e not in Entry) implies no(e.succs) and some(succs.e)\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | t not in t.^succs\n  \tall ex : Exit | some t : Track | ex in t.*succs implies no ex.succs\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | Exit in t.signals implies no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t1, t2 : Track | (t2 in t1.succs and t2 in Exit) implies no t2.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t1, t2 : Track | (t1 in Entry and t2 in t1.succs and t2 in Exit) implies no t2.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | one e : Exit | e not in t implies some t.succs\n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | t not in t.succs\n  all t : Track, e : Exit | e not in t implies some t.succs\n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track | t not in t.succs\n  all t : Track, e : Exit | e in t implies no t.succs\n  all t : Track, e : Entry, j : Junction | some e+j & t implies some t.succs\n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n  \n  all t : Track, e : Exit | e in t implies no t.succs\n  all t : Track, e : Entry, j : Junction | (e in t or j in t) implies some t.succs\n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n  all t : Track| one e : Exit | e in t implies no t.succs\n  \n  \n  \n  \n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t :Track | t in Exit iff t.^succs not in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Track | t in Exit implies no t.succs and some Entry & ^succs.t\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno (succs.Exit & Exit.succs)\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tno (succs.Exit)\n  \tsome (Exit.succs)\n  \tno Exit.succs\n  \n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall x : Exit | all t : Track | x in t and no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall x : Exit | all t : Track | x in t and t not in t.succs implies no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t: Track | t not in Entry and no t.succs => t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no succs.t implies Exit in t \n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no succs.t iff Exit in t \n}",
                    "{\n\t// Exit tracks are those without successor\n  all t1,t2:Track | t1.^succs = t2\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\tno e : Exit | some e.succs\n  \tall t : Track | no t.succs implies t in Entry\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Exit-Junction-Entry | no t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n    \n  \t\n  \tExit = Track - Track.signals\n}",
                    "{\n\t// Exit tracks are those without successor\n\tTrack.succs != none implies Track in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Exit | no e.succs\n  \tno e: Exit | e in Entry + Junction\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Exit | no e.succs\n  \tno t: Track | t in Entry and t in Exit and t in Junction\n}",
                    "{\n\t// Exit tracks are those without successor\n\tTrack = Junction+Entry+Exit \n}",
                    "{\n\t// Exit tracks are those without successor\n\tTrack = Junction+Entry+Exit\n  \tall t:Track | t in Entry implies t.succs = none\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no tr : Track| tr in t.succs implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t:Track | t in Exit implies no t.succs \n  \tall t:Track | t not in t.^succs\n  \tsome succs.Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t:Track | t in Exit implies no t.succs \n  \tall t:Track | t not in t.^succs\n  \tsome Track-Exit implies some succs.Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no t.succs implies t = Exit\n  \tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs or Exit = Entry\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs or some Exit\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs or lone Track or some Exit & Entry\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | some (Track - Exit).succs or lone Track\n\t\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | no t.succs implies t in Exit and no Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  all e : Entry | no t : Track | e in t.succs\n\tall e : Exit | no e.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \n  \tall ex : Exit | no ex.succs\n  \n  \tall en: Entry | no {t: Track | t.succs = en}\n\n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n  \tsome t: Track | no t.succs implies t in Exit\n  \n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n   all t: Track | \n        (no t.succs implies t in Exit)\n\tall e:Exit | e not in e.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Track - Entry | no e.succs\n}",
                    "{\n    // Exit tracks are those without successor\n    all e: Exit | #e.succs = 0\n  \tall t: Track | #t.succs > 0\n}",
                    "{\n    // Exit tracks are those without successor\n  \tall t: Track | #t.succs > 0\n}",
                    "{\n    // Exit tracks are those without successor\n  \tall t: Track | #t.succs > 0 and t not in t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | t not in t.succs and some t.succs implies t in Exit\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tall t : Track | (t not in t.succs) and (no t.succs and t not in Exit)\n\n}",
                    "{\n    \n    all t: Track | no t.succs implies t in Track-Junction-Entry\n}",
                    "{\n    \n    all t: Track - Junction - Entry | no t.succs implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n  \n  some t : Track | t in Exit implies no t.*succs \n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all ex : Exit | no ex.^succs\n  some Entry\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all ex : Exit | no ex.*succs\n  some Entry\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all e : Exit | e in Track and Track.^succs not in Exit\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t:Track | t not in t.succs.succs\n  all t:Track-Exit | some t.succs \n  \n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t:Track-Exit | some t.succs - t - t.succs.succs\n  \n\n}",
                    "{\n\t// Exit tracks are those without successor\n  \tsome Track-Exit.succs\n\tno Exit.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall e : Exit, t : Track - Exit & Entry | t not in e.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t:Track| t in Exit implies t.succs = none\n  \tall t:Track| t in Entry implies (some tt:Track| t in tt.succs)\n  \t\n}",
                    "{\n\t// Exit tracks are those without successor\n\tExit not in Track.succs\n}",
                    "{\n\t// Exit tracks are those without successor\nall e : Track - Entry - Junction | no e.^succs and no e\n\n}",
                    "{\n\t// Exit tracks are those without successor\n  all t: Track | t in Exit implies t not in t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n  some t: Track | t in Exit implies t not in t.succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t : Track | t in Entry <=> no t.~succs\n}",
                    "{\n\t// Exit tracks are those without successor\n\t\n  all t:Track | no t.succs and no succs.t  implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Track | t not in t.^succs implies t in Exit\n}",
                    "{\n\t// Exit tracks are those without successor\n\tall t: Track | Track not in t.^succs implies t in Exit\n}"
                ]
            },
            {
                "description": "Entry tracks are those without predecessors",
                "pred": "this/inv4",
                "oracle": "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | no succs.t iff t in Entry\n}",
                "erroneous": [
                    "{\n  // Entry tracks are those without predecessors\n  all e: Entry | no succs.e\n}",
                    "{\n\t// Entry tracks are those without predecessors\nall t: Entry | no t.^succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t:Track | no succs.t implies t in Entry \n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t1,t2 :Track | t1 in Entry iff t1 not in t2.succs \n}",
                    "{\n\t// Entry tracks are those without predecessors\nall t: Entry | no t.*succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t != t2 and t not in t2.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t not in t2.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff no t.succs\n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t not in t.^succs and t not in t2.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track - t | t in Entry iff t not in t2.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall e : Entry , t:Track - e| e not in t.*succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track, r: Track - t | t not in r.succs <=> t in Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t : Track | all t1 : Track | t not in t1.succs => t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall disj t1, t2: Track | t1 not in t2.succs => t1 in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\n  \tall e: Entry | all t: Track | e not in t.succs\n  \tall t: Track - Exit | some t.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t:Track | no t.succs implies t in Entry\n\n}",
                    "{\n\t\n  \t\n  \t\n  \tall t1: Track, t2: Track | t1 != t2 and t1 in Entry iff t1 not in {t2.succs+t1.succs}\n  \t\n\t\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | all t2 : Track-t | t in Entry implies (not t in Track.succs and not t in t2.succs)\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t != t2 and t not in t2.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t != t2 and t not in t2.^succs implies t in Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n    all t: Entry | some t.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t in (Track - t).succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | (t not in t.^succs) <=> t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t in t.succs\n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | t not in Track.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tno (succs.Entry)\n \tall t: Track | no succs.Entry implies t in Entry\n  \n  \n  \n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \t\n\tall e: Entry, t: Track | e not in Exit and e not in t.^succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  all t: Track| all e: Entry| t in Entry iff no e.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry implies t in t.succs or no t.succs\n  \n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t in t.succs or no t.succs\n  \n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry implies t in t.succs\n\n}",
                    "{\n\t\n  \t\n  \t\n  \tall t: Track, t2: Track | t != t2 and t in Entry iff t not in t2.succs\n  \t\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\t\n  \tall t1, t2 : Track | t1 != t2 implies t1 in Entry iff t1 not in t2.succs and t1 not in t1.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n   all t:Track | t in Entry iff t not in t.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n    all t: Entry | some succs.t\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | lone(t&succs.t) iff t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall e: Track |\n  \t\te in Entry implies (some t: Track | e not in t.succs)\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t1 : Entry | no t2 : Track | t1 not in t2.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n    all en: Entry | no {t: Track | t.succs = en}\n\n}",
                    "{\n  \tall t: Track | t in Exit iff no t.succs\n\tEntry not in Track.succs\n\n}",
                    "{\n    // Entry tracks are those without predecessors\n    all t: Track | Entry not in t.succs\n}",
                    "{\n\t\n  \t\n  \t\n  \tall t1: Track, t2: Track | t1 in Entry iff t1 not in t2.succs+t1.succs\n  \t\n\t\n}",
                    "{\n\t// Entry tracks are those without predecessors\nall t: Track - Exit | some t.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tno t: Entry | t.succs & Entry != t.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Entry | no pre: Track - Entry | t in pre.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t in t.succs\n  no Entry.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  \n  all t: Track| all e: Entry| no e.succs implies t in Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t in t.succs\n  all t: Track| t in Entry iff no t.succs\n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff (t in t.succs or no t.succs)\n  \n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  all t: Track| t in Entry implies one t.succs\n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  all t: Track| t in Entry implies lone t.succs\n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  all t: Track| t in Entry iff lone t.succs\n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \n  all t: Track| t in Entry implies lone t.succs\n  no succs.Entry\n  \n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t:Track | some t.succs <=> t in Exit\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t:Track | some t.succs <=> t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Entry | no succs.t\n  \tall t: (Track - Entry) | some t.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | some t1 : Track | t in t1.succs => t not in Entry\n  \tall t : Track | some t1 : Track | t not in t1.succs => t in Entry\n}",
                    "{\n  \n    all t : Track | no(succs.t) => t in Entry \n  \tall t : Track | some(succs.t) => t not in Entry\n\t// Entry tracks are those without predecessors\n\tall disj t,t1 : Track | t in t1.succs => t not in Entry\n  \tall disj t,t1 : Track | t not in t1.succs => t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t1 : Track | no t2 : Track | t1 in Entry implies t1 not in t2.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\t(all t: Track - Exit | some succs.t) and no succs.Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | all succ: Track.^succs | t in Entry iff t not in succ\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | all succ: Track.^succs-t | t in Entry iff t not in succ\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | all succ: (Track-t).^succs | t in Entry iff t not in succ\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track | no t2: Track | t in Entry iff t != t2 and t in t2.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t != t2 and t not in t.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t not in t2.^succs implies t in Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t != t2 and t not in t.^succs and t not in t2.^succs implies t in Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track, t2: Track | t in Entry iff t != t2 and t not in t.^succs and t not in t2.^succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \t\n\tall e: Entry, t: Track | e not in t.^succs and e not in Exit and e not in Junction\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  no Entry.succs \n  some succs.Entry\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  some Entry.succs \n  no succs.Entry\n\n}",
                    "{\n\t\n  \t\n  \t\n  \tall t1: Track, t2: Track | t1 != t2 and t1 in Entry iff t1 not in t2.succs+t1.succs\n  \t\n\tall t1: Track | t1 in Entry iff all t2: Track | t1 not in t2.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | no t.succs & Entry and t not in Exit\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | t in Entry implies no t.succs & Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t:Track | t = Entry iff #(succs.t) = 0\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | (t.succs in Entry) implies (no t) else (some t)\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | all t2 : Track-t | all t2 : t.succs| t in Entry implies (not t in Track.succs and not t in t2.succs)\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | t in Entry implies t = Track\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | all e : Entry | e in t implies e not in (t.succs + t.^succs)\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | t in Entry <=> t.succs not in t\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all e: Entry | no succs.e\n  all t: Track | no succs.t implies Entry in t\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  Track.succs !in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t,tr: Track | not tr in t.succs implies t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all e : Entry | (one t : Track | t->e in succs)\n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t : Track - Entry | one t.succs\n  \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t: Track | (#succs.t > 1) iff t in Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff  #(Track - t).succs > 0 \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tEntry.succs = Track - Entry\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff  #(Track - t).succs = 0 \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t: Track | t in Entry iff t not in (Track - t).succs \n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t1,t2: Track | t1 != t2 and t1 in Entry and t1 not in t2.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t1: Track | some t2: Track | t2 not in Entry implies t2 in t1.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  no e: Entry | e in e.~succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n    \n   Track in Entry.*(succs)\n\n}",
                    "{\n\tEntry not in Track.succs\n\n}",
                    "{\n    // Entry tracks are those without predecessors\n    all t: Track | t in Entry iff t in Track.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tno succs.Entry\n  \tsome succs.(Track-Entry)\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tno succs.Entry\n  \tsome succs.(Track-Entry-Exit)\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  \tall t: Track - Exit | some t.succs\n  \tall e: Exit | no e.succs\n  \tall e: Entry | all t: Track | e not in t.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tone Exit\n  \tall e: Entry | all t: Track | e not in t.succs\n  \tall t: Track - Exit | some t.succs\n\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall e: Entry | no e.succs.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tone e: Entry | no succs.e\n}",
                    "{\n\t// Entry tracks are those without predecessors\nall disj t,e:Track-Exit | e in Entry implies e not in t.succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n  all t : Track-Exit, e : Entry | t->e not in succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n all e : Entry, t : Track | e in t.^succs\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall t : Track | no succs.t implies t in Entry\n  \tall t : Track | some (succs.t) implies t not in Exit\n}",
                    "{\n\t// Entry tracks are those without predecessors\n\tall e: Exit | no e.*succs\n\n}"
                ]
            },
            {
                "description": "Junctions are the tracks with more than one predecessor",
                "pred": "this/inv5",
                "oracle": "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | #(succs.t) > 1 <=> t in Junction\n}",
                "erroneous": [
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t\n  \tall t: Junction | #succs.t > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | some succs.t\n}",
                    "{\n    // Junctions are the tracks with more than one predecessor\n      all t:Track | some succs.t iff t in Junction\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | #(succs.t) > 1 => t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | #(t.succs) > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | t in Junction => some t2: Track | t in (t2.succs - t) and some t3: (t2.succs - t) | t in (t3.succs - t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some t2: Track | some t3: Track | t in Junction iff t in t2.^succs and t2 != t3 and t in t3.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n    all t: Track | #(~succs.t) > 1 <=> t in Junction\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j: Junction | some t: Track | j in t.succs.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  \n  all j: Junction | some s1,s2:Track -j  | j in s1.succs and j in s2.succs and not (s1=s2)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all j : Junction | some succs.j - j\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | t in Junction <=> some (Track.^succs - t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j: Junction | #(succs.j) > 1 and no j & succs.j\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | some t.succs implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj a, b, c: Track | a in (b.succs & c.succs) implies a in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some succs.t implies t in Junction \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Junction | some (Track.succs - t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome succs.Junction\n  \tall t: Track | #succs.t > 1 implies t in Junction\n  \n  \t\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t : Track | t in Junction iff t in Track.succs.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | some j.succs\n\tall t : Track | some t.succs implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome succs.Junction\n  \tall t: Track | some succs.t implies t in Junction\n  \n  \t\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | (t in Junction) implies some(succs.t)\n  \tall t: Track | t not in t.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Junction | #(t.^succs) > 1\n\t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) <=> (some t1, t2 : Track | t1 != t2 and t in t1.^succs and t in t2.^succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies some(t.succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | lone (succs.t) => t not in Junction\n  \tall t : Track | some(succs.t) => t in Junction\n }",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | (t in Junction) implies some(succs.t) and t not in ^succs.t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t : Track | (lone t1 : Track | t in t1.succs) iff t in Junction\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | some (succs.succs.t-t) implies t in Junction\n  \tall e : Junction | some (succs.succs.e-e)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj t1,t2 : Track | some (t1.succs&t2.succs) implies t1.succs in Junction\n  \t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j : Junction | some disj t,t2 : Track | j in t.succs&t2.succs\n  \tall disj t,t2,j : Track | j in t.succs&t2.succs implies j in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | t in Junction iff some succs.t-t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some disj t1,t2: Track | t in Junction iff (t1 in t2.succs and t in t1.succs and (t!=t1 or t!=t2))\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | some succs.j and j not in succs.j\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | #succs.j > 1 \n  \tall t : Track - Junction | #succs.t = 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome succs.Junction\n  \t\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track| t not in Junction implies lone succs.t\n  all j:Junction | some succs.j -j.^(succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  \tall t: Track | t not in t.succs\n  \tall e: Junction | some t1,t2: Track | e in t1.succs and e in t2.succs and \t\tnot(t1 = t2)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j: Track |\n  \t\tj in Track iff some t: Track | j in t.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some disj a, b: Track | t in (a.succs & b.succs) implies t in Junction else t not in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | all tr: Track | #(tr.^succs) > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some ts: Track-t | t in Junction iff ts in t.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some t2: Track | some t3: Track | t in Junction iff t != t2 and t in t2.^succs and t != t3 and t in t3.^succs and t2 != t3\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \t\n  \tall t: Track | #(t.^succs) > 1 implies t in Junction\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | t in Junction iff some t1,t2:Track | t1 in t.^succs and t2 in t.^succs and t1!=t2 \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | some disj t1,t2:Track | t in Junction iff t1!=t and t in t1.^succs and t2!=t and t in t2.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track-Entry-Exit | some(succs.t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  all j : Junction | all disj s1,s2 : Track | s1 in succs.j and s2 in succs.j\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j : Junction | all disj t1, t2 : Track | (j in t1.succs) and (j in t2.succs)\n  \tall j : Track - Junction | lone(j.succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j: Junction | some t: Track | j in t.succs.succs - t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t1, t2: Track | t1 in Junction => some t3: t2.succs | t1 in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t1 : Track | t1 in Junction iff all t2,t3 : Track | t1 in t2.succs and t1 in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome disj t1,t2 : Track | all j: Junction | t1+t2 in succs.j\n  \tall disj t1,t2 : Track | (t1.succs&t2.succs) in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n    all disj t1,t2 : Track | (t1.succs&t2.succs) in Junction\n  \tall j : Junction | some disj t1,t2 : Track | t1+t2 = succs.j \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j: Junction | some t: Track | j in (t.succs - j).succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | #(succs.t)>2 implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (#{t.succs}>1) implies t in Junction \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some t2,t3: Track| t in Junction iff \n  \t(t in t2.succs and t in t3.succs)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some disj t1,t2: Track | t in Junction iff (t1 in t2.succs and t in t1.succs and t!=t1 and t!=t2)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some t1,t2: Track | t in Junction iff (t1 in t2.succs and t in t1.succs and t!=t1 and t!=t2)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t : Track | #succs.t > 1 and t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | lone (succs.t) implies t not in Junction\n  \tall t : Junction | some t1, t2 : Track | t1 in t.^succs and t2 in t.^succs  \n}",
                    "{\n\t\n\tall t : Track | no(succs.t) => t in Junction\n  \tall t : Track | some(succs.t) => t  not in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track | t in Exit implies one succs.t  \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all e:Exit | one succs.e or no succs.e\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track| t not in Junction implies lone succs.t\n  all j:Junction | some succs.j\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tno t : Track | t in t.^succs\n\tall j : Junction | some disj t,t2 : Track | j in t.succs&t2.succs\n  \t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj a, b, c: Track | c in (b.succs & c.succs) implies c in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj a, b, c: Track | a in (b.succs & c.succs) implies a in Junction else a not in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some disj a, b: Track | t in (a.succs & b.succs) implies t in Junction \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some disj a, b: Track | t in (a.succs + b.succs) implies t in Junction else t not in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track {\n  \t\t(t in Junction) iff (\n      \tsome disj t1, t2: Track | t != t1 and t != t2 and t in t1.succs and t in t2.succs\n      )\n  }\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n    Junction = {x: Track | #{x: Track | x in univ.succs} > 1 }\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | all disj t1: Track, t2: Track | (t in t1.succs) and (t in t2.succs)\n  \t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome t: Track | t in Junction iff some t.~succs\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | some succs.t <=> t in Entry\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | some t.succs <=> t not in Exit\n\tall t:Track | some succs.t <=> t not in Entry\n\t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | all tr: Track | #(tr.succs) > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all j : Junction | some succs.j and Entry in (*succs).j and Exit in j.*succs\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  some Junction and all j : Junction | some disj s1,s2 : Track | s1 in succs.j and s2 in succs.j\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  (all t : Track - Junction, j : Junction | lone succs.t and some disj t1,t2 : Track | j in t1.succs and j in t2.succs) \n\n}",
                    "{\n\t\n \tall j: Junction | some j.succs & Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) <=> (some t1, t2 : Track | t1 != t2 and t in t1.^succs and t in t2.^succs and t not in t.^succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) <=> (some t1, t2 : Track | t1 != t2 and t in t1.^succs and t in t2.^succs and t1 not in t2.^succs and t2 not in t1.^succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies (some t1, t2 : Track | t1 != t2 and t in t1.^succs and t in t2.^succs and t1 not in t2.^succs and t2 not in t1.^succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies (some t1, t2 : Track | t in t1.^succs and t in t2.^succs and t1 not in t2.^succs and t2 not in t1.^succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tnot ( lone ( ^(succs).Junction) )\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j : Junction| not ( one ( ^(succs).j) )\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t(all t: Track - Entry| lone succs.t) and all j : Junction | some disj t1, t2 : Track | j in t1.succs and j in t2.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall x: Track | x in Junction iff (all disj y, z: Track | y in succs.x and z in succs.x)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some t2: Track | t in Junction iff t in t2.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | some t2: Track | one t3: Track | t in Junction iff t in t2.^succs and t in t3.^succs and t2 != t3\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome succs.Junction\n  \tall t: Track | (some succs.t and succs.t!= t )implies t in Junction\n  \n  \t\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome succs.Junction\n  \tall t: Track | (some succs.t and t not in succs.t) implies t in Junction\n  \n  \t\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | (t in Junction) implies some(succs.t)\n  \tall t: Track | t not in t.^succs\n  \tall t: (Track-Entry-Exit) | some(t.succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n    all t: Track | #(t.*succs) > 1 <=> t in Junction\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track | t in Junction iff t not in Entry or t not in Exit\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track | t in Junction iff t in Track.^succs and t not in Exit\n\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | t in Junction iff some t1,t2:Track | t1!=t and t in t1.^succs and t2!=t and t in t2.^succs and t1!=t2 \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | some disj t1,t2:Track | t in Junction iff t in t1.^succs and t2!=t1 and t in t2.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies some(succs.t)\n  \tall t : Track | t not in t.*succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | t in Junction and t not in Entry implies some(succs.t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track-Entry-Exit | some(succs.t) and t not in t.^succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies some(succs.t)\n  \tall t : Track | (t not in Junction) implies (t in Entry)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | (t in Junction) implies some(succs.t) and t not in Entry\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t: Track | t in Junction iff some( succs.t + t.succs)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t: Track | t in Junction iff (some succs.t and some t.succs)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | t in Junction => some t2: Track | t in t2.succs and some t3: t2.succs | t in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | t in Junction => one e: Entry | t in e.succs.*succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj t1, t2: Track | t1 in Junction <=> some t3: t2.succs | t1 in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj t1, t2: Track | t1 in Junction => some t3: t2.succs | t1 in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t1 : Track | t1 in Junction iff all t2,t3 : Track | t1 in t2.succs and t2 in t3.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Track | t in Entry <=> no succs.t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | no succs.succs.t implies t in Junction\n  \tall e : Entry | no succs.succs.e\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | some (succs.t-t) implies t in Junction\n  \tall e : Junction | some succs.e\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tno Junction\n\tall t : Track | some (succs.succs.t-t) implies t in Junction\n  \tall e : Junction | some (succs.succs.e-e)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall disj t1,t2 : Track | some (t1.succs&t2.succs) iff (t1.succs&t2.succs) in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | some disj t1,t2 : Track | t1+t2 = succs.j \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n    all t: Junction | some pred1, pred2: Track | pred1 != pred2 && t not in pred1.succs && t in pred2.succs\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | some t.succs and some t.succs.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | some j.~succs.~succs && not (j in j.~succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall j : Junction | (j.~succs = j.~succs - j) && not (one j.~succs)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall disj p1, p2, j : Track | j in p1.^succs and j in p2.^succs implies j in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j : Junction | some disj p1, p2 : Track | j not in j.^succs and j in p1.succs & p2.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j : Junction | some p1, p2 : Track | p1 = j and p2 != j and j in p1.succs and j in p2.succs\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \t#succs.Junction > 1\n\tall t : Track | #succs.t > 1 implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  all t : Track | (some succs.Junction) \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  all j : Junction | (some t:Track - Entry | t->j in succs) \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \n  all j : Junction | (some t:Track - Junction | t->j in succs) \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t : Track | t in Junction iff some succs.t and t not in ^succs.t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t1: Track | some t2: Track | t2 not in Entry and t1 in t2.succs implies t1 in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tsome Junction.succs\n\tall t : Track | some t.succs implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | all t2,t3: Track| t in Junction iff \n  \t(t in t2.succs and t in t3.succs)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | t in Junction iff Track.succs.succs != none\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some t1,t2: Track | t in Junction iff (t1 in t2.succs and t in t1.succs)\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track | some disj t1,t2: Track | t in Junction implies (t1 in t2.succs and t in t1.succs and (t!=t1 or t!=t2))\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all j: Junction | some s1,s2:Track | s1 in j.succs and s2 in j.succs and not (s1=s2)\n all j: Track - Junction | some s1,s2:Track | s1 in j.succs and s2 in j.succs and  (s1=s2)\n  \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \tall t: Track - Junction | one t.succs\n  \tall j: Junction | #(j.succs) > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j:Junction | some t1,t2:Track | t1.succs = t2 and t2.succs = j\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall j:Junction | some t1,t2:Track | t1 != t2 and t2 != j and t1.succs = t2 and t2.succs = j\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t: Track | t in Junction iff some t1,t2: Track | t1 != t2 and t2 in t1.succs and t in t2.succs\n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall disj j, t : Track | j in t.succs and j in (Track - j).succs implies j in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall disj j, t : Track | j in t.succs and j in (Track - j).succs implies j in Junction\n  \t\n  \tall j : Junction, t : Track | j in t.succs and j in (Track - j).succs \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t\n  \t\n  \tall j : Junction, t : Track | j in t.succs and j in (Track - j).succs \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t\n  \t\n  \tall j : Junction, t : Track | j in t.succs implies j in (Track - j).succs \n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tno e : Track-Entry-Junction | #e.~succs = 1\n  \tall e : Entry | #e.~succs = 0\n  \tall j : Junction | #j.succs > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tno e : Track-Entry-Junction | #e.~succs = 1\n  \tall e : Entry | #e.~succs = 0\n  \tall j : Junction | #j.~succs > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall e : Track-Entry-Junction | #e.~succs = 1\n  \tall e : Entry | #e.~succs = 0\n  \tall j : Junction | #j.succs > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t1,t2,t3: Track | (t2 in Junction) iff (t1.succs = t2) and (t2.succs=t3)\n\t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall disj t1,t2,t3: Track | (t2 in Junction) iff (t1.succs = t2) and (t2.succs=t3) \n\t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track-Junction-Entry | lone succs.t  \n\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  all t:Track| t not in Junction implies lone succs.t\n  all j:Junction | some succs.j - j\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n  \t\n  \tall j:Track | j in Junction iff \n  \t\t\tlet n = {t:Track | j in t.succs} | #n>2\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | t in Junction iff (some t1,t2:Track|t1.succs=t and t2.succs=t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\n  \tall t:Track | t in Junction iff (some disj t1,t2:Track | t1.succs=t and t2.succs=t)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\n  \tall disj t1,t2,t3:Track |(t1 in Junction iff t2.succs=t1 and t3.succs=t1)\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\n  \tall t:Track | some t1:Track | t in Junction iff t1.succs=t\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t#succs.Junction > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\t#succs.Track > 1\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t:Track | lone succs.t implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | some t.succs\n  \tand\n  \tall t: Track | some t.succs implies t in Junction\n}",
                    "{\n\t// Junctions are the tracks with more than one predecessor\n\tall t: Junction | some t.~succs and not one t.~succs\n  \tand\n  \tall t: Track | (some t.~succs and not one t.~succs) implies t in Junction\n}"
                ]
            },
            {
                "description": "Entry tracks must have a speed signal",
                "pred": "this/inv6",
                "oracle": "{\n\t// Entry tracks must have a speed signal\n  \tall t:Entry | some (t.signals & Speed)  \n\n}",
                "erroneous": [
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e: Entry | Speed in e.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e: Entry | one s: Speed | s in e.signals \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e : Entry | some e.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall entry: Entry | entry.signals in Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t:Track | some (t.signals&Speed)  \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  all s:Speed, t:Track | t in Entry implies s in t.*succs\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track, s: Signal| t in Entry implies t.signals in Signal\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e:Entry| some e.signals and e.signals in Speed \n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tsome Entry.signals & Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t:Track|all s:Signal| t in Entry => s in t.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all s: Signal, t:Track | t in Entry implies signals.s in Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall track: Entry | one track->Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all e : Track , s : Speed | e in Entry iff s in e.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tSpeed in Entry.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e : Entry | some Speed and Speed in e.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\t(all t: Track| t in Entry iff some t.signals)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e: Entry | some (e.signals & Semaphore)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n   all t : Track | one s : Speed | s in t.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \t\n  \tsignals in Entry -> Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Entry some -> Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Track | t in Entry <=> some (t.signals & Speed)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t: Track | t in Entry iff Speed in t.signals \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Track | some t.^succs.signals & Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Entry | some t.*succs.signals & Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t : Track | (some t.signals and t.signals in Speed)\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t : Track | (one t.signals and t.signals in Speed)\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all e : Entry | one s : Speed | e in s.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track, s: Speed | t in Entry iff (signals.s->t in signals)\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tEntry = {x: Track | Track.signals in Speed}\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e: Entry, s: Speed | s in e.signals implies all t: Track - Entry | s not in t.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\t(all t: Track| t in Entry and some t.signals)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall track: Entry | some track->Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all t : Track | some (t.signals & Speed) implies t in Entry \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Track | some s : t.signals |t in Entry implies s in Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t:Track|one s:Signal| t in Entry => s in t.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n    signals in Entry -> one Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e : Entry | Speed in e.signals or Speed in e.^succs.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e : Entry | one s : Speed | s in e.signals or s in e.^succs.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e : Entry | Signal in e.succs\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall e : Entry | one Speed and Speed in e.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all e : Entry | (one s : Signal | e->s in signals)\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t: Track | (Entry in t) iff Speed in t.signals\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Track some -> Signal\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Track one -> Signal\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Entry one -> Signal\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Entry some -> Signal\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  signals in Entry one -> Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t: Track | t in Entry and Speed in t.signals \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t: Track | one s: Speed |t in Entry implies s in t.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all x: Track | some s: Signal | s in x.signals \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e : Entry | all s : e.signals | e in Speed \n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall e: Entry | all s: Signal | s in e.signals and s in Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t:Track | t in Entry implies no (Speed & t.signals)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Entry | some t.^succs.signals & Speed\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t : Track | one t.signals iff t.signals in Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  \tall t : Entry | one t.signals and t.signals in Speed\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Track | one s : Signal | s in t.signals implies (t in Entry)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\tall t : Track | one s : Signal | s in t.signals implies (t in Entry and s in Speed)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all e:Entry, s:Signal, t:Track | e in Track implies s in t.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all s:Signal, t:Track | t in Entry iff s in t.signals\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n  all s:Signal, t:Track |  s in t.signals  implies t in Entry\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n  all s:Speed, e: Entry, t:Track | s in e.signals implies t in Entry \n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all s: Signal, t:Track | (t in Entry and s in Speed) implies some signals.s\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all s: Signal, t:Track | (t in Entry and s in Speed) implies one signals.s\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track, s: Speed | t in Entry iff (signals.s in t)\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track| t in Entry iff t.signals in Signal\n\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track, s: Signal| t in Entry implies (s in Speed or s in Semaphore)\n}",
                    "{\n\t// Entry tracks must have a speed signal\n\n\n  \n  all t:Track, s: Signal| t in Entry implies s in Speed\n}"
                ]
            },
            {
                "description": "The station has no cycles",
                "pred": "this/inv7",
                "oracle": "{\n\t// The station has no cycles\n\tall t: Track | t not in t.^succs\n\n}",
                "erroneous": [
                    "{\n\t// The station has no cycles\n  \tall t:Track | t not in t.*(succs) \n\n}",
                    "{\n\t// The station has no cycles\n  \tall t:Track | t not in t.succs \n\n}",
                    "{\n\t// The station has no cycles\n\t\n}",
                    "{\n\t// The station has no cycles\n\tall t1: Track, t2: Track | t2 not in t1.^succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | some t1:Track | t1 in t.succs => t not in t1.^succs\n}",
                    "{\n\t// The station has no cycles\n\tall t1, t2: Track | t1 in t2.succs implies (t1.succs.succs & t2.succs) = none\n}",
                    "{\n\t// The station has no cycles\n  \n  all t :  Track | not (t in Entry and t in Exit )\n\n}",
                    "{\n\t// The station has no cycles\n  \tno (Exit.succs & Entry)\n\tno (succs.Entry & Exit)\n\n}",
                    "{\n\t// The station has no cycles\n  \tTrack in Track.^succs\n\n}",
                    "{\n\t// The station has no cycles\n\tall t: Track | one e: Entry | one ex: Exit | e in t.^succs and ex in t.^succs\n}",
                    "{\n\t// The station has no cycles\n  \tTrack not in Track.^succs\n\n}",
                    "{\n\t// The station has no cycles\n\tall disj t1, t2 : Track | t1 not in t2.*succs iff t2 in t1.*succs \n}",
                    "{\n\t// The station has no cycles\n  \tTrack not in Track.*succs\n\n}",
                    "{\n\t// The station has no cycles\n\tall t : Exit | no t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall ex : Exit | no e : Entry | e in ex.^succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | t.^succs != t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | t.*succs != t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Entry | t not in t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Entry | t not in t.^succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | t not in t.succs\n  \tall t : Track | t in Entry.*succs\n}",
                    "{\n\t// The station has no cycles\n\tall t: Track | t in t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall e: Entry | no e.succs\n}",
                    "{\n\t// The station has no cycles\n  \n  all en:Entry,ex:Exit| ex not in succs.en and en not in ex.*succs\n\n}",
                    "{\n\t// The station has no cycles\n  \n  all en:Entry,ex:Exit| ex not in en.succs\n\n}",
                    "{\n\t// The station has no cycles\n  \n  all t:Track | Entry not in t.*(succs) \n\n}",
                    "{\n\t// The station has no cycles\n\tno disj t1, t2 : Track | t1 in t2.succs\n}",
                    "{\n\t// The station has no cycles\n\tall disj t1, t2: Track | t1 in t2.succs implies (t1.succs & t2.succs) = none\n}",
                    "{\n\t// The station has no cycles\n\tall disj t1, t2: Track | t1 in t2.succs iff (t1.succs & t2.succs) = none\n}",
                    "{\n\t// The station has no cycles\n\tall t1, t2: Track | t1 in t2.succs iff (t1.succs & t2.succs) = none\n}",
                    "{\n\t// The station has no cycles\n\tall t1, t2: Track | t1 in t2.succs implies (t1.succs & t2.succs) = none\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | not t.succs in t\n}",
                    "{\n\t// The station has no cycles\n\tall t: Track | one e: Entry | one ex: Exit | e in t.succs and ex in t.succs\n}",
                    "{\n\t// The station has no cycles\n\tall t: Track | one e: Entry | one ex: Exit | t != e and t != ex and e in t.^(succs) and ex in t.^(succs)\n}",
                    "{\n\t// The station has no cycles\n\tno t : Track-Entry-Exit | t in t.*succs\n}",
                    "{\n\t// The station has no cycles\n\tall t : Track | (t not in Exit and t not in Entry and t not in Junction)\n}",
                    "{\n\t// The station has no cycles\n  \tall e : Exit, en : Entry | (en.succs in e) and (succs.e in en)\n\n}"
                ]
            },
            {
                "description": "It should be possible to reach every exit from every entry",
                "pred": "this/inv8",
                "oracle": "{\n\t// It should be possible to reach every exit from every entry\n  \tall ex: Exit | all en: Entry | ex in en.*succs\n\n}",
                "erroneous": [
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall ex: Exit | all en: Entry | ex in en.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tExit in Entry.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall en: Entry, ex: Exit | ex in en.succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall e:Entry | e in Exit or (all ex:Exit | ex in e.^(succs)) \n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tExit in Entry.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all e : Entry | some (e.^(succs) & Exit)\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall e: Exit, ent: Entry | ent in e.^succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall e : Entry | all ex : Exit | (ex in e.^succs) and e != ex\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\t*succs in Entry -> Exit\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall en: Entry | one ex: Exit | ex in en.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall e: Entry, x: Exit | e->Track in x-> Track\n      \n            \n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all disj t1,t2:Track | t1 in Entry and t2 in Exit implies t2 in t1.succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \n  \tall en : Entry | some ex : Exit | ex in en.*succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tone Exit & Entry.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall t: Track | some ex : Exit | ex in t.^succs.signals\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all e: Exit , t: Track - Exit | t in Entry <=> e in t.*succs \n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \t\n  \tall ex : Exit | ex in Entry\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall ex: Exit|\n  \t\tall e: Entry | e in ex.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall e:Entry | all ex:Exit | e in e.^(succs)\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all entry : Entry, exit : Exit | some t : Track | entry + exit in t.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall exit: Exit, entry: Entry | exit in Entry or exit in entry.^succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tall en: Entry, ex: Exit | en in ex.^succs or ex in en.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  \tone en: Entry | all ex: Exit | ex in en.^succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall et: Entry | et.^succs = Exit\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall et: Entry | et.*succs = Exit\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall en: Entry | some ex : Exit | ex in en.^succs.signals\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all e: Exit , t: Track - Exit | t in Entry <=> e in t.succs \n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all e: Exit , t: Track - Exit | t in Entry => e in t.succs \n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall t : Track, e : Exit |\n  \t\te in t.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall t : Track, e : Exit |\n  \t\te in (t.*succs + *succs.t)\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tsome exits: Exit | all entrys: Entry | exits in entrys.^succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall ex: Exit|\n  \t\tsome e: Entry | e in ex.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall t: Track|\n  \t\tone e: Entry | one ex: Exit | e in t and ex in t\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all e: Entry | some ex: Exit | ex in e.succs\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall e1 : Entry | one e2 : Exit | e2 in e1.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall entry : Entry | all exit : Exit | entry != exit and exit in entry.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall entry : Entry | all exit : Exit | entry != exit and exit in entry.^succs\n\tall entry : Entry | all exit : Exit | entry = exit \n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall e: Exit| all en: Entry| en in e.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tall e : Entry | Exit in Entry.*succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tExit in Entry.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tExit in Track.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all ex: Exit, e: Entry | ex in e.succs iff (Exit not in Track and Entry not in Track)\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all ex: Exit, e: Entry | ex in e.succs \n  all t: Track | Entry in t and Exit in t iff no t.succs\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all ex: Exit, e: Entry | ex in e.succs or Entry in Exit\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  all ex: Exit, e: Entry | ex in e.succs\n  Entry in Exit\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n   Track in Entry.*(succs)\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n  Exit in Entry.*(succs)\n  all t:Track | t in Entry implies t not in Exit\n\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n\tsome (Exit & Entry.*succs)\n}",
                    "{\n\t// It should be possible to reach every exit from every entry\n    all en, ex: Track | en in Entry and ex in Exit implies ex in ex.^succs\n}"
                ]
            },
            {
                "description": "Tracks not followed by junctions do not have semaphores",
                "pred": "this/inv9",
                "oracle": "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t : Track | no (Junction&t.succs) implies no (Semaphore&t.signals)\n\n}",
                "erroneous": [
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t : Track | Junction not in t.succs implies Semaphore not in t.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction => no (Semaphore & t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track|all j :Junction| j not in t.succs implies no s:Semaphore| s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | no Junction & t.^succs => no t.signals & Semaphore\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | {\n      Junction in t.succs => Semaphore in t.signals\n      Junction not in t.succs => Semaphore not in t.signals\n    }\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | no (succs.t & Junction) implies no (Semaphore & t.signals)\n  \n  \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction|\n  \t\tj not in t.^succs implies (all s: t.signals | s not in Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | t.^succs not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \t\n\t\n  all t : Track| t.succs != none and some(t.succs & Junction) implies no(t.signals & Semaphore)\n}",
                    "{\n    // Tracks not followed by junctions do not have semaphores\n    all t: Track - Junction | no t.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n    all t: Track | no(t.succs & Junction) <=> no(t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, s: Semaphore | t.^succs not in Junction implies s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | Junction not in t.*succs => Semaphore not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | \n  \t\tno j: Junction | j in t.succs implies no s: Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track |  no t.signals & Semaphore => no Junction & t.succs\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t:Track | all t1: t.succs | t1 in Junction implies some (t1.signals & Semaphore) \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t: Track | no j: Junction | (j in t.succs or no t.succs) => no s: Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : (Track-Junction).succs | no t.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction | {\n      j in t.succs => Semaphore in t.signals\n      j not in t.succs => Semaphore not in t.signals\n    }\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | (t.succs not in Junction) implies no(t.signals & Semaphore)\n\tall t: Track | no(t.succs) implies no(t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | t not in Junction and no t.^succs & Junction implies no s : Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n    all t: Track - Junction | no t.signals -> Semaphore\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t: Track | (all s: Semaphore | s in t.signals) implies (t.succs in Junction)\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.^succs not in Junction implies no t.signals & Semaphore\n\n  \tall t:Track | no t.succs implies no t.signals & Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | Junction not in t.^succs => Semaphore not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction, s: Semaphore | j not in t.*succs => s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | some j:Junction | j not in t.succs => (no s : Semaphore | s in t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs in Junction implies one (t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction <=> no (t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t1, t2: Track, s : Signal - Semaphore| t2 in t1.^succs and t2 not in Junction implies t2->Speed in signals \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | all s:t.signals| t.succs not in Junction and t not in Junction implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | some j: Junction | {\n      j not in t.succs => Semaphore not in t.signals\n  \t}\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | some succs.t implies (succs.t not in Junction => no t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | Junction in t.succs => Semaphore in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | no t.succs & Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track| no t1:Track | t1 in Junction and t1 in t.*succs \n  \t\t\t\timplies (Semaphore & t.signals = none)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | no (succs.t & Junction) iff no (Semaphore & t.signals)\n  \n  \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n    no t: Junction | no s: Semaphore | t in s.signals\n\n}",
                    "{\n    // Tracks not followed by junctions do not have semaphores\n      all t:Track | all t1:t.succs | t1 not in Junction implies some (t1.signals & Semaphore)\n  \n  \t\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Entry | all t1: t.succs| t1 not in Junction => no (Semaphore & t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Entry | (all t1: t.succs| t1 not in Junction) => no (Semaphore & t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction | t.^succs not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | (t.succs not in Junction) or no(t.succs) implies no(t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track, j : Junction | t not in Junction and j not in t.^succs implies all s : Semaphore | s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track|all j:Junction| all s:Semaphore | j not in t.^succs => s not in t.succs.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t: Track | ((no t2: Track | t2 in t.succs) or (no j: Junction | j in t.succs)) => no s: Semaphore | s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t : Track, j : Junction | t.succs != j => no s : Semaphore | s in t.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | no Junction & t.^succs <=> no t.signals & Semaphore\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track |  no t.signals & Semaphore => no Junction & t.^succs\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | some s:t.signals, j:Junction | j in t.^succs implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track, j:Junction  | some s:t.signals| j not in t.^succs implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | all s:t.signals| t.^succs not in Junction and t not in Junction implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.^succs not in Junction implies t.signals not in Semaphore\n  all t:Track | no t.succs implies t.signals not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.^succs not in Junction implies no t.signals & Semaphore\n\n  \tall t:Track | no t.succs implies no t.signals & Semaphore\n  \tall t:Track | some s:t.signals | t.^succs in Junction implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track - Junction | not t.signals in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no j : t.succs | no s : t.signals| j in Junction and s in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n    all t: Track - Junction| no t.^signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | s in t.signals and j in t.succs implies t in Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (s in t.signals and j in t.succs ) implies t in Junction and s in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no t.succs and t not in Junction implies no (t.signals & Semaphore)\t\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | Semaphore in t.succs.signals & t.signals implies some t.succs & Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | Semaphore in t.succs.signals implies some t.succs & Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall j : Junction | Semaphore in (succs.j).signals \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction implies no t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | t not in Entry implies ((succs.t not in Junction) => (no t.signals))\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | Junction in t.succs implies Semaphore not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall disj x,y:Track| y not in Junction and x->y in succs implies no s:Semaphore| x->s in signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.signals in Semaphore <=> t.succs in Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.signals in Semaphore => t.*succs in Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t not in Junction.succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall t:Track-Junction, j:Junction | j->t in ^succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall disj t:Track | t not in Junction.^succs => no t.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track, s : Semaphore | t.*succs not in Junction implies s not in t.signals\n\n}",
                    "{\n    // Tracks not followed by junctions do not have semaphores\n      all t:Track | all t1:t.succs | t1 not in Junction implies no (t1.signals & Semaphore)\n  \n  \t\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs in Junction => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction and t not in t.succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction iff no t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.^succs not in Junction iff no t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.*succs not in Junction iff no t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall track: Track | Junction in track.succs implies all signal: track.signals | signal not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | no s: Semaphore | t.succs not in Junction implies s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | no s: Semaphore | t.succs not in Junction implies s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, s: Semaphore | t.^succs not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, s: Semaphore | t not in Junction or t.^succs not in Junction implies s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, s: Semaphore | t.succs not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | t not in Junction and t.succs not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction | t.succs != j implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n     all t: Track, j: Junction | no s: Semaphore | t in t.^succs and j in t.^succs implies s not in j.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: (Track-Entry-Exit) | (t.succs not in Junction) implies no(t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track|all j :Junction| j not in t.succs iff no s:Semaphore| s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track|all j :Junction| j not in t.succs iff all t1:Track | no s:Semaphore| s in t1.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t not in Junction and no t.succs & Junction implies no s : Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | no t.succs & Junction implies some t.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | (Junction not in t.succs or t in Entry and t in Exit) implies no(t.signals & Semaphore)\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall disj t1, t2 : Track | t2 in t1.succs and t2 not in Junction implies Semaphore not in t1.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall disj t1, t2 : Track | t2 in t1.succs and t2 not in Junction implies all s : Signal | s in Semaphore and s not in t1.signals\n  \n   \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall disj t1, t2 : Track | t2 in t1.succs and t2 not in Junction implies some s : Signal | s in Semaphore and s not in t1.signals\n  \n   all t : Track | no (t.succs & Junction) implies no (Semaphore & t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall disj t1, t2 : Track | t2 in t1.succs and t2 not in Junction implies no s : Signal | s in Semaphore and s not in t1.signals\n  \n   all t : Track | no (t.succs & Junction) implies no (Semaphore & t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction iff Semaphore not in t.signals\n}",
                    "{\n    // Tracks not followed by junctions do not have semaphores\n    all t: Track | no j: Junction | (j in t.^succs or no t.succs) => no s: Semaphore | s in t.signals\n}",
                    "{\n    // Tracks not followed by junctions do not have semaphores\n    all t: Track | no j: Junction | (j in t.*succs or no t.succs) => no s: Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs in Junction implies lone (t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t : Track, j : Junction | no t.succs & Junction => no s : Semaphore | s in t.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \t\n\tall t : Track, j : Junction | t.*succs != j => no s : Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \t\n\tall t : Track, j : Junction, suc : t.succs | suc != j => no s : Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | some t.signals & Semaphore => no Junction & t.^succs\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n    all t: Track - Junction, s: Semaphore | t in t.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall j:Junction | some t:Track | t in j.succs => no s:Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall j:Junction | all t:Track | t in j.succs => no s:Semaphore | s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction, s: Semaphore | {\n      j in t.succs => s in t.signals\n      j not in t.succs => s not in t.signals\n    }\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | {\n      Junction in t.^succs => Semaphore in t.signals\n      Junction not in t.^succs => Semaphore not in t.signals\n    }\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction {\n      \n      \n      t not in Junction.~succs => Semaphore not in t.signals\n    }\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | some j: Junction | no s: Semaphore {\n      j not in t.succs => s in t.signals\n  \t}\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction|\n  \t\tj not in t.^succs implies (some s: t.signals | s not in Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track, j: Junction|\n  \t\tt not in Entry and t not in Exit and j not in t.^succs implies (all s: t.signals | s not in Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no Semaphore & t.signals iff t.succs in Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tno t : Track | some t.succs & Junction implies some Semaphore & t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\n  all t : Track | t.succs in Junction iff t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\n  all t : Track, s:Signal | Track - Junction in t.^succs implies s not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\n  all t : Track, s:Signal | Track - Junction in t.^succs implies Semaphore not in (Track - Junction).signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\n  all t : Track - Junction, s:Signal | t in Track.^succs implies Semaphore not in (Track - Junction).signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t1, t2: Track, s : Signal | t2 in t1.^succs and t2 not in Junction implies t2->s in signals and s not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t1, t2: Track, s : Signal - Semaphore| t2 in t1.^succs and t2 not in Junction and t2->s in signals \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t1, t2: Track | Junction not in t1.^succs implies t1->Speed in signals \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : succs.Track - succs.Junction | no t.signals & Semaphore \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t in Junction implies t.succs.signals in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\t\n  all t : Track |(Semaphore & t.signals) = none iff Junction not in t.succs \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\t\n  all t : Track |(t.succs & Junction) = none iff Semaphore not in t.signals \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track, j:Junction| some s:t.signals | j in t.succs implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track, j:Junction| some s:t.signals | j in t.^succs implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track, j:Junction| some s:t.signals | j in t.*succs implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | some s:t.signals, j:Junction | j not in t.^succs implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | some s:t.signals| t.^succs not in Junction implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | all s:t.signals| (t.^succs & t) not in Junction implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | all s:t.signals| t.succs not in Junction or t not in Junction implies s not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\t\n  \tall t:Track | no t.succs implies t.signals not in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.*succs not in Junction implies no t.signals & Semaphore\n\n  \tall t:Track | no t.succs implies no t.signals & Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track | t.^succs not in Junction implies no t.signals & Semaphore\n\n  \tall t:Track | no t.succs implies no t.signals & Semaphore\n  \n  \tall t:Track | some s:t.signals | some (t.^succs & Junction) implies s in Semaphore\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | one j: Junction | j not in t.succs implies (Semaphore not in t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track| some j: Junction, s: Semaphore| j not in t.succs implies s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tsome t: Track| all j: Junction, s: Semaphore| j not in t.succs implies s not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | !(Junction in t.succs implies Semaphore in t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall t: Track | no j: Junction, s: Semaphore | j in t.succs implies s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall t: Track | no j: Junction| no s: Semaphore | j in t.succs implies s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all x: Track | Junction in x.succs iff x.signals & Semaphore = none \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track - Junction | no s : t.signals | not s in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | t.succs not in Junction implies no s : t.signals | s not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no j : t.succs | no s : t.signals| j in Junction implies s in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no j : t.succs | j in Junction implies not t.signals in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall j : Junction | no j.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (s in t.signals ) implies (t in Junction and s in Semaphore)\n  \n  \t\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all s: Signal | (s in t.signals ) implies (t in Junction and s in Semaphore)\n  \n  \t\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (j in t.succs ) implies (s in t.signals and t in Junction and s in Semaphore)\n  \n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (j in t.succs ) implies (s in j.signals and t in Junction and s in Semaphore)\n  \n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (j in t.succs ) implies (s in j.signals and s in Semaphore)\n  \n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (j not in t.succs ) implies (s in j.signals and s not in Semaphore)\n  \n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | all j: Junction | all s: Signal | (no t.succs ) implies (s in j.signals and s not in Semaphore)\n  \n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : succs.(Track-Junction) + Entry | no Semaphore & t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : succs.(Track-Junction) + Entry + Exit| no Semaphore & t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : succs.(Track-Junction) +  Exit| no Semaphore & t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | ( no t.succs and t in Entry or t in Exit) implies no (t.signals & Semaphore)\t\n  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track |all j : Junction | no (t.succs) implies no (t.signals & Semaphore)\t\n }",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | Semaphore in t.succs.signals  implies t.succs in Junction\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | some succs.t => (succs.t not in Junction and no t.signals)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | all j: Junction | (j not in succs.t) implies no (t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \n  all t : Track | t.succs not in Junction implies (t.succs).signals not in Semaphore \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tall t: Track | ( no ( t.succs & Junction ) ) implies no t.signals\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track-Exit | Junction not in t.succs implies Semaphore not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tno t: Track | \n        \n  \t\tJunction not in t.succs implies Semaphore not in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | t.succs in Junction => Speed not in t.signals  \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | Junction in t.succs => Speed not in t.signals  \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t : Track | Junction not in t.succs => Speed not in t.signals  \n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | some j: Junction |all s: Signal | j not in t.*(succs) and s in t.signals implies s not in Semaphore\n  \n  \t\n\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t,t1 : Track |( t1 not in t.succs and t1 not in Junction) implies no (t.signals & Semaphore)\t\n }",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t,t1 : Track | not (t1 in t.succs and t1 not in Junction) implies no (t.signals & Semaphore)\t\n }",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | not Semaphore in t.signals iff not Junction in succs.t \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | no s: Semaphore | not Junction in t.signals implies s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  all t: Track | no s: Semaphore | not Junction in t.succs implies s in t.signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall disj x,y:Track, s:Semaphore | y in Junction and x->y in succs implies x->s in signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall disj x,y:Track-Exit, s:Semaphore | y in Junction and x->y in succs implies x->s in signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall disj x,y:Track, s:Semaphore | y in Junction and x->y in succs implies x->s in signals else x->s not in signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\nall disj x,y:Track| y in Junction and x->y in succs implies no s:Semaphore| x->s in signals\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | some s : t.succs | s not in Junction implies t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | some s : t.succs | s not in Junction implies no (t.signals & Semaphore)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track, j:Junction | t->j in succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall t:Track, j:Junction | t->j in succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall t:Track, j:Junction | j->t in succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall t:Track-Junction, j:Junction | j->t in succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \t\n\tall t:Track-Junction, j:Junction | j->t in ^succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall disj t:Track, j:Junction | j->t in ^succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall disj t:Track, j:Junction | j->t not in ^succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall disj t:Track | t not in Junction.^succs => t.signals not in Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n  \tno Junction => no Semaphore\n\tall t:Track | t not in ^succs.Junction => no t.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track| no t1:Track | t1 in Junction and t1 in t.^succs \n  \t\t\t\timplies (Semaphore & t.signals = none)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track| no t1:Track | t1 in Junction and t1 in t.*succs \n  \t\t\t\tiff (Semaphore & t.signals = none)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t:Track| no t1:Track | t1 in Junction and t1 in t.succs \n  \t\t\t\timplies (Semaphore & t.signals = none)\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall j : Junction | some j.succs.signals & Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | some t.succs & Junction implies some t.succs.signals & Semaphore  \n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no (t.succs & Junction) implies no t.signals - Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t : Track | no (Junction & t.succs) => no Semaphore\n}",
                    "{\n\t// Tracks not followed by junctions do not have semaphores\n\tall t: Track | some j: Junction, s: Signal | j not in t.succs implies s not in t.signals\n}"
                ]
            },
            {
                "description": "Every track before a junction has a semaphore",
                "pred": "this/inv10",
                "oracle": "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | some (Junction&t.succs) implies some (Semaphore&t.signals)\n\n}",
                "erroneous": [
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t : Track | some(succs.t & Junction) implies some(t.signals & Semaphore)\n  \n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track, j: Junction {\n      j in t.succs => Semaphore in t.signals\n    }\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tsome succs.Junction.signals & Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track | some(t.succs & Junction) implies one(t.signals & Semaphore)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | (t.succs in Junction) => some (t.signals&Semaphore)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | some s: Semaphore | t.succs in Junction implies s in t.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\n  \n  \n  all x: Junction | not (Semaphore & succs.x.signals = none)\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | j in t.succs => some s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: (Junction.succs) | Semaphore in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction, s: Semaphore | (j in t.succs) implies (s in t.signals)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track | Junction in t.succs implies Semaphore in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all j : Junction | succs.j.signals in Semaphore\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | Junction in t.succs iff Semaphore in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | succs.t in Junction => some t.signals&Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t1,t2 : Track | t2 in t1.*succs and t2 in Junction implies some e:Semaphore| t1->e in signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | Junction in t.succs => some s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n    all t : Track | t.succs in Junction implies t.signals in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t1,t2 : Track | t2 in t1.^succs and t2 in Junction implies (some e:Semaphore| t1->e in signals)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | some s: Semaphore | some t.succs and t.succs in Junction implies s in t.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | some s: Semaphore | s in t.signals iff t.succs in Junction\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | one s: Semaphore | t.succs in Junction implies s in t.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \t\n  \tall t: Track | one j: t.succs | j in Junction implies some s: Semaphore | s in t.signals\n  \t\n  \t\n}",
                    "{\n\t// Every track before a junction has a semaphore\n    all t: Track | Junction in succs.t implies some s:t.signals | s in Semaphore\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | one j: Junction| j in t.succs => some s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | j in t.succs => one s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall j: Junction, s: Semaphore | some t: Track {\n      t in j.~succs => s in t.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track, s: Semaphore | some j: Junction | {\n      j in t.succs => s in t.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | one s: Semaphore | some j: Junction | {\n      j in t.succs => s in t.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | one s: Semaphore | (j in t.succs) implies (s in t.signals)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | {\n      j in t.succs => Semaphore in t.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all t : Track | (some succs.t & Junction) implies one Semaphore\n  \n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | all j: t.succs | some s: Semaphore | j in Junction implies s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | all j: t.succs | some s: t.signals | j in Junction implies s in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n   all t1, t2: Track | some  s1: t1.signals |\n        t2 in Junction and t2 in t1.succs \n            implies s1 in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all t: Track | some s: Semaphore | some (t.succs & Junction) implies s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track |(all j: Junction | t in j.succs) implies (all s: Semaphore | s in t.signals)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Junction.succs | one s: Semaphore| s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all x: Junction | some e:Semaphore |  e in succs.x\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\nall disj x,y:Track, s:Semaphore | y in Junction and x->y in succs implies x->s in signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall j: Junction| all jp: j.~succs| all t: Track| t in jp iff Semaphore in t.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | one s: Semaphore | s in t.signals iff t.succs in Junction\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall j: Junction | some s: Semaphore | s in j.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t : Track | some s : Semaphore| s in (succs.t).signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t: Track | t.^succs in Junction implies some s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t:Track | t.succs = Junction implies some t.signals & Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | Junction in t.succs => one s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | one j: Junction| j in t.succs => one s: Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | j in t.succs => some s: Semaphore | s in j.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track | t.succs in Junction implies lone (t.signals & Semaphore)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track | t.succs in Junction => one s : Semaphore | s in t.succs.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track, j : Junction | t.succs = j implies one s : Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track, j : Junction | t.succs = j implies some s : Semaphore | s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t : Track | succs.t in Junction => t.signals in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n    all t: Track - Junction, j: Junction | some pre: t.^succs & j | some s: Semaphore | s in pre.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Junction | some s: t.succs.signals | s in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Junction | t.succs in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tsome {t: Track | some t.succs & Junction }\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track, j: Junction {\n      j in t.succs => Semaphore in t.signals\n      j not in t.succs => Semaphore not in t.signals\n    }\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track, s: Semaphore | some j: Junction | {\n      j not in t.succs => s not in t.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall j: Junction, s: Semaphore, ta: Track | some t: Track {\n      t in j.~succs => s in ta.signals\n  \t}\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all t : Track, s : Signal | Junction->t in succs implies t->s in signals and s in Semaphore\n  \n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all t : Track, s : Signal | some succs.t & Junction implies t->s in signals and s in Semaphore\n  \n}",
                    "{\n\t// Every track before a junction has a semaphore\n\t\n  all t : Track | (no t.succs & Junction) implies no t.signals & Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | all j: t.succs | one s: Semaphore | j in Junction implies s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: t.succs | some s: t.signals | j in Junction implies s in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t : Entry |Junction in t.succs implies Semaphore in t.signals\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t: Entry | some t.succs & Junction implies some t.signals & Semaphore\n\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t1, t2:Track | t2 in Junction and t2 in t1.*succs \n  \t\timplies (t1.*succs - t2.*succs).signals in Semaphore\n\t\n}",
                    "{\n\t// Every track before a junction has a semaphore\n   all t1, t2: Track |\n        t2 in Junction and t2 in t1.*succs \n            implies all t: (t1.*succs - t2.*succs) | some t.signals & Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n   all t: Track | some  s: t.signals |\n        t in Junction and t in t.succs \n            implies s in Semaphore\n  \n  \n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | t in Junction.succs iff Semaphore in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tone t: Track | t in Junction.succs implies Semaphore in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track |one s: Semaphore| t in Junction.succs implies s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\nall t: Track | some j: Junction | t in j.succs implies some s: Semaphore | s in t.signals\n }",
                    "{\n\t// Every track before a junction has a semaphore\n\n  \n  \n  all x: Junction | \n    no (x.succs.signals & Semaphore) implies no x.succs\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | some j: Junction | (j in t.succs) => (t.signals in Semaphore)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \n  all t : Track | one succs.t & Junction implies some  t.signals & Semaphore \n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track | all j: Junction | all s: Signal | j in t.^(succs) and s in t.signals implies s in Semaphore\n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: Track |all j : Junction | all s: Signal | j in t.succs implies  (s in t.signals and s in Semaphore)\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t: Track | some s: Semaphore | Junction in succs.t implies s in t.signals\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t : Track | some (succs.t & Junction) implies some (t.signals & Semaphore) \n    all t : Track | no (t.succs & Junction) implies no (t.signals & Semaphore)\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  \tall t : Track | some (succs.t & Junction) implies some (succs.t.signals & Semaphore) \n}",
                    "{\n\t// Every track before a junction has a semaphore\n\tall t: (Junction.~succs) | t.signals & Semaphore = none\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t : Track | succs.t in Junction implies t in (t.signals & Semaphore)\n\n}",
                    "{\n\t// Every track before a junction has a semaphore\n  all t : Track |some s : Semaphore| succs.t in Junction implies s in t.signals\n\n}"
                ]
            }
        ]
    },
    {
        "example": "Courses",
        "model": "open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {}",
        "id": "iP5JL36afv5KbDKP6",
        "requirements": [
            {
                "description": "Only students can be enrolled in courses",
                "pred": "this/inv1",
                "oracle": "{\n\t// Only students can be enrolled in courses\n\tall p : Person | some p.enrolled implies p in Student\n}",
                "erroneous": [
                    "{\n\t// Only students can be enrolled in courses\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Professor | no p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p:Person | p.enrolled in Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p:Person |\n  \tp.enrolled in Course implies p in Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p : Person | p in Student implies some p.enrolled\n\t\n}",
                    "{\n\tall s : Student , c: Course | s in enrolled.c \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person|Student in p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n  all s : Student | some s.enrolled\n  all p : Professor | no p.enrolled\n\t\n}",
                    "{\n    all p : Person | (p in Student) iff (some p.enrolled)\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person, c : Course | p.enrolled in c implies p in Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tno (Professor-Student).enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some c:Course | c in p.enrolled implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person - Professor | \n  \t\tno p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p : Person | some c : p.enrolled & Course | p in Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  Person-Professor in enrolled.Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tall p: Person, c: Course | p in Student implies p.enrolled in c\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | all s : Student | enrolled.c in s\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tPerson.enrolled = Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall c: Course | c.grades in (Student -> Grade)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | some p.enrolled => p = Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p : Person | p.enrolled in Student.enrolled\n\t\n}",
                    "{\n  no p : Professor | p.enrolled in Course\n\t// Only students can be enrolled in courses\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some enrolled implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | some c : Course | p.enrolled in c implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tPerson - Professor in Course.enrolled  \n}",
                    "{\n\t// Only students can be enrolled in course\n  all s: Student, c: Course | s in c.enrolled\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | enrolled.c = Student\n \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | (some c : Course | p in enrolled.c) implies p in Student\n\n\tall p : Person | some (p.enrolled & Student)\n}",
                    "{\n\t\n  all s: Student, c: Course | s.enrolled = c\n\t\n}",
                    "{\n\t\n  all s: Student, c: Course | s.enrolled = c and #(s.teaches) = 0\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tStudent in Person\n  \tall s:Student| Person.enrolled = Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s: Student | all c: Course | c in s.enrolled and c not in s.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some c:Course |c in p.teaches implies c not in p.enrolled and c in p.enrolled and c not in p.teaches implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Professor, s : Student | s in enrolled.Course and not p in enrolled.Course\n\t\n}",
                    "{\n\t\n  all p: Professor, c: Course | p.enrolled not in c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person |\n  \t\tsome course:p.enrolled|\n  \t\t\tcourse in Course implies Student in p\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | no p.teaches implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  Person-Professor not in Course.enrolled \n}",
                    "{\n\t// Only students can be enrolled in courses\n  Person-Student not in enrolled.Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p: Person | (p in Student) implies (no p.enrolled)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p : Person | (Course in p.enrolled) implies (p in Student) \n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tsome s : Student |  some s.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | p in Student or no p.enrolled\n  \tsome s : Student | some s.enrolled\n  \tall p: Person | no p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | c.enrolled = Person - Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | enrolled.c not in Person - Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person |\n  \t\tone p.enrolled implies p in Student\n}",
                    "{\n\t\n all p: Person - Student, s: Person - Professor, c: Course | \n\t#(p.enrolled) = 0 and\n\t#(s.teaches) = 0 and\n\tno (p & s) and\n\ts.enrolled in c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Professor, s: Student, c: Course | \n  \t\tp != s and\n  \t\tp + s = Person and\n  \t\tno p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person-Professor, c : Course | p.enrolled in c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall x : Person | (all c : Course | x in c.enrolled )implies x in Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Person , c : Course | p.enrolled in c implies p in Student and p not in Professor\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n\tall p : Person , c : Course | p.teaches in c implies p not in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s: Student | some c: Course | c in s.enrolled and c not in s.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tsome Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s:Student | s.teaches = none\n}",
                    "{\n    // Only students can be enrolled in courses\n    all p: Person |\n        some c: p.enrolled |\n            c in Course implies Student in p and Professor not in p\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some p.enrolled implies p in Student else p in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | all p : Person | c in p.enrolled implies p in Student and p not in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p:Person |\n  \tp.enrolled in Course implies p in Student and p not in Professor\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Professor | no p.enrolled\n  all s: Student | s in s.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  Person-Student not in Person.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | p.enrolled in p implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s : Student |  Person in s implies (some s.enrolled)\n\t\n}",
                    "{\n    \n    all p: Person | (p in Professor implies no p.enrolled)\n    \n    \n    all p: Person | (p in Student implies no p.teaches)\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | enrolled.c not in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | enrolled.c = Person\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | Person-Student not in enrolled.c\n \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | Person-Professor in enrolled.c\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall pe: Person| pe.teaches&pe.enrolled=none\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | (p in Student) iff (p.enrolled != none) and (not some p1: Professor| p1.enrolled!=none)\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n    all p : Person, c : Course | p in Student and p in c.enrolled\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall t : Person & Professor, p : Person | no t.enrolled and no p.enrolled \n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p:Person | all c:Course | p.enrolled in c iff p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall c: Course | c.grades in (Student some -> Grade)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | (some c : Course | some c.grades[p]) iff (p in Student)\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | Professor not in enrolled.c\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | Student in enrolled.c and Person not in enrolled.c\n}",
                    "{\n\t\n  all s: Student, c: Course | s.enrolled = c and no teaches\n\t\n}",
                    "{\n\t\n  all s: Person - Professor, c: Course | s.enrolled = c\n\t\n}",
                    "{\n\t\nall p: Person  | \n\tp in Student and\n\t#(p.enrolled) != 0 and\n\t#(p.teaches) = 0 \n\t\n}",
                    "{\n\t\n all p: Professor , s: Student, c: Course | \n\t#(p.enrolled) = 0 and\n\t#(s.teaches) = 0 and\n\tno (p & s) and\n\ts.enrolled in c\n\t\n}",
                    "{\n\t\nall disj p,s : Person |\n\tp!=s and\n\tp in Professor and\n\ts in Student and\n\t#(p.enrolled) = 0 and\n\t#(s.teaches) = 0 \n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person - Professor, s: Person - Student, c: Course | \n  \t\tno p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | \n  \t\tno p.enrolled and\n  \t\tp in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person, c : Course | p.enrolled in c implies p in Student and p.teaches not in c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Person-Professor, c : Course | p.enrolled in c and p.teaches not in c\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | some c : Course | p.enrolled in c implies (p in Student and not p in Professor)\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s:Person, c:Course | s in Professor and s not in enrolled.c\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s:Person, c:Course | s in Professor implies s not in enrolled.c and s in Student implies s in enrolled.c \n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tall p: Person, c: Course | p = Student implies p.enrolled in c\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n   all p : Person | p in enrolled.Course \n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | (p in Student) => (p.enrolled = p.teaches)\n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tall p: Person, c: Course | p in Student and p.enrolled in c\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tall p: Person, c: Course | p in Student and p.enrolled in c implies p not in Professor\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tall p: Person, c: Course | p in Student and p.enrolled in c and p not in Professor\n  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s: Student | s.enrolled = s.teaches\n    all p: Professor | p.enrolled = none\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Person , c : Course | some p : Person | p.enrolled in c implies p in Student\n  \tall p : Person | (some c : Course | p->c in enrolled) implies p in Student\n\tall p : Person , c : Course | p in enrolled.c implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Person , c : Course | some p : Person | p.enrolled in c implies p in Student\n  \t\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n  all p : Professor, s : Student | s in p.enrolled and not p in s.enrolled\n  \n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n  all s : Student, c : Course | s in enrolled.c\n  all p : Professor, c : Course | p not in enrolled.c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n  all s : Student, c : Course | some s.enrolled\n  all p : Professor, c : Course | p not in enrolled.c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\n\t\n\n\t\n\n        teaches in Student -> Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s: Student | all c: Course | c in s.enrolled and c in s.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s: Student |some c: Course | c in s.enrolled and c in s.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person-Professor | some enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s : Student | Person.enrolled != Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tStudent in Person\n  \tall s:Student| Student.enrolled = Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s:Student | Person.enrolled = Course && Person.teaches = none\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tno enrolled.Course & Professor and Student = enrolled.Course\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Professor | some c:Course | c in p.enrolled iff c not in p.teaches \n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some c:Course | c in p.enrolled iff c not in p.teaches \n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | some c:Course | c in p.enrolled and c not in p.teaches implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | p.teaches not in p.enrolled and p.enrolled in Course implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person |\n  \t\tone course:p.enrolled|\n  \t\t\tcourse in Course implies Student in p\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person |\n  \t\tone course:p.enrolled|\n        \tcourse in Course implies Professor not in p\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p:Person |\n  \t\tsome c:p.enrolled|\n        \tc in Course implies Professor not in p\t\n}",
                    "{\n    // Only students can be enrolled in courses\n    all p: Person |\n        some c: p.enrolled |\n            c in Course implies p in Student and p not in Professor\n}",
                    "{\n    // Only students can be enrolled in courses\n    all p: Person |\n        one c: p.enrolled |\n            c in Course implies p in Student \n}",
                    "{\n\t// Only students can be enrolled in courses\n  Course in Student.enrolled\n  Course not in Professor.enrolled\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course, p: Person | (p - Professor) not in c.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tno (Professor-Student).enrolled\n  \n\tno (Student-Professor).teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n    all p : Person, c : Course | p in Student and p in enrolled.c\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n    all p : Person, c : Course | p in Student and p.enrolled in Course\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\n\t\n\n\t\n\n        \n   \n  all p : Person | p in Professor implies p not in Student\n  no Professor.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tno p: Professor | all c: Course | p in c.enrolled\n  \n  \t\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tno p: Professor | all c: Course | c in p.enrolled\n  \n  \t\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | some c: Course | c in p.enrolled => p = Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | some c: Course | c in p.enrolled => p in Student and p not in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | some c: Course | c in p.enrolled => p in Student and c not in p.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p : Student, c : Course | c in p.enrolled implies c not in p.teaches\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tsome (Person-Professor).enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\t\n  \tno p : Professor | all c : Course | some p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all p : Person | lone p.enrolled\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Professor | not one p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall s : Student, p : Professor, c : Course | s -> c in enrolled and not(p -> c in enrolled)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person - Professor | no p.teaches\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  Person-Professor not in enrolled.Course\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tno Professor . enrolled - Student . enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all e : Person.enrolled | Professor not in e\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all e : Person.projects | Professor not in e\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | all p : Person | enrolled.c in p && p in Student \n}",
                    "{\n    \n    all p : Person | \n        (p in Professor implies all c : p.enrolled | c in p.teaches)\n}",
                    "{\n  all s : Student | some s.enrolled and no s.teaches\n\t// Only students can be enrolled in courses\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall  p: Person | Student in p implies (some p.enrolled)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\n\t\n\n  \n   all p : Person | \n        (p in Student) => some p.enrolled and\n        (p in Professor) => no p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Professor | p.enrolled = p.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s: Student | one c: Course | s in enrolled.c \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall s: Student | one c: Course | enrolled.c in s \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | #p.enrolled > 1 implies p in Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall x: Person | x.enrolled in Course and x = Student\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | c.grades.Grade = Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c: Course | all p: c.grades.Grade | p = Student\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tlone s : Student | s.enrolled = Person.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \tall p: Person | (p in Student <=> some p.enrolled and no p.teaches)\n\t\n}",
                    "{\n\t// Only students can be enrolled in courses\n  \t\n  \tsome s : Student | some s.enrolled\n  \tall p: Professor | no p.enrolled\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all s: Student | some s.enrolled\n  all p: Professor | no p.enrolled and some p.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n  all s: Student | some s.enrolled and no s.teaches\n  all p: Professor | no p.enrolled and some p.teaches\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Person | #p.enrolled > 0 iff p in Student and p not in Professor  \n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall c : Course | enrolled.c = Person-Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p : Person | some c : p.enrolled | not p in Professor\n}",
                    "{\n\t// Only students can be enrolled in courses\n\tall p: Professor, s: Student, c: Course| p !=s and c not in p.enrolled\n}"
                ]
            },
            {
                "description": "Only professors can teach courses",
                "pred": "this/inv2",
                "oracle": "{\n\t// Only professors can teach courses\n    all p : Person | some p.teaches implies p in Professor\n}",
                "erroneous": [
                    "{\n\t// Only professors can teach courses\n\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Person | some p.teaches implies p in Student\n}",
                    "{\n\t// Only professors can teach courses\n    all c : Course | c in  Professor.teaches \n   \n  \t\n\n}",
                    "{\n\t// Only professors can teach courses\n  all p: Person | p.teaches in Professor\n}",
                    "{\n\t// Only professors can teach courses\n  \tall p: Person | p in Professor implies (some p.teaches)\n\n}",
                    "{\n\t// Only professors can teach courses\n\tno (Person - Professor).enrolled\n}",
                    "{\n\t// Only professors can teach courses\n\tall p: Person | p.teaches in Course iff p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Person | some c : Course | p.teaches in c implies p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n\tall p :Person|all c:Course|p.teaches in c implies p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Person | some c : Course | p in teaches.c implies p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n  all p : Person | some c: Course| p not in Professor implies c not in c.teaches\n}",
                    "{\n\t// Only professors can teach courses\n  all teachers : Person.teaches | Student not in teachers\n\n}",
                    "{\n\t// Only professors can teach courses\n  \tall p: Person | (some c : Course | c in p.teaches) <=> p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n\tPerson -> Person.teaches in Professor -> Course\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Professor | p not in Student implies p.teaches != none\n  \tall pe: Person | pe not in Student implies pe.teaches != none\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Professor | p not in Student implies p.teaches != none\n\n}",
                    "{\n\t// Only professors can teach courses\n  all p : Person | some p.teaches implies Professor in p\n\n}",
                    "{\n\t// Only professors can teach courses\n\tall c: Course | Student not in teaches.c\n}",
                    "{\n\t// Only professors can teach courses\n  all p:Person |\n  \tsome t:p.teaches |\n  \t\tt in Course implies p in Professor\n\n}",
                    "{\n\t// Only professors can teach courses\n  \tall p: Person-Professor | some c: Course | c not in p.teaches\n}",
                    "{\n\t// Only professors can teach courses\n\tno (Student-Professor).teaches\n}",
                    "{\n\t// Only professors can teach courses\n\tall p :Person|(all c:Course|p.teaches in c) implies p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n  all p : Person | some c: Course| c not in p.teaches implies p not in Professor\n}",
                    "{\n\t// Only professors can teach courses\n  all p : Person | some c: Course| p not in Professor implies (p.teaches = none)\n}",
                    "{\n\t// Only professors can teach courses\n   no p: Person | p in Student and p in Professor\n \n\n}",
                    "{\n\t// Only professors can teach courses\n\t\n\t\n\n       Professor in Course.teaches\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Person | no p.enrolled implies p in Professor\n}",
                    "{\n\t// Only professors can teach courses\n\t\n  \tall p : Person - Professor | some p.teaches\n \n}",
                    "{\n\t// Only professors can teach courses\n  \tall p: Person | one  Professor implies (some p.teaches)\n\n}",
                    "{\n\t// Only professors can teach courses\n  \tall disj p, p1: Person| (p in Professor) iff (p.teaches!= none) and (p1 not in Professor) iff (p1.teaches!=none)\n\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Professor | p not in Student implies p.teaches != none\n  \tall pe: Person | pe in Student implies pe.teaches = none\n}",
                    "{\n\t// Only professors can teach courses\n\tall p : Professor | p not in Student implies p.teaches != none\n  \tall pe: Person | pe.teaches = none\n}",
                    "{\n\t// Only professors can teach courses\n\tall p: Person, c: Course | c in p.teaches iff p in Professor\n}"
                ]
            },
            {
                "description": "Courses must have teachers",
                "pred": "this/inv3",
                "oracle": "{\n\t// Courses must have teachers\n    all c: Course | some teaches.c\n}",
                "erroneous": [
                    "{\n\t// Courses must have teachers\n\n\tall c : Course | some c.teaches\n}",
                    "{\n\t// Courses must have teachers\n\n}",
                    "{\n\t// Courses must have teachers\n\tall c:Course , p:Professor |\n  \t\tc in p.teaches\n}",
                    "{\n\t// Courses must have teachers\n    some teaches.Course\n}",
                    "{\n\t// Courses must have teachers\n\t\n    all course : Course | teaches.course in Professor\n}",
                    "{\n\t// Courses must have teachers\n  all c: Course | one teaches.c\n\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | all p : Person | c in p.teaches\n}",
                    "{\n\t// Courses must have teachers\n  \tsome p : Professor | all c : Course | c in p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n\tsome p : Professor  | p in teaches.Course\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some p : Professor | p.teaches in c\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some p : Person | (p in teaches.c) implies (p in Professor)\n}",
                    "{\n\t// Courses must have teachers\n  some Course.teaches \n}",
                    "{\n\t// Courses must have teachers\n  no teaches.Course\n\n}",
                    "{\n\t// Courses must have teachers\n  all c: Course | c.grades = Professor -> Grade\n}",
                    "{\n\t// Courses must have teachers\n  \tall p: Professor | some p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n  \tall c : Course | some p : Professor | p.teaches=c\n\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | lone teaches.c\n  \n}",
                    "{\n\t// Courses must have teachers\n  \tall c: Course | one pf: Professor | c in pf.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n\t\n  \tone teaches.Course\n}",
                    "{\n\t// Courses must have teachers\n  \tall c : Course | (all p : Professor | p.teaches in c)\n\n}",
                    "{\n\t// Courses must have teachers\n\tall p: Person | some p -> Course implies p in Professor\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | (some p : Person | p.teaches = c)\n}",
                    "{\n\t// Courses must have teachers\n  all p : Person | some p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n\t\n  \t\n  \tteaches in Professor -> some Course\n}",
                    "{\n\t// Courses must have teachers\n\tsome p : Person | all c : Course | c in p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some t : (Person - Student) | c in t.teaches\n}",
                    "{\n\t// Courses must have teachers\n  \t\n  \tsome p : Professor | all c : Course |\n  \tp in p.teaches\n  \t\n\n}",
                    "{\n\t// Courses must have teachers\n  all x : Course | no teaches.x & Professor \n\n}",
                    "{\n\t// Courses must have teachers\n  all c:Course | some p:Person | p.teaches in c\n\n}",
                    "{\n\t// Courses must have teachers\n  all c: Course | #(c.grades[Person]) >= 1\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | c.grades[Person] = Professor\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | some p: Person | p in Professor => c in p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some Professor -> c\n  \n\t\n  \n}",
                    "{\n\t// Courses must have teachers\n  \tteaches in Professor one -> Course\n}",
                    "{\n\t// Courses must have teachers\n  all c: Course | teaches in Professor -> c\n\n}",
                    "{\n\t// Courses must have teachers\n\tsome p : Professor | p.teaches in Course\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | some p: Person | (p.teaches = c) implies (p in Professor)\n}",
                    "{\n\t// Courses must have teachers\n  all c : Course | some p : Professor | p in teaches.c\n  all c : Course | some p : Professor | p.teaches in c\n  \n\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some p : Person | some p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | all t : (Person - Student) | c in t.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tsome p : Professor  | p in enrolled.Course\n}",
                    "{\n\t// Courses must have teachers\n  \tall c : Course | (one p : Professor | p.teaches in c)\n\n}",
                    "{\n\t// Courses must have teachers\n  \tall p : Person, c : Course | c in Professor\n\n}",
                    "{\n\t// Courses must have teachers\n\tall p : Person | p in Professor and some p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | one p: Person | p in Professor => c in p.teaches\n}",
                    "{\n\t\n\tall c : Course | some p : Student | p->c in teaches\n\n}",
                    "{\n\t// Courses must have teachers\n  all c : Course | all p : c.projects | p.teaches != none\n\n}",
                    "{\n\t// Courses must have teachers\n\tall x: Course, y: Person-Student | lone(y.teaches)\n}",
                    "{\n\t// Courses must have teachers\n\tPerson-Student in Course.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall x : Course , y : Person - Professor | some(y.teaches)\n}",
                    "{\n\t// Courses must have teachers\n\tall x : Course , y : Person - Professor | some(teaches.x)\n}",
                    "{\n\t// Courses must have teachers\n\tall x : Course , y : Person - Professor | one(y.teaches)\n}",
                    "{\n\t// Courses must have teachers\n\tall x: Person-Student, y: Course | no(x.teaches)\n}",
                    "{\n\t// Courses must have teachers\n  all x : Course | all y : Person - Student | some(teaches.x)\n\n}",
                    "{\n\t// Courses must have teachers\n  all x : Course | all y : Person - Student | some(x.teaches)\n\n}",
                    "{\n\t// Courses must have teachers\n  \tlone p : Professor | lone t : p.teaches | t in Course\n\n}",
                    "{\n\t// Courses must have teachers\n  \tall p : Person | lone t : p.teaches | t in Course\n\n}",
                    "{\n\t\n\t all p : Person, c: Course | one teaches.c implies one p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | some enrolled.c\n}",
                    "{\n\t// Courses must have teachers\n  all p : Professor | one c: Course | c in p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n  all p : Person-Student | one c: Course | c in p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n  all p : Person-Student | some c: Course | c in p.teaches\n\n}",
                    "{\n\t// Courses must have teachers\n  all c: Course | some p: Person | p in teaches.c\n  \n  all c: Course, p: Professor | p in teaches.c\n}",
                    "{\n\t// Courses must have teachers\n\t\n\tall p: Project | some (p & (Course + Professor))\n}",
                    "{\n\t// Courses must have teachers\n\t\n\tall p: Project | some (Course + Professor)\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | all p: Professor | c in p.teaches and c not in p.enrolled \n}",
                    "{\n\t// Courses must have teachers\n\tall c : Course | some p : Person - Professor | c in p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | one p: Professor | p.teaches = c\n}",
                    "{\n\t// Courses must have teachers\n  \tall c: Course | some teaches.c\n  \tsome teaches.Course\n}",
                    "{\n\t// Courses must have teachers\n  \tall p: Person, c: Course | p.teaches in c iff p in Professor\n}",
                    "{\n\t// Courses must have teachers\n  \tall p: Person, c: Course | p.teaches in c implies p in Professor\n}",
                    "{\n\t// Courses must have teachers\n  \t\n  all c: Course, p: Person | p.teaches in c\n}",
                    "{\n\t// Courses must have teachers\n  \t\n  all c: Course| lone p: Person | p.teaches in c\n}",
                    "{\n\t// Courses must have teachers\n  \t\n  all c: Course| some p: Person | teaches.c in p\n}",
                    "{\n\t// Courses must have teachers\n   \n\tall c: Course | lone p: Professor | c in p.teaches \n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | lone p: Person | p in Professor implies c in p.teaches \n}",
                    "{\n\t// Courses must have teachers\n\tall c: Course | lone p: Person | p in Professor implies p.teaches in c\n}",
                    "{\n\t// Courses must have teachers\n\t\n\tall p: Person, c:Course | some teaches.c implies p in Professor\n  \n}",
                    "{\n\t// Courses must have teachers\n\tall p: Person, c: Course | (p not in teaches.c) iff (p in Professor)\n}",
                    "{\n\t// Courses must have teachers\n\tall p: Person, c:Course| p in teaches.c implies p in Professor\n\tsome p: Person | p->Course in teaches implies some p.teaches\n}",
                    "{\n\t// Courses must have teachers\n\tsome p: Person|all c: Course| c in p.teaches implies p in Professor}",
                    "{\n\t// Courses must have teachers\n  some p: Person, c: Course| some teaches.c implies p in Professor\n\n}"
                ]
            },
            {
                "description": "Projects are proposed by one course",
                "pred": "this/inv4",
                "oracle": "{\n\t// Projects are proposed by one course\n\tall p: Project | one c: Course | p in c.projects\n}",
                "erroneous": [
                    "{\n\t// Projects are proposed by one course\n  \tall p:Project | some c:Course | p in c.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall c1, c2: Course | all p: Project | p in c1.projects and p in c2.projects implies c1 = c2\n\t\n}",
                    "{\n\t// Projects are proposed by one course\n  all p: Project | one p.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c:Course | one c.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n    all c1: Course, c2: Course | no (c1.projects & c2.projects)\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tone c : Course | all p : Project | p in c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p: Project | one Course\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall c: Course | all p: Project | p in c.projects \n\n}",
                    "{\n\t// Projects are proposed by one course\n\tone c : Course | some c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c: Course | lone c.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p:Project | some c1,c2:Course | p in c1.projects and p in c2.projects implies c1 = c2\n}",
                    "{\n\t// Projects are proposed by one course\n  \n  all p: Project | one Course.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n  some (Course<:projects).Project\n}",
                    "{\n\t// Projects are proposed by one course\n\tall c: Course | some c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  \n  all p: Project | all c: Course | one c.projects\n\n}",
                    "{\n  \tall p : Project | (one c : Course | c.projects = p)\n\t// Projects are proposed by one course\n\n}",
                    "{\n\t// Projects are proposed by one course\n  \n  \n  all p: Project | one c: Course | c.projects in p\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p : Project | all c : Course | p in c.projects implies no (Course-c).projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p: Project | one (Course->(Course.projects)).p\n}",
                    "{\n\t// Projects are proposed by one course\n     one Course.projects\n\n\n}",
                    "{\n\t// Projects are proposed by one course\n  \tlone c: Course | all p: Project | p in c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  some p : Project | one c : Course | p in c.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tsome c: Course | c in Project\n}",
                    "{\n\t// Projects are proposed by one course\n  all p:Project | lone Course\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall x: Project | one Course <: projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p : Project | all c : Course.projects | one p&c\n}",
                    "{\n  \tall p : Project | (some c : Course | c.projects = p)\n\t// Projects are proposed by one course\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p: Project | all c: Course | some c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c:Course ,cnot:Course-c |\n  \tsome p:Project |\n  \t\tp in c.projects implies p not in cnot\n\n}",
                    "{\n\t// Projects are proposed by one course\n  all c : Course, p : Project, pr : Person | p in c.projects and p not in pr.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n  all p:Project | p in Course.projects\n  no p:Project | all disj c1,c2:Course | p in c1.projects implies p not in c2.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c:Course | not (no c.projects)\n\tall p:Project | some c1,c2:Course | p in c1.projects and p in c2.projects implies c1 = c2\n}",
                    "{\n\t// Projects are proposed by one course\n  all c1,c2:Course | all p:Project | p in c1.projects and p in c2.projects implies c1 = c2\n  all c:Course | not (no c.projects)\n}",
                    "{\n\t// Projects are proposed by one course\n\n\tall p: Project | some c: Course | c.projects in p\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p: Person | some c : Course | c.projects in p.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tall disj c1, c2: Course | some p: Project | p in c1.projects and p not in c2.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tno Person.projects \n}",
                    "{\n\t// Projects are proposed by one course\n\tone c: Course | all p: Project | c.projects in Course\n}",
                    "{\n  \tall p : Project | (one c : Course | c.projects = p)\n    all x, y : Course | x != y implies no (x.projects & y.projects)\n\t// Projects are proposed by one course\n\n}",
                    "{\n\t// Projects are proposed by one course\n  \n  all c : Course, p: Project | one (Course<:projects).p\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p : Project | some c1, c2 : Course | c1 in projects.p implies not c2 in projects.p\n}",
                    "{\n\t// Projects are proposed by one course\n  \tsome c:Course | one c.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n  one Course.projects -> Project\n}",
                    "{\n\t// Projects are proposed by one course\n  all p:Project | all disj c1,c2:Course | p in c1.projects implies p in c2.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c:Course ,cnot:Course-c |\n  \tsome p:Project |\n  \t\tp in c.projects and p not in cnot\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall c:Course | c.projects not in (Course - c).projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tone c : Course | one p : Project | c in projects.p\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall p : Project | some c : Course | lone (Course :> projects.p)\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tone(Course -> Project)\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p : Project | one c : Course | c in Course :> projects.Project\n}",
                    "{\n\t// Projects are proposed by one course\n\tall p : Project, p1 : Person | one c : Course | p in p1.projects and p in c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  all c : Course, p : Project | p in c.projects and p not in Person.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n\t(all p: Project|all disj c1, c2: Course| p in c1.projects iff p not in c2.projects)\n}",
                    "{\n\t// Projects are proposed by one course\n\t(all p: Professor| p.projects = p.teaches.projects)\n}",
                    "{\n\t// Projects are proposed by one course\n\t(all p: Professor| p.projects = p.teaches.projects) and (all p: Project|all c: Course| p in c.projects implies (no c2: Course| not c2 = c and p in c2.projects))\n}",
                    "{\n\t// Projects are proposed by one course\n\t(all p: Professor| p.teaches = p.teaches.projects) and (all p: Project|all c: Course| p in c.projects implies (no c2: Course| not c2 = c and p in c2.projects))\n}",
                    "{\n\t// Projects are proposed by one course\n\tone c : Course | c.projects in Project\n}",
                    "{\n\t// Projects are proposed by one course\n\tall c : Course | one Course.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  \tsome Course.projects\n\tall disj c1,c2 : Course | no (c1.projects&c2.projects)\n}",
                    "{\n\t// Projects are proposed by one course\n  all p:Course.projects | one Course\n\n}",
                    "{\n\t// Projects are proposed by one course\n  no disj c1, c2:Course | no p1:Project | p1 in c1.projects => p1 in c2.projects\n\n}",
                    "{\n\t// Projects are proposed by one course\n  all c1, c2 : Course | (c1 not in c2) and no (c1.projects & c2.projects)\n\n}",
                    "{\n\t// Projects are proposed by one course\n\t\n  \n  all x : Project | one p : Professor, c : Course| x in c.projects and p in teaches.c\n}",
                    "{\n\t// Projects are proposed by one course\n  \t\n  \tall p : Project | one c : Course |\n  \t\tone c.projects\n\t\n}",
                    "{\n\t// Projects are proposed by one course\n\tall x: Project | lone Course <: projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tlone Course.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  some cx:Course, cy:Course | all p:Project | p in cx.projects implies p not in cy.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  some cx:Course | all p:Project | p in cx.projects implies all cy:Course | cy != cx and p not in cy.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall c : Course | one Project\n}",
                    "{\n\t// Projects are proposed by one course\n\t\n  \tone p: Project | all c: Course.projects | one p & c\n}",
                    "{\n\t// Projects are proposed by one course\n  all c1,c2:Course | some p:Project | p in c1.projects and p in c2.projects implies c1 = c2\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall disj c1,c2:Course |  all p: Project | c1.projects not in c2.projects and (p in c1.projects or p in c2.projects)\n\n}",
                    "{\n\t// Projects are proposed by one course\n\tall c : Course | some p: Person | p.projects in c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tsome c : Course | all p: Person | p.projects in c.projects\n}",
                    "{\n\t// Projects are proposed by one course\n  one c : Course | all p : Project | p in c\n  \n\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall p : Project | p in Course.projects\n  \tall a,b : Course | a != b implies a.projects not in b.projects\n\tall p : Project,  a,b : Course | p in a.projects and a != b implies p not in b.projects    \n}",
                    "{\n\t// Projects are proposed by one course\n  \tall p : Project | p in Course.projects\n  \tall a,b : Course | a != b implies a.projects not in b.projects\n\t\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall p: Project, c1,c2: Course | ( p in c1.projects and p in c2.projects ) iff c1 = c2\n\n}",
                    "{\n\t// Projects are proposed by one course\n  \tall p : Project, c : Course | one(c.projects) implies c.projects in p\n  \t\n}",
                    "{\n\t// Projects are proposed by one course\n  all p: Project | one c: Course | lone c.projects\n  \n}",
                    "{\n\t// Projects are proposed by one course\n\tall c: Course | all c1: Course | one p: Project | (p in c.projects) implies (p not in c1.projects)\n}",
                    "{\n\t// Projects are proposed by one course\n\tPerson <: projects.~projects :> Course in iden\n}",
                    "{\n\t// Projects are proposed by one course\n\tone Person <: projects.~projects :> Course\n}",
                    "{\n\t// Projects are proposed by one course\n\tCourse.projects in Person.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tPerson.projects in Course.projects\n}",
                    "{\n\t// Projects are proposed by one course\n\tPerson.projects = Course.projects\n}"
                ]
            },
            {
                "description": "Only students work on projects and projects must have someone working on them",
                "pred": "this/inv5",
                "oracle": "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n\t\n\n\t\n\n\t\n  \n\t\n\n\tall pr : Project | (Person <: projects).pr in Student\n\n\n\t\n\n\tall pr : Project | some (Person <: projects).pr\n}",
                "erroneous": [
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | (some p.projects) implies p in Student\n}",
                    "{\n  all p : Project | (some s : Student | p in s.projects)\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project | some (Person <: projects).p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\t\n  \tall ps : Project | some p : Person | p in ps.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  (all p : Project | some s : Student | p in s.projects) and no Professor.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some pp : Person | p in pp.projects implies pp in Student \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall pers:Person | (some pers.projects) implies pers in Student\n\tand\n\tall p:Project | some pers:Person | p in pers.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall y : Project | some p : Person-Professor | y in  p.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    Person<:projects.Project in Student\n    some Person<:projects.Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | all s : Person | p in s.projects and s in Student\n\n}",
                    "{\n  all p : Professor | no p.projects\n \n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person | some p.projects implies p in Student\n  \tall p: Project | one person: Person | p in person.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | all pp : Student | p in pp.projects\n}",
                    "{\n  all p : Project, s : Person | (p in s.projects implies p in Student)\n \n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  \tall p:Person | some pro:Project | pro in p.projects implies p in Student\n  \tall proj:Project | some p:Person| proj in p.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | some s.(Person <: projects)\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person-Student | no p.projects\n\t// projects must have someone working on them\n  \tall p : Project, s : Student | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Project | one person: Person | person in Student and p in person.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n \tsome Person:>Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Person | some pj:Project| pj in p.projects implies p in Student \n  \n  \n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some per : Person | p in per.projects implies per in Student and per not in Professor\n}",
                    "{\n\t// Only students work on projects and\n\t\n\tall x : Person | \n\t\t( \n\t\t\tall p : Project | (p in x.projects implies x in Student)\n\t\t) and \n\t\t( \n\t\t\tsome p : Project | p in x.projects\n\t\t)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some s: Student |s.projects=p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  (all p : Project | some s : Student | p in s.projects) and no (Professor - Student).projects\n\n}",
                    "{\n\t// Only students work on projects and\n  \tall p : Project | (Person <: projects).p in Student\n\t// projects must have someone working on them\n\tall p : Project | some (Person <: projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t\n  \t\n  \tsome p : Person | \n  \t\tall pr : Project |\n  \t\t\tpr in p.projects implies p in Student\n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all proj:Project, p:Person | proj in p.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall s : Student, p : Project | p in s.projects\n  \tall p : Project | some s : Student | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person-Professor, x : Project | x in p.projects\n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.projects implies p in Student\n\t// projects must have someone working on them\n  all c : Course | some c.projects implies some p : Person | c.projects in p.projects \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | all p: s.projects | some p.projects\n\n}",
                    "{\n\t// Only students work on projects and \n  \n  \t\tall s : Person | some ( s.projects) implies s in  Student\n  \n\t// projects must have someone working on them\n  \n  \t\tall pr : Project | some (Course <:projects).pr \n  \n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tsome Student.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall s: Student | some s.projects\n  \tall p:Project | some ss: Student | p in ss.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone \n  all s: Person, p:Project | s->p in (Person <: projects) implies s in Student and one (Person <: projects).p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\t(all p: Person| some p.projects iff p in Student) and (Project & Student.projects = Project)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall pro:Project | ( some p:Person | p in projects.pro implies p in Student)  and (some (Person <: projects).pro) \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Person, pr : Project | some pr => p in Student\n  \tall p : Project | some s : Person | p in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | p in Student implies p in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  some s : Student | all p : Project | p in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.projects implies p in Student\n\t// projects must have someone working on them\n  \tall x : Course | some s : Student | some x.projects implies x.projects in s.projects\n\n}",
                    "{\n  all p : Professor | no p.projects\n  all p : Person | some p.projects implies p in Student\n  all p : Project | (some s : Student | p in s.projects)\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.enrolled implies p in Student\n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p:Person |\n  \t\tsome proj:Project|\n  \t\t\tproj in p.projects implies p in Student\n\t\n  \tall proj:Project|\n  \t\tsome s:Student |  proj in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Person - Student | all pj : Project | p not in projects.pj and \n  \tsome s : Student| s in projects.pj\n  \t\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tsome s: Student | all p : Project | s in projects.p and all x:Person | p in x.projects implies x in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t\n  all p: Project | one c:Course | p in c.projects\n  \t\t\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall s : (Person - Professor) | some s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p : Project | some Person-Professor <: projects.p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Project | one person: Person | p in person.projects implies person in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | one (Person <:projects).p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pr : Project |all p : Person | (some p->pr) implies p in Student \n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n      lone ((Student - Professor).projects) and (Student - Professor).projects = Person.(projects & (Person->Project))\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n      lone (Student.projects) and Student.projects = Person.(projects & (Person->Project))\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n  all x: Project | some Student.projects &  Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person | (all pr: Project | (p->pr) in (Person<:projects)) implies p in Student\n  \t\n    \n  \tall p: Project | some (Person<:projects).p\n  \t\n  \t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 and p not in Professor implies p = Student \n  \tall pr : Project | some s : Student | pr in s.projects\n}",
                    "{\n\t// Only students work on projects and \n  \tall c : Course | some c.projects implies some s : Student | c.projects in s.projects\n\t// projects must have someone working on them\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    all c : Course | some c.projects implies some s : Person | c.projects in s.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some per : Person | per in projects.p and per in Student and per not in Professor\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tPerson :> projects.Project in Student and Person :> projects.Project not in Professor\n  \tsome(Person :> projects.Project)\n  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  some s : Person - Professor | all p : Project | p in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Person - Student | all pj : Project | p not in projects.pj and \n  \tall s : Student| some s.projects\n  \t\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project,  s : Student | p in s.projects\n  \tall p : Project | some p1 : Person | p in p1.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | (all s:Person | some s.enrolled implies s in Student and  p in s.projects)\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\t(all p : Project | all ps : Person | some ps.enrolled implies p in Student)\n\t(all p : Project | all s : Student | p in s.enrolled)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | (p in pe.projects) implies pe in Student\n\tall p : Project | all c : Course | some pe : Person | p in c.projects \n  \t\timplies p in pe.projects and pe in Student\n}",
                    "{\n\t\n\t// projects must have someone working on them\n\tall p : Person | (some pr : Project | p->pr in projects) implies p in Student \n\tand all pr1 : Project | one p1 : Person | p1 in projects.pr1\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\t(all p: Person| some p.projects iff p in Student)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n    all p: Project | some s: Student | s.projects = p\n\tall s: Person | s in Student <=> s.projects != none\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n   all p: Project |\n\t\t(some s: Student | s.projects = p) and\n\t\t(all s: Person | s not in Student => s.projects = none)\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some x : Student | p in x.projects implies x in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pr : Project | one pe : Person | pe not in Professor implies pr in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Person-Student, y: Student | no(x.projects) && some y\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Person-Student, y: Course | no(x.projects) || no(y.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    (Course <: projects) . Project in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student, p: Project | one (Person<:projects).s\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  \tall p : Person | (some p.(Person<:projects)) \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pe: Person - Student | all p: Project | p not in pe.projects\n\tsome p: Person | all pro: Project | pro in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | pe in Student implies p in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all x:Person | x not in Professor and some x.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s : Person, p : Project | (p in s.projects) implies (s in Student)\n  all p : Project | some s : Person | (p in s.projects) implies (s in Student)\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall s: Student | all p: Project | p in s.projects and p not in Professor\n  \tall p: Project | some s:Student | p in s.projects\n  \tall pe: Person - Student | all p: Project | p not in pe.projects\n\tall pro: Project| some p: Person | pro in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n    all proj : Project | proj in Person.projects implies Person in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Project | lone (Student <: projects).p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | p.projects in Project implies p in Student\n  \tall p: Project | some s: Student | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | (all pr : Project | p->pr in projects) implies p in Student \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p : Person, c : Course | some p.projects => p in Student \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome p : Person | some s : Student | all pj : Project | s.projects in pj and pj in p.projects  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some pp : Person | pp.projects in p and pp in Student\n}",
                    "{\n\t// Only students work on projects and \n  all p: Project, s: Person | s in projects.p implies s in Student\n\t// projects must have someone working on them\n\tall p: Project | some pe: Person | pe.enrolled in projects.p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | Student not in p implies no p.projects\n  \tall p : Project | some pe : Person & Student | p in pe.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome p : Person | all pr : Project | pr in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Project, s: Student | s.enrolled in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Project | some per: Person - Professor | p in per.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    Person<:projects.Project in Student\n    some Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    Person != Student\n\tall person: Person | some person.projects implies person in Student \n}",
                    "{\n  all p : Professor | no p.projects\n  all p : Person | some p.projects implies p in Student\n \n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n  all p : Person | some p.projects implies p in Student\n  all p : Project | (some s : Student | p in s.projects)\n  all p : Project, s : Student | some s.projects\t\n  \n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person-Professor, ps : Project | ps in p.projects\n  \tall ps : Project | some p : Person-Professor | ps in p.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person, ps : Project | ps in p.projects\n  \tall ps : Project | some p : Person | ps in p.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person-Student | no p.projects\n  \tall p : Project | some s : Person-Professor | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.enrolled implies p in Student\n\t// projects must have someone working on them\n  all c : Course | some c.projects implies some s : Student | c.projects in s.projects \n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.enrolled implies p in Student\n\t// projects must have someone working on them\n  all c : Course | some c.projects implies some p : Person-Professor | p.projects in c.projects \n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.enrolled implies p in Student\n\t// projects must have someone working on them\n  all c : Course | some c.projects implies some p : Person-Professor | c.projects in p.projects \n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.enrolled implies p in Student\n\t// projects must have someone working on them\n  all c : Course | some c.projects implies some p : Person | c.projects in p.projects \n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person | some p.projects implies p in Student\n\t// projects must have someone working on them\n  \tall x : Course | some s : Person | some x.projects implies x.projects in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n  \t\n\t// projects must have someone working on them\n  \tall x : Course | some s : Student | some x.projects implies x.projects in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person-Professor | some p.projects implies p in Student\n\t// projects must have someone working on them\n\n\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person, c : Course | c in p.enrolled implies c not in p.teaches \n  \tall p : Person | some p.projects implies p in Student\n\t// projects must have someone working on them\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    all c : Course | some c.projects implies some s : Person-Professor | c.projects in s.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some c : Course, s : Student | p in c.projects implies p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n  all p : Professor | no p.projects\n\t// projects must have someone working on them\n  \tall p : Project | some c : Course, s : Student | p in c.projects implies p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n  \tall p : Person-Student | no p.projects\n\t// projects must have someone working on them\n  \tall p : Project | some c : Course, s : Student | p in c.projects implies p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Person | some pj:Project| some(p.projects) implies (p in Student)\n  \n  \n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some per : Person | per in projects.p implies p in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student, p: Project | one (Person<:projects).p \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student, p: Project | one (Person<:projects).p and (Person<:projects).p in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student, p: Project | lone s.(Person<:projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student, p: Project | some s.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | all per : Person | per in projects.p and per not in Professor\n\tall p : Project | some per : Person | per in projects.p and per in Student  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some per : Person | per in projects.p and per not in Professor\n\tall p : Project | some per : Person | per in projects.p and per in Student  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Person, p: Project | some s.projects implies s in Student and some (Course<:projects).p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall per : Person | per in Student implies per not in Professor\n\tall p : Project | some per : Person | per in projects.p and per in (Person-\t\t\tProfessor)  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | all per : Person | per in (Person <: projects).p and per in \t\t(Person-Professor)  \n  \n\tall p : Project | some per : Person | per in (Person <: projects).p \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x : Person | some p : Project | x in Student and some p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p:Project, person:Person | one Person<:projects.p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    all proj:Project,p:Person|\n  \tproj in p.projects\n  \t\n  \tall proj:Project , prof:Professor |\n  \t\tproj not in prof.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : (Person-Student) | no p.enrolled \n  \tall p : Project , pp : Person | pp in projects.p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : (Person-Student) | no p.enrolled \n  \tall p : Project , pp : Person | pp in projects.p\n  \n  no (Person - Student).projects \n  all p : Project | p in Person.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n\tsome p: Project | some s: Student | s.projects in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | some s:Student |all pf:Professor | p in s.projects and p not in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | some s:Student |all pf:Professor | p in s.projects and p not in pf.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | (Professor not in Person :> projects.p) and some (Person :> projects.p)\n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | (Professor not in Person :> projects.p) and some (Student :> projects.p)\n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t(all p : Project | some s : Student | some s.enrolled implies p in s.projects)\n\t(all p : Project | all t : Professor | p not in t.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t(all p : Project | some s : Person | some s.enrolled implies p in s.projects)\n\t(all p : Project | all t : Professor | p not in t.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t(all p : Project | all s : Person | some s.enrolled implies p in s.projects)\n\t(all p : Project | all t : Professor | p not in t.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | (p in pe.projects) implies pe in Student\n\tall p : Project | all c : Course | some pe : Person | p in c.projects \n  \t\timplies p in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | (p in pe.projects) implies pe in Student\n\tall p : Project | some pe : Person | pe.projects in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tno (Person-Student).projects\n\tStudent.projects in Course.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some pe : Person | (p in pe.projects) implies pe in Student\n\tall p : Project | some pe : Person | pe.projects = p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project | some pe: Person | p in pe.projects\n  no  p: Professor | p.projects in Project\n  \n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project, pe: Person | p in pe.enrolled.projects => pe in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | all ps : Person| one c : Course | ps in Student and p in ps.projects and p in c.projects implies c in ps.enrolled\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p : Project | some ps : Person| one c : Course | ps in Student and p in ps.projects and p in c.projects implies c in ps.enrolled\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t\n  \t// Only students work on projects\n    \n  \tall p : Person - Professor | p.projects = none \n\n    \n    all p: Person | some p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | lone s.projects and some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  one s: Student | lone s.projects and some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Person | all p: s.projects | p in s.enrolled.projects and some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | all p: s.projects | p in s.enrolled.projects and some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | all p: s.enrolled | some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | all p: s.enrolled.projects | some s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all s: Student | all p: s.enrolled.projects | some p.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n   \n    all s: Person | (s in Student <=> s.projects != none) and \n     (all p:Project | s.projects = p)\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n   \n    all s: Person | (s not in Student => s.projects = none) and \n     (all p:Project | s.projects = p)\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n   all p: Project |\n\t\t(some s: Student | s.projects = p) and\n\t\t(all s: Person | s in Student <=> s.projects != none)\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\t\n  \n  \t(all p : Project, x : Person, c : Course | p in c.projects and c in x.enrolled \t\t\timplies x in Student) \n\tand\n\t(all p : Project | some c : Course, x : Student | p in c.projects and c in x.enrolled)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some x : Student | p in x.projects implies not x in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | some x : Student | p in x.projects implies not x in Professor\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  all s : Person, pr : Project | (some s.(Person<:projects)) implies s in Student\n\t& (Person<:projects).pr\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t\n  \t\n\n\tall s : Student, c : Course, pr : Project | c -> pr in projects and s -> pr in projects implies s -> c in enrolled\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n  all x: Project | some (Person - Student).projects &  Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \t\n \t\n  \tall pr : Project, s : Person |  some (Person<:projects).pr\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pr : Project | one pe : Person | pe not in Professor and pr in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pr : Project | one pe : Person | pe in Student implies pr in pe.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Person-Student, y: Course | no(x.projects) && no(y.projects) && some Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Professor, y: Course | no(x.projects) && no(y.projects) && some Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Professor, y: Course | no(x.projects) && no(x.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all x : Person - Student | no(x.projects)\n  all x : Project | some projects.x & Professor\n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Person-Student, y: Course | no(x.projects) && no(y.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Professor, y: Course | no(x.projects) || no(y.projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Professor, y: Course | no(x.projects) || no(y.projects) && some Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some pr: Project | p in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Project | one person: Person | some person.projects implies person in Student \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    (Course <: projects) = (Person <: projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n    (Course <: projects) = (Student <: projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n      // Only students work on projects and \n\t all p : Person | (some pr : Project | p->pr in projects) implies p in Professor\n    // projects must have someone working on them\n\tall proj: Project | some s : Student | proj in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person - Student | all pr: Project | pr in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall s: Student | some p : Project | s in projects.p and all x:Person | x\n in projects.p implies x in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone \n  all s: Person, p:Project | s in Student and one (Person <: projects).p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone \n  all s: Person, p:Project | !( s in Professor and one (Person <: projects).p)\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone \n  all s: Person, p:Project |  s in p.projects\n}",
                    "{\n\t// Only students work on projects and \n  \n  \n  all p : Project | lone ( Person <: projects).p \n  \n\t// projects must have someone working on them\n  \n  \n  \n\n}",
                    "{\n\t// Only students work on projects and \n  \n  \t\tall s : Student | some ( s.projects) \n  \n\t// projects must have someone working on them\n  \n  \t\tall pr : Project | some (Course <:projects).pr \n  \n  \n\n}",
                    "{\n\t// Only students work on projects and \n  \n  \t\tall s : Student | some ( s.projects) \n  \n\t// projects must have someone working on them\n  \n  \t\tall pr : Project, s : Student  | some (Course <:projects).pr \n  \n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall x: Student | some p: Project | (Person <: projects).p in x.(Person <: projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person | (all pr: Project | (p->pr) in (Person<:projects)) implies p in Student\n\tall p: Person | all pr: Project | (p->pr) in (Person<:projects) implies p in Student\n  \t\n    \n  \tall p: Project | some (Person<:projects).p\n  \t\n  \t\n}",
                    "{\n\t// Only students work on projects and \n\tall c: Course, P: Person | Project in P.projects implies P in Student\t\n  // projects must have someone working on them\n\t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tsome s : Person | all p : Project | (s in p.projects) implies (s in Student)\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project | (Person <: projects) in Student -> p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  all p : Person , pro : Project | (Person <:projects).pro in Student  iff some p.(Person <: projects) & Student\n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  all p : Person , pro : Project | (Person <:projects).pro in Student  iff some (Person <: projects).pro & Student\n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  all  pro : Project | (Person <:projects).pro in Student  iff some (Person <: projects).pro & Student\n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n  all  pro : Project | (Person <:projects).pro in Student  iff no (Person <: projects).pro & Professor\n  \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | some pe:Person | p in pe.enrolled\n  all pe:Person | some p:Project | p in pe.enrolled implies pe in Person\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | some pe:Person | p in pe.projects\n  all pe:Person | some p:Project | p in pe.projects implies pe in Person\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p:Project | some pe:Student | p in pe.projects\n  all pe:Person | some p:Project | p in pe.projects implies pe in Person\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall pe: Person - Student | some p: Project | p not in pe.projects\n\tall p: Person | all pro: Project | pro in p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | p.projects in Project implies p in Student\n  \tall p: Project | one s: Student | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | p.projects in Project implies p in Student\n  \tall p: Project | lone s: Student | p in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n\tall proj : Project | some per : Person | proj in per.projects implies per in Student \n  \tall proj : Project | some per : Person | some per.projects implies per in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n\tall proj : Project | some per : Person | proj in per.projects implies per in Student \n    all proj : Project | proj in Person.projects implies Person in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \n\tall proj : Project | some per : Person | some proj implies per in Student \n    all proj : Project | proj in Person.projects implies Person in Student\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n      Student.projects = Person.(projects & (Person->Project))\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n      lone (Person.projects) and (projects.Project & Person) in Student\n\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | Person.projects in p implies Person in Student\n}",
                    "{\n\t// Only students work on projects and \n  all x:Person, p:Project | x in Student implies p in x.projects\n  all p : Project | lone (Person <: projects).p\n\n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n  all x:Person, p:Project | x in Student implies p in x.projects\n  all p : Project | lone (Student <: projects).p\n\n\t// projects must have someone working on them\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all x:Person | x in Student implies some x.projects\n  all x:Professor, c:Course, p:Project | c in x.teaches implies p not in x.projects}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all x:Person | x in Student implies some x.projects\n  all x:Person, c:Course, p:Project | c in x.teaches implies p not in x.projects}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p : Person | (some p.enrolled) implies p in Student and one (Course <: projects).p.projects \n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Course.projects | no ((Person-Student).projects & p)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | no (p & (Person-Professor).projects)\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\n  all pr : Project | some (Person <: projects).pr implies some Person & Student \n  all pr : Project | some (Person <: projects).pr\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n \t\n  \tall p : Person  | p.projects in Project implies p in Student\n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n \t\n  \tall p : Person  | p.projects in Project implies p in Student\n  \tall p : Project | some \tStudent.projects \n  \t\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Project | all ps: Person | (p in ps.projects) implies no (ps & Professor)\n\tall p: Project | one s: Student | p in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person, p1: Project | p1 in p.projects implies p not in Professor \n  \tsome (Person <: projects).Project\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person, p1: Project | p1 in p.projects implies p not in Student \n  \tsome (Person <: projects).Project\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  \tall p: Person, p1: Project | p1 in p.projects implies p not in Student \n  \tall p: Project | some (Person <: projects).p\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 implies p = Student \n  \t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 implies p = Student and p not in Professor\n  \tall pr : Project | some s : Student | pr in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 and p not in Professor iff p = Student \n  \tall pr : Project | some s : Student | pr in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 and p not in Professor implies p = Student \n  \t\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 and p not in Professor implies p = Student \n  \tall pr : Project | some s : Person | pr in s.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | #(p.projects) > 0 and p not in Professor implies p = Student \n  \tall pr : Project | some s : Person | pr in s.projects and s not in Professor\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome s : Student | all p : Project | s.projects in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome t : Professor | some s : Student | all p : Project | s.projects in p and t + s in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome t : Professor | some s : Student | all p : Project | s.projects in p and (t + s).projects in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tsome p : Person | some s : Student | all p : Project | s.projects in p and p in p.projects  \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Project | all t : Professor | some s : Student | p in s.projects implies s not in Professor\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | some p.projects implies p not in Professor\n  \tall p : Project | some pp : Person | pp.projects in p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | Student not in p implies no p.projects\n  \tall p : Project | some Course.projects:>p\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | Student not in p implies no p.projects\n  \tall p : Project | some pe : Person | p in pe.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | Student not in p implies no p.projects\n  \tall p : Project | some pe : Person | Student in pe implies p in pe.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p : Person | Student not in p implies no p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Project | some projects[Person]\n}",
                    "{\n\t// Only students work on projects and \n  \tall p: Project, y: Person | y->p in projects implies y in Student\n\t// projects must have someone working on them\n\t\n  \tsome y: Person | some Project implies y in Project\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project | some s : Person | p in s.projects iff s in Student\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n  all p: Project | some s : Person | p in s.projects iff s in Student\n  \n  all p: Project | some per : Person | p in per.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Person | some p.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Project | some per: Person | some per.projects implies p in per.projects\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Project | some s: Student | some s.projects implies p in s.projects\n\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Project | some s: Student | p in s.projects and some c: Course | p in c.projects and c in s.enrolled\n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p in Student\n    and\n    all p: Project | some s: Student | some c: Course | p in c.projects implies p in s.projects \n}",
                    "{\n\t// Only students work on projects and \n\t// projects must have someone working on them\n\tall p: Person | some p.projects implies p not in Professor\n    and\n    all p: Project | some s: Student | p in s.projects\n}"
                ]
            },
            {
                "description": "Students only work on projects of courses they are enrolled in",
                "pred": "this/inv6",
                "oracle": "{\n\t// Students only work on projects of courses they are enrolled in\n    all s: Student | s.projects in s.enrolled.projects\n    \n    \n}",
                "erroneous": [
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n  all s : Student | s.projects in\ts.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n        \n\t\n\n        all s : Student | all c : Course | some c.projects implies s->c in enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s: Student| all c:Course | all pr:Project | pr in s.projects implies pr in c.projects and c in \t\t  s.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | s.projects = s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Person & Student, p : s.projects, c : s.enrolled | p in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n   all s: Student | all p: Project | all c: Course| p in s.projects implies c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n      all s: Student |  s.enrolled.projects in s.projects \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : Project, c : Course | c in s.enrolled implies p in s.projects\n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all pr : Project, s : Person-Professor | pr in s.projects implies pr in s.enrolled.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n  all s : Student |  some s.(Person <: projects)  & (s.enrolled).(Course <: projects)  \n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p: Project | (Person<:projects).p in (Course<:projects).p \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s: Student | all c: Course| s.projects in c.projects implies c in s.enrolled  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t(Student <: projects).Project in enrolled.Course\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s: Student | all p: Project | p in s.enrolled.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | all p: Project | all c: Course | p in s.projects implies c in p.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person | all c : p.enrolled | c.projects in p.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s:Student | projects.(s.projects) = s.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student, p:s.enrolled.projects | s.projects in p\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s : Student | all c : Course | some pr : Project | s in projects.pr implies s in enrolled.c and c in projects.pr\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tenrolled = projects.~projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Student | p.enrolled in p.projects.~projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person | some p.enrolled implies p in Student and p.enrolled.projects in p.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t(Student <: projects).Project = enrolled.Course\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall st : Student | all p : Project | one c : Course | p in st.projects implies c in st.enrolled and p in c.projects\n}",
                    "{ Student.projects in Student.enrolled.projects  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tStudent.projects in Course.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | all c : s.enrolled | s.projects in c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Project, st : Person, c :Course | p in st.projects implies st in enrolled.c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person, c : Course |\n  \t\t(p.projects in c.projects) implies (c in p.enrolled)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s: Student, pr: Project, c: Course | s -> c in enrolled implies pr in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \n  all s : Student, c : Course | some (s.projects & c.projects)  implies s.enrolled in c \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | some p:Project | some c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in s.enrolled)\n  \t\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all p : Person, c : Course, pr : Project | p in projects.pr implies p in enrolled.c and c in projects.pr\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c : Course | s.projects in c.projects => s.enrolled in c  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s:Student | some s.projects implies some c:Course | some c.projects and s->c in enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p: Student | (some pr:Project, c:Course | p in projects.pr and pr in c.projects implies p in enrolled.c)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person | some c : p.enrolled | c.projects in p.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s : Student | all c : Course | all pr : Project | \n  \tc in projects.pr implies c in s.enrolled\n  \t\n  \tall s : Student | all pr : Project | pr in s.projects implies pr in \t\ts.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person, c : Course | p.projects in c => p in Student\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s : Student, c : Course | (some s->Project) implies s->c in enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | all p:Project | all c:Course | s->p in projects implies c->p in projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s:Person | all p:Project| (some c:Course |  s in Student and c in projects.p and c in projects.p implies p in s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t\n  \t\n\t\n\t\n\tall s: Student, pr: s.projects | some c: Course | c->pr in projects implies s->c in enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | s.enrolled = s.projects.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  Student->~projects.Course in enrolled \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p:Project | (Person<:projects).p in Student and (Person<:enrolled).p in Student\n \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p: Person | all c: Course | c in p.enrolled => p.projects in c.projects \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p:Person, c: p.enrolled | p.projects in c \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | all c : s.enrolled | lone p : s.projects | p in c.projects  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s : Student, pr : Project, c : Course | c in projects.pr\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c : s.enrolled | some s.projects implies s.projects in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | all p : s.projects | p = s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  all s: Student, c: Course | s->c in enrolled implies some p: Project | p in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p: Student, c: Course, y: Project | (c in projects.y) and (p in enrolled.c) and (p not in teaches.c) implies (p in projects.y)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p: Student,c: Course, x: Project| lone (p.enrolled & projects.x)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    Course.projects in Student.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all p: Student.projects | p in projects.p.enrolled.projects\n    \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : Project, c : Course | \n  \t\tp in s.projects implies c.projects in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s : Student | some c : Course, p : Project | p in c.projects and c in s.enrolled implies p in s.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s : Person-Professor | some c : Course, p : Project | p in c.projects and c in s.enrolled implies p in s.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p: Project | (Person<:projects).p = (Course<:projects).p \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \n  all p: Person | all c: Course | all pr : Project | p in projects.pr implies p in Student and p in enrolled.c\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c : Course | \n  \t \ts.projects in c.projects and s.enrolled in c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c : Course | \n  \t \ts.projects in s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall pr: Project, c:Course | (some p:Student | p in (Person <: projects).pr and pr in (Course <: projects).c implies p in enrolled.c)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall pr: Project, c:Course | (some p:Student | p in (Person <: projects).pr and c in (Course <: projects).pr implies p in enrolled.c)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all p: Person - Student | all g: Project | g in p.projects => some c: Course | c in p.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some p: Project | p in s.projects implies s in enrolled.(Course <: projects.p)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p : Student | (some c : Course, p : Project | p in enrolled.c and c in projects.p )  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p : Person | (some c : Course, pr : Project | p in enrolled.c and c in projects.pr ) implies p in Student \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p : Person | all c : Course | some pr : Project | p in projects.pr and p in Student implies p in enrolled.c and c in projects.pr\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some(s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : s.projects | one c : Course | p in c.projects implies c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall c : Course | enrolled.c in Student\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person | (some p.enrolled and some p.enrolled.projects) implies Person<:projects.Project in p \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all s : Student, p : Project, c : Course | p in s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all pr : Project, s : Person-Professor | all c : (Course <: projects).pr | pr in s.projects implies c in s.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    all pr : Project, s : Person-Professor | all c : (Course <: projects).pr | pr in s.projects and c in s.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Person - Professor | all p : Project | s.enrolled in projects.p\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Person-Professor | all p : s.projects | s.enrolled in projects.p\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s : Student | s.projects = s.enrolled \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n\tall s: Student, p: Project | s.enrolled.projects in p\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall st : Student | all c : Course | c.projects in st.projects implies c in st.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person, c : Course | p.projects.enrolled in c => p in Student\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | some c:Course | c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | some c:Course | some p:Project | p in s.projects implies c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \t\n  \tall s: Person - Professor, prj: Project | \n        prj in s.enrolled.projects\n}",
                    "{ \n\t// Students only work on projects of courses they are enrolled in\n\tall p: Project, s: Student | some c: Course | p in s.projects and p in c.projects => c in s.enrolled \n}",
                    "{ \n\t// Students only work on projects of courses they are enrolled in\n\tall c: Course, s: Student | some p: Project | c in s.enrolled and p in s.projects => p in c.projects \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person | p.enrolled in p.projects.~projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  Project->Course in enrolled \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  Student->Course in enrolled \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall x : Student, p : Project | one c : Course | p in x.projects and p in c.projects implies c in x.enrolled\n}",
                    "{\n  \t// Students only work on projects of courses they are enrolled in\n  \tsome s : Student | all pr : Project | some c : Course |\n  \t\tpr in s.projects implies (pr in c.projects and c in s.enrolled)\n  \n  \t\n}",
                    "{\n  \t// Students only work on projects of courses they are enrolled in\n  \tsome s : Student | all pr : Project |\n  \t\tpr in s.projects implies (some c : Course | pr in c.projects and c in s.enrolled)\t\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n\tall s : Student, c : Course, p : Project | s.projects in p and c.projects in p implies s -> c in enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tStudent.projects = Course.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t(Person <: projects).Project = enrolled.Course\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tno (Person-Student).projects\n  \t(Student <: projects).Project = enrolled.Course\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tenrolled.Course in (Student <: projects).Project \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n    (Course <: projects) . Project in Student . enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \tStudent.projects & Course.projects in Student.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \tStudent.projects & Course.projects = Student.enrolled.projects\n}",
                    "{\n    // Students only work on projects of courses they are enrolled in\n    all s:Student-Professor | all p:Project | all c:Course | (s->c in enrolled and c->p in projects) implies s->p in projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | some p:Project | some c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in p.enrolled)\n  \t\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | some p:Project | one c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in s.enrolled)\n  \t\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s:Student | one p:Project | one c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in s.enrolled)\n  \t\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | all p : s.projects | one c : Course | p in c.projects implies s in c.grades.Person\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s:Student | all p:Project| (some c:Course | c in projects.p and c in projects.p implies p in s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s:Student | all p:Project| (some c:Course | s not in Professor and c in projects.p and c in projects.p implies p in s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p: Person | (p in Student) implies (p not in Professor)\n  \tall s:Student | all p:Project| (some c:Course | c in projects.p and c in projects.p implies p in s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s:Person | all p:Project| (some c:Course | s in Student and c in projects.p and c in projects.p implies p in s.projects and (s in Professor implies s not in projects.p))\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t all s: Student | all p: Project | \n        (some c: Course | c in s.enrolled and p in c.projects) implies p in s.projects and\n        (s in Professor implies p not in s.projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t all s: Student | all p: Project | some c: Course |\n        (c in s.enrolled and p in c.projects) implies p in s.projects and (c in s.enrolled and p in c.projects implies s not in c.teaches)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : Project | p in s.projects implies some c : s.enrolled | p in c.enrolled or p in s.teaches.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \n  all s : Student, c : Course | some (s.projects & c.projects)  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student, c: Course | Project in s.(Person<:projects) implies s in enrolled.c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student, c: Course, pr: Project | pr in s.(Person<:projects) iff c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person - Professor |\n  \t\tall proj : p.projects |\n  \t\t\tone c : p.enrolled | proj in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall pr : Project, p : Person | one c : Course |\n  \t\tp -> pr in projects implies\t\t\n  \t\t\tc -> pr in projects and c in p.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, pr : Project, c : Course | (pr in s.projects implies c in s.enrolled) and pr in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all pro : Project | some ((Person <: projects).pro & Student) implies Student.enrolled in  (Course <: projects).pro\n  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person, c : Course | p.projects in c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s:Student | some c:Course, p:c.projects | c in s.enrolled implies p in s.projects\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some p: Project | p in s.projects iff p in s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | one p: Project | p in s.projects iff p in s.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all p : Person, pr : Project | p in Student and p in projects.pr\n  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p:Person,c:Course | p.(Person <: projects) in c.(Course <: projects) implies p in Student and p in enrolled.c\n  \n \n  \n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c: Course | some ( s.projects & c.projects ) implies ( c in s.enrolled )\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, c:Course, pr:Project | pr in s.projects and pr in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tStudent.projects = Student.enrolled.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall p: Person, pr: Project, c: Course | p -> pr in (Person <: projects) implies p in Student\n  \t\t\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p: Person | all c: Course | c in p.enrolled <=> p.projects in c.projects \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student | some c : s.enrolled | lone p : s.projects | p in c.projects  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tlet cProjects = Course <: projects , pProjects = Person <: projects |\n\tcProjects[enrolled] = pProjects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s : Student | all pro : Project | all c : Course | s.projects in c.projects => c in s.enrolled  \n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all c : Course.projects | (Person <: projects).c in Student\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  all s: Person, c: Course, p: Project | s in enrolled.c implies s in Student\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\n  all s : Student |  lone  s.(Person <: projects)  & (s.enrolled).(Course <: projects) \n  \n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p : Person, c : Course, pr: c.projects |\n  \t\t(p.projects in pr) implies (c in p.enrolled)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : Project| some c : Course | c in s.enrolled implies p in s.projects\n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, p : Project| some c : Course | p in c.projects and s in c.enrolled\n  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student, c: Course | s.projects in c.projects iff c in s.enrolled\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \t\n  \tall s: Student, p: Project | p in s.projects implies one s.enrolled.(Course<:projects)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s: Student, p: Project | p in s.projects iff one (s.enrolled & (Course<:projects.p))\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some c: Course | c in s.enrolled implies c.projects in s.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some c: Course, p: Project | c in s.enrolled implies p in s.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some c: Course | c in s.enrolled implies s.projects in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student, c: Course | c in s.enrolled implies s.enrolled.projects in c.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student, p: Project | some c: Course  | p in s.projects implies s in enrolled.c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n  \tall s : Student, c: Course | some p : Project | s.enrolled in c implies p in s.projects\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, c : Course, pr : Project | (pr in s.projects) and (pr in c.projects) and (s in c.enrolled)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s : Student, c : Course, pr : Project | (pr in s.projects) and (pr in c.projects) and (s in enrolled.c)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  all p:Person, x: Project, c: Course |( p in projects.x) iff (p in enrolled.c and c in projects.x)  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  all p:Student, x: Project, c: Course |( p in projects.x) iff (p in enrolled.c and c in projects.x)  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  some p:Student, x: Project, c: Course |( p in projects.x) iff (p in enrolled.c and c in projects.x)  \n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  some p:Student, x: Project, c: Course |( p in projects.x) iff (p in enrolled.c and c in projects.x)  \n  \n  all p: Student | some x: Project, c:Course | p in projects.x iff (p in enrolled.c and c in projects.x)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  \n  \n  all p: Student | some x: Project, c:Course | p in projects.x iff (p in enrolled.c and c in projects.x)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n  \n  \n  \n  all p: Student | some x: Project, c:Course | p in projects.x implies (p in enrolled.c and c in projects.x) and p not in teaches.c\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n\tall p: Project, c: Course, y: Person | y in enrolled.c implies ( y in Student and y in projects.p)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n\tall p: Project, c: Course, y: Person | y in enrolled.c implies ( y in Student and y in projects.p and (y not in teaches.c ))\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n\tall p: Project, c: Course, y: Person | y in enrolled.c implies ( y in Student and y in projects.p and (y not in projects.p ))\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\t\n\tall p: Project, c: Course|some y: Person | y in enrolled.c implies ( y in Student and y in projects.p and (y not in projects.p ))\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall p: Student,c: Course, x: Project| lone (enrolled.c & projects.x)\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall pj: Project | some p: Person | pj in p.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall pj: Project | all c: Course | some p: Person | pj in p.projects implies c in p.enrolled\n\n}",
                    "{\n\t// Students only work on projects of courses they are enrolled in\n\tall s: Student | some c: Course | some s.projects implies s.projects in c.projects and c in s.enrolled\n}"
                ]
            },
            {
                "description": "Students work on at most one project per course",
                "pred": "this/inv7",
                "oracle": "{\n\t// Students work on at most one project per course\n  all s: Student, c: Course | lone s.projects & c.projects\n}",
                "erroneous": [
                    "{\n\t// Students work on at most one project per course\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s : Student | lone  s.projects & s.enrolled.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : s.enrolled | one(s.projects & c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all c: s.enrolled | lone c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | lone s.enrolled.projects \n}",
                    "{\n\t// Students work on at most one project per course\n  all s : Student, c:Course | one(s.projects & c.projects) \n\n}",
                    "{\n\t// Students work on at most one project per course\n\n        \n\n        all s : Student | lone s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | one s.enrolled.projects  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : s.enrolled | one p : Project | p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | one (s.projects & s.enrolled.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | one p : Project | p in s.projects\n}",
                    "{\n  all s: Student, c: Course | s -> c in enrolled and one p: Project | s -> p in projects and c -> p in projects\n\t// Students work on at most one project per course\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | some s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\t\n  \tall s:Student, c : Course | #s.projects&c.projects <= 0 \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student , p : Project | s.projects in p.enrolled and lone p.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | some s.projects.(Course<:projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student, pj: Project, c1, c2: Course | pj in s.projects and pj in c1.projects and pj in c2.projects => c1 = c2\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s:Student | all c:s.enrolled | lone (s.projects) \n\n}",
                    "{\n\t\n  \tall s:Student , proj:s.projects | one c:Course | proj in c.projects implies c.projects - proj not in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tlone (Student.enrolled.projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, p : s.projects | one c : Course | p in c.projects \n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | lone(Course.projects & s.projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | all c : p.enrolled | one(p.projects & c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n  \t~enrolled.projects in Course -> lone Project\n\n}",
                    "{\n\t// Students work on at most one project per course\n\n        \n\n        \n\n        \n\n        all s : Student, c : Course | some (c.projects & s.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n    all s : Student | all c : s.enrolled | one p : s.projects | c in p.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student |\n  \t\tall c : s.enrolled |\n  \t\t\tsome p : s.projects | p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : Course | lone(s.projects &  c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all c: Course | lone c.projects \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, disj p1, p2 : Project | \n  \t\t\t(p1 in s.projects and p2 in s.projects and\n  \t\t\t(Course:>projects.p1 in s.enrolled) and \n            (Course:>projects.p2 in s.enrolled)) implies p1 = p2 \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : Course | c in s.enrolled implies ((one pro : Project | pro in c.projects and pro in s.projects) or (all pro: Project | pro in c.projects and pro not in s.projects))\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : Course | ((one pro : Project | pro in c.projects and pro in s.projects) or (all pro: Project | (pro in c.projects) and not (pro in s.projects)))\n}",
                    "{\n\t// Students work on at most one project per course\n  \t\n  \n  \tlone Course.projects & Student.projects\n\n\t\n}",
                    "{\n\t// Students work on at most one project per course\n    lone enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student | some s.enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall x: Student | all c: Course | all p1, p2: Project |\n  \t\tp1 in c.projects and\n  \t\tp2 in c.projects and\n  \t\tc in x.enrolled implies\n  \t\t\tnot (p1 in x.projects and p2 in x.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | one sCourse : s.enrolled | \n  \t\t#(sCourse.projects & s.projects) <=1\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Person | lone (s.projects & s.enrolled.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, p1, p2: Project | not Course <: projects.p1 = projects.p2\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student , p : Project | p in s.projects and lone p.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | all c: Course | lone p: Project | c in s.enrolled and p in c.projects implies p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | all proj:s.projects | one c:s.enrolled | proj in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : s.enrolled | lone s.projects & c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \n    \n  all c : Course | all mitglieder : enrolled.c | lone (c.projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\t\n  \n  \tall s : Student, c : Course | one s.enrolled.projects and one c.projects\n   \n  \t\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student, p: s.enrolled |\n  \t\t(s.projects not in p.projects) or (one proj: s.projects | proj not in p.projects - proj)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student|all p1,p2:Project|all c:Course|p1 in s.projects and p2 in s.projects implies p1=p2\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student, p: s.projects | one p & s.enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | all pr : Project | some c : Course | p in Student and c in p.enrolled and pr in p.projects implies pr in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all p : s.projects | some c : Course | p in c.projects implies no p2 : c.projects | p != p2 implies p2 in s.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all p : s.projects | no c : Course | p in c.projects implies no p2 : c.projects | p != p2 implies p2 in s.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall c: Course | lone c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | lone p:Project | all c:Course |\n  \t\tc in s.enrolled implies p in s.projects and (p in c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : s.enrolled | one s.projects & c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | Person <: projects in s.projects one -> Course\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : Course | one(s.projects &  c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student, c : Course | lone p: Project | s->p in projects implies s->c in enrolled\n  \t\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tlone (enrolled.projects & (Person <: projects))\n}",
                    "{\n\t// Students work on at most one project per course\n    all s : Student | one e : s.enrolled | all p : s.projects | e in p.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : s.enrolled | one (s.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | all c : Course | lone p : Project | c in s.enrolled implies p in s.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n\t  all s : Student | some Course.projects  & s.projects\n\n  \n  \n}",
                    "{\n\t// Students work on at most one project per course\n\t  all s : Student | one (Course <: projects).(s.projects) \n\n  \n  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall c : Course | lone p : c.projects | p in c.(~enrolled).projects\n}",
                    "{\n\t// Students work on at most one project per course\n\t\n  \n  \tall s : Student, c : Course | one s.enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n    lone Student<:enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tPerson <: projects in (Student -> lone Project)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all disj p1, p2: s.projects | one c : s.enrolled | p1 in c.projects iff p2 not in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \t\n  \n  all s : Student, c : Course | c in s.enrolled implies one s.enrolled.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s : Student | one c : Course | s.projects in c \n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s:Student | all pr1, pr2:Project | one c: Course | \n  \tpr1 in s.projects and pr2 in s.projects and pr1 in c.projects and c in s.enrolled implies pr2 not in c.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p :Project | (Person<:projects).p in enrolled.projects.p\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | lone p : Project | all c : Course | c in s.enrolled implies p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tone (Person <: projects).{p:Project, c:Course | c->p in projects}\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : Course | c in s.enrolled => lone(s.enrolled.projects - s.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : Course | c in s.enrolled => \t\t\t\t\t\t\t\tlone(s.enrolled.projects & s.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : s.enrolled | lone (s.enrolled.projects - \t\t\t\t\tc.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all c : s.enrolled | lone(s.projects - c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all c: Course | lone(c.projects & s.enrolled.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student | some s.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n  enrolled in Student -> Course\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student, c:s.enrolled | lone s->c->(Course<:projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student | lone s.enrolled\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student | lone enrolled.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Student | lone enrolled->(s.projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \n  \n  \n    \n  all c : Course | all mitglieder : enrolled.c | lone (Person<:projects).(c.projects)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall c : Course | one c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student, c : s.enrolled | lone c.projects and lone s.projects\n  \t\n    \n}",
                    "{\n\t\n  \tall s:Student,proj:s.projects|some c:Course | proj in c.projects implies c.projects - proj not in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all disj p1,p2 : Project | Course<:projects.p1 != Course<:projects.p2\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, c : Course | one c.projects implies s in enrolled.c\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, c : Course | lone c.projects implies s in enrolled.c\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | lone c: s.enrolled.projects | s.projects in c\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Person - Professor | all c : s.enrolled | one p : s.projects | p in c.projects \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Person - Professor | all c : s.enrolled | lone(s.projects & c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student, c : s.enrolled, p : s.projects | lone( c + p)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student, c : s.enrolled, p : s.projects | lone( c.projects + p)\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | all c : Course | lone p : Project | c in s.enrolled implies\n  \t\t((c.projects & s.projects) = p)\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student, c : Course | one p : Project | c in s.enrolled implies\n  \t\t((c.projects & s.projects) = p)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student, c:Course | one s.projects <: Person & c.projects <: Course\n}",
                    "{\n\t// Students work on at most one project per course\n\n\tall s: Student | one p: Project | s.projects in p\n\n}",
                    "{\n\t// Students work on at most one project per course\n    \n   all s : Student, c : Course, p1 : Project | c in s.enrolled and lone c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n    \n   all s : Student, c : Course | c in s.enrolled and lone c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tenrolled.projects in Student -> lone Project\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tone enrolled.projects & Student <: projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | one pr : Project | p in Student and pr in p.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | all pr1, pr2 : Project | some c : Course | p in Student and pr1 in p.projects and pr2 in p.projects and pr1 in c.projects and pr2 in c.projects implies pr1 = pr2\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | one pr : Project | some c : Course | p in Student and c in p.enrolled implies pr in p.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | one pr : Project | some c : Course | p in Student and c in p.enrolled and pr in p.projects implies pr in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | all pr : Project | one c : Course | p in Student and c in p.enrolled and pr in p.projects implies pr in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall c : Course | one p : Project | p in c.projects\n  \tall s : Person | all p : Project | some c : Course | s in Student and c in s.enrolled and p in s.projects implies p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Person | some p : Project | all c : Course | s in Student and c in s.enrolled and p in s.projects implies p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Person | some p : Project | all c : Course | s in Student and c in s.enrolled and p in c.projects implies p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | one p : Project | p in Course.projects and p in s.projects \n}",
                    "{\n\t// Students work on at most one project per course\n   no disj s1, s2: Student, c: Course | s1.projects & c.projects & s2.projects != none\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall x : Student, c : Course | lone p : Project | p in x.projects and c in x.enrolled implies p in c.projects\n}",
                    "{\n\t// Students work on at most one project per course\nall x : Student, p1,p2 : Project, c1,c2 : Course | (x->p1 in projects and x->p2 in projects and c1->p1 in projects and c2->p2 in projects ) implies(c1=c2)\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | no c : Course | some p1, p2 : Project | p1 != p2 implies p1 in c.projects and p2 in c.projects and c in s.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | lone c : s.enrolled | one p : s.projects | p in c.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s : Student | all pro : Project | all c : Course | (pro in c.projects and pro in s.projects) implies c in s.enrolled\n\tall s : Student | all c : Course | c in s.enrolled implies ((one pro : Project | pro in c.projects and pro in s.projects) or (all pro: Project | pro in c.projects and pro not in s.projects))\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student , p : Project| p in s.projects and lone (Course<:projects).p\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | lone p: Project | all c: Course | p in c.projects and p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Person | all c : Course | ((one pro : Project | pro in c.projects and pro in s.projects) or (all pro: Project | (pro in c.projects) and not (pro in s.projects)))\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student , p : Project | s.projects in p and lone p.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | s.projects = s.enrolled.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | some (Course.projects)\n  \t\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | lone (Course.projects)\n  \t\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s: Student | one (Course.projects)\n  \t\n}",
                    "{\n\t// Students work on at most one project per course\n  \tlone Course.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tCourse.projects & Student.projects = Project\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \t(Student.enrolled.projects) in Student.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tlone ((Student.enrolled.projects)&(Student.projects))\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tlone ((Student.enrolled.projects)+(Student.projects))\n\n}",
                    "{\n  all s: Student, c: Course | s -> c in enrolled and some p: Project | s -> p in projects and c -> p in projects\n\t// Students work on at most one project per course\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | one p:Project | some c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in s.enrolled)\n  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | lone p:Project | some c:Course |\n  \t\tp in s.projects implies (p in c.projects and c in s.enrolled)\n  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | lone p:Project | all c:Course |\n  \t\tc in s.enrolled implies p in s.projects\n  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | lone p:Project | all c:Course |\n  \t\tc in s.enrolled and p in s.projects implies p in c.projects\n  \n}",
                    "{\n\t// Students work on at most one project per course\n    all student: Student, project: student.projects | lone course: Course | project in course.projects and course in student.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | some c : s.enrolled | one s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tPerson<:projects in Student -> one Project\n}",
                    "{\n\t// Students work on at most one project per course\n\t#Student<:projects <= 1\n}",
                    "{\n\t// Students work on at most one project per course\n\tlone Student<:projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tCourse <: projects in Course one -> one Student\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, c : Course | one pr : Project | pr in s.projects implies (c in s.enrolled and pr in c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student| some c : Course | one pr : Project | pr in s.projects implies (c in s.enrolled and pr in c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, c : Course | lone pr : Project | pr in s.projects implies (c in s.enrolled and pr in c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all p1, p2: s.enrolled.projects | p1 != p2 \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | one c: Course | c in s.enrolled implies\n  \t\t#(c.projects & s.projects) <=1\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all p1, p2: s.projects | one (s.projects & s.enrolled.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student | all c_p: s.enrolled.projects | one (s.projects & c_p)\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student, c : Course | one p : Project | p in c.projects and p in s.projects implies c in s.enrolled\n\n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student, c : Course | lone p : Project | p in c.projects and p in s.projects implies c in s.enrolled\n  \n  \t\n\n}",
                    "{\n\t// Students work on at most one project per course\n all s:Student | all c:Course | all p1,p2:Project | p1 in s.projects and  p2 in s.projects and c in s.enrolled implies p1 in c.projects and p2 in c.projects and p1 = p2\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s: Student| all p: s.projects | #(s.enrolled.projects) <= 1\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | some c: s.enrolled| #(s.projects & c.projects) > 0\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p: Project | all c: Course | one s: Student | c in s.enrolled and p in c.projects and p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p: Project | all c: Course | one s: Student | c in s.enrolled and lone s.projects }",
                    "{\n\t// Students work on at most one project per course\n\t    all s: Student | all c: Course| c in s.enrolled and lone p: c.projects | p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n  all c : Course | some enrolled.c.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s:Person,c:Course | s in Student && lone (s.projects & c.projects)\n   \n  \n\n}",
                    "{\n\t// Students work on at most one project per course\n  one s : Student | all p : Project | once(p in s.projects) or not(p in s.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | lone pr : Project | pr in (s.projects + s.enrolled.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student, c : Course | lone pr : Project | pr in (s.projects + c.projects)\n}",
                    "{\n\t// Students work on at most one project per course\n  all p:Person, c: p.enrolled, p1,p2 : p.projects | not (p1 in c.projects and p2 in c.projects)\n\n}",
                    "{\n\t\nall x:Person | all p1,p2:x.projects, c:Course | p1 in c.projects and p2 in c.projects implies p1!=p2\n  \n}",
                    "{\n\t// Students work on at most one project per course\n\tall s : Student | all p1,p2 : s.projects | one c : Course | p1 in c.projects and p2 in c.projects implies p1 = p2\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall s:Student | all c: Course | c in s.enrolled and lone p: Project | p in c.projects implies p in s.projects\n  \n \n  \n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall c : Course | some s : Student | one p : c.projects | p in s.projects\n}",
                    "{\n\t// Students work on at most one project per course\n\tno s : Student | some c : Course | lone c.projects & s.projects \n}",
                    "{\n\t// Students work on at most one project per course\n  \tall s : Student | s not in Professor and  all c : Course | c in s.enrolled implies #(c.projects) <= 1\n}",
                    "{\n\t// Students work on at most one project per course\n  \t\n    all s : Student, pr : s.projects | (Course <: projects).pr in s.enrolled\n}",
                    "{\n\t// Students work on at most one project per course\n  all s: Student | one p: Project | s.projects in s.enrolled.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n  all s: Student, c: Course | lone p: Project | c in s.enrolled implies p in s.projects & c.projects\n\n}",
                    "{\n\t// Students work on at most one project per course\n\tall p : Person | all c : Course | c in p.enrolled implies one c.projects \n}",
                    "{\n\t// Students work on at most one project per course\n\t\n\tall p: Student, c: Course| one y: Project | p in enrolled.c implies y in p.projects \n\n}",
                    "{\n\t// Students work on at most one project per course\n\t\n\tall p: Student, c: Course| one y: Project | p in enrolled.c implies y in p.projects and c.projects in p.enrolled \n\n}"
                ]
            },
            {
                "description": "A professor cannot teach herself",
                "pred": "this/inv8",
                "oracle": "{\n\t// A professor cannot teach herself\n\tall p: Professor | no (p.teaches & p.enrolled)\n}",
                "erroneous": [
                    "{\n\t\n\tall p : Professor | p.teaches not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Professor | p.enrolled not in p.teaches\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Professor | no p.teaches\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Professor | p.enrolled != p.teaches\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | all c : Course | not p in enrolled.c\n}",
                    "{\n\t// A professor cannot teach herself\n  all p : Professor|some c : Course | c in p.teaches implies p not in enrolled.c\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p:Professor , c:p.teaches| c in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tno(Professor.teaches & Professor.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor| all c : Course |not p in enrolled.c and not p in teaches.c\n  \n}",
                    "{\n\t// A professor cannot teach herself\n  \tall p : Person | p.enrolled not in p.teaches\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person-Student, c : Course | c in p.teaches implies c not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n all p: Person | p.enrolled !=none implies p.teaches=none\n}",
                    "{\n\t// A professor cannot teach herself\n\tno(Person.teaches & Person.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n            teaches.(~(enrolled)) not in iden\n\n\n\n}",
                    "{\n\t// A professor cannot teach herself\n       some (teaches & enrolled) implies (teaches.(~(enrolled)) not in iden)\n\n\n\n\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall p : Professor | no p.teaches.grades[p]\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p1:Professor, p2:teaches.(p1.teaches)-p1 | no (p1.teaches & p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person, c : Course | (p in Professor and p in c.teaches) and (p in Student and p in c.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n\t\n  \tteaches in Professor -> Student\n  \n}",
                    "{\n  all p: Professor, c: Course | p -> c in teaches and\n  some p2: Professor | p2 -> c in teaches and p != p2\n\t// A professor cannot teach herself\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor, c : Course | p in teaches.c and p in enrolled.c \n  \n  \tall p : Professor | no (p.teaches & p.enrolled)\n\n\t\n\n\t\n}",
                    "{\n\t// A professor cannot teach herself\n\tno p : Professor | all c : Course | p in teaches.c and p in enrolled.c \n  \n  \tall p : Professor | no (p.teaches & p.enrolled)\n\n\t\n\n\t\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Professor | (p.enrolled & p.teaches) = 0\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor| all c : Course | p in enrolled.c and p in teaches.c\n  \n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Person|\n  \t\tsome c: Course | c in p.teaches implies\n\t\t\tc not in p.enrolled\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor| all c : Course |not p in enrolled.c and p in teaches.c\n  \n}",
                    "{\n\t// A professor cannot teach herself\n  Professor.enrolled not in Professor.teaches\n\n}",
                    "{\n\t\n\tall p : Professor | enrolled.(p.teaches) & teaches.(p.teaches) = none\n}",
                    "{\n\t// A professor cannot teach herself\n \tall p: Professor | all c: Course |\n  \tp->c in enrolled implies p->c in teaches\n\n}",
                    "{\n\t// A professor cannot teach herself\n\n  all pr :  Professor, p : Person | p.teaches in Person implies p!=pr \n}",
                    "{\n\t// A professor cannot teach herself\n\tall c : Course | not one teaches.c & enrolled.c\n}",
                    "{\n\t// A professor cannot teach herself\n\tall c : Course | not one teaches.c & enrolled.c & Professor\n}",
                    "{\n\t// A professor cannot teach herself\n\n  all pr :  Professor, c : pr.enrolled | pr.teaches != c\n}",
                    "{\n\t// A professor cannot teach herself\n \tall p: Person, c: Course | p not in teaches.c implies p in Professor\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p1 : Professor | one c : Course | c in p1.teaches implies (c not in p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | all c : p.teaches | p.enrolled not in c\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | all c : p.teaches | p.enrolled != c\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall p: Professor | lone (p.teaches & p.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | teaches.p=Person-p\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | p.teaches=Person-p\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall c:Course | teaches.c not in enrolled.c\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p:Professor, c:Course | p in teaches.c implies (some g:Grade | p not in c.grades.g)\n}",
                    "{\n\t// A professor cannot teach herself\n\tall t : Professor | not one (t.enrolled & t.teaches)\n}",
                    "{\n\t// A professor cannot teach herself\n  \n  \tall x : Person - Student | x->x in teaches\n\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall pe : Person | pe.teaches != pe.enrolled \n}",
                    "{\n\t// A professor cannot teach herself\n  one p : Person | p.teaches != p.enrolled\n\t\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | all c : Course | not p in enrolled.c\n  \n  \tno teaches & enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person | some c : Course | p in Professor and c in p.teaches implies c not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person | some c : Course | p in Professor and c in p.teaches and c not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person | some p.teaches => p not in Student\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | some p.teaches => p not in Student\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | some p.teaches => p.teaches not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor|some c : Course | p.teaches= c implies not p.enrolled in c\n}",
                    "{\n\t\n  all p:Professor | all c: Course | c in p.teaches => all t:Project | t in c.projects => t not in p.projects  \n\n}",
                    "{\n\t// A professor cannot teach herself\n\t\n  \tProfessor.teaches != Professor.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n  all c : Course | one p : Professor |\n not (c in p.teaches and c in p.enrolled)\n  \n\n}",
                    "{\n\t// A professor cannot teach herself\n  all c : Course | one p : Person |\n not (c in p.teaches and c in p.enrolled)\n  \n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p1 : Professor | all p2 : Professor - p1 | all c : p1.teaches | p2 not in enrolled.c \n}",
                    "{\n\t// A professor cannot teach herself\n\t\n \tall p : Professor, c : Course | p.teaches not in p.enrolled \t\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall p : Professor | no teaches -> p\n\n}",
                    "{\n  all p: Professor, c: Course | p -> c in teaches iff\n  some p2: Professor | p2 -> c in teaches and p != p2\n\t// A professor cannot teach herself\n\n}",
                    "{\n  all p: Professor, c: Course | p -> c in teaches implies\n  some p2: Professor | p2 -> c in teaches and p != p2\n\t// A professor cannot teach herself\n\n}",
                    "{\n  no p: Professor | p in Student\n  all p: Professor, c: Course | p -> c in teaches implies\n  some p2: Professor | p2 -> c in teaches and p != p2\n\t// A professor cannot teach herself\n\n}",
                    "{\n  all c: Course |\n    \n    #c.teaches >= 2\n\t// A professor cannot teach herself\n\n}",
                    "{\n  all p: Professor, c: Course | p -> c in teaches and no (p.enrolled) implies\n  some p2: Professor | p2 -> c in teaches and no (p.enrolled) and p != p2 \n\t// A professor cannot teach herself\n\n}",
                    "{\n  all p: Professor, c: Course | p -> c in teaches and no(p.enrolled) implies\n  some p2: Professor | p2 -> c in teaches and no(p2.enrolled) and p != p2 \n\t// A professor cannot teach herself\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Professor | all c : p.enrolled | p.teaches not in c\n}",
                    "{\n\t// A professor cannot teach herself\n  \tall c1 : Professor.teaches, c2: Student.enrolled | no c1 & c2\n\n}",
                    "{\n\t// A professor cannot teach herself\n  \n  all p : Person |  (p.teaches & p.enrolled) = 0 \n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p : Person | one c : Course |\n  \t\tno (p.enrolled & p.teaches)\n}",
                    "{\n\t// A professor cannot teach herself\n\tnot (all p:Professor, c:Course | c in p.enrolled and c in p.teaches)\n}",
                    "{\n\t// A professor cannot teach herself\n\tno p : Professor | no p.teaches & p.enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n  all p : Person | p.teaches not in p.enrolled \n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall c1,c2: Course, p1, p2: teaches.c1 | c2 in p1.teaches => c2 not in p2.enrolled\n  \t\n}",
                    "{\n\t// A professor cannot teach herself\n  all p: Professor | all c: Course | p not in teaches.c and p in enrolled.c\n\n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Person | some (p.teaches) implies (p in Professor) \n}",
                    "{\n\t// A professor cannot teach herself\n\tall p: Person | some (p.teaches) implies (p in Professor) and no (p.enrolled)\n}",
                    "{\n\t// A professor cannot teach herself\n\tiden in teaches.~enrolled\n}",
                    "{\n\t// A professor cannot teach herself\n\tteaches.~enrolled in iden\n}"
                ]
            },
            {
                "description": "A professor cannot teach colleagues",
                "pred": "this/inv9",
                "oracle": "{\n\t// A professor cannot teach colleagues\n\n}",
                "erroneous": [
                    "{\n\t// A professor cannot teach colleagues\n  all p : Professor, c : Professor | no(p.teaches & c.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj a, b: Professor | no (a.teaches & b.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1: Professor, p2: Professor | all c: p1.teaches | p2 not in teaches.c\n}",
                    "{ all p : Professor | no (p.enrolled & p.teaches) }",
                    "{ \n\t// A professor cannot teach colleagues\n\n\t\n\t\n\n\t\n\n\tall c : Course | no (teaches.c & enrolled.c)\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a : Professor | no a.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p:Professor | all c:p.teaches | enrolled.c in Student \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p,p1: Professor |no (p.teaches & p1.enrolled) and p!=p1\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2: Professor | no p1.teaches & p2.teaches\n}",
                    "{ \n\t// A professor cannot teach colleagues\n\n\t\n\t\n\n\t\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\n\tall p : Professor, c : p.teaches | no teaches.c & enrolled.c\n\t\n\n\t\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor, c : Course | c in p1.teaches and c in p2.teaches implies c not in p1.enrolled and c not in p2.enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2 : Professor | p2 not in Student implies no (p1.teaches & p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | no teaches.(p.teaches) & enrolled.(p.enrolled) \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1,p2: Professor | not (p2.enrolled in p1.teaches)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Professor | a.teaches not in b.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p1:Professor | all p2:Professor -p1 | p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Professor, c : Course | c in p1.teaches and c in p2.teaches implies p1.enrolled not in p2.teaches and p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Professor | a.teaches != b.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall t:Professor | some t2:Professor | no t2.enrolled & t.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Person-Student | no p.teaches & (Professor-p).enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor | p1.enrolled not in (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n  \tall p : Professor, c : p.enrolled, s : enrolled.c | not (some c1 : Course | p->c1 in teaches and s->c1 in enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course| enrolled.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor | no p.teaches.grades[Professor]\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person , c :Course | c in a.teaches implies c not in b.enrolled \n  \t\n\n}",
                    "{\n\t\n  \tall c: Course | all p: Professor | c in p.teaches and c not in p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n\tall p:Professor | no p1:Professor | some (p.teaches & p1.teaches) implies p1.enrolled in p.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor, p2 : Professor | some (p1.teaches & p2.teaches) implies \n  \t\tno ( p1.teaches & p2.enrolled) or no ( p2.teaches & p1.enrolled)\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : Course |\n\t\tc in p.teaches implies no p2 : Professor | c not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | p1 not in Student and p2 not in Student implies (p1.enrolled & p2.teaches) = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all x,y : Professor |no c : Course| x!=y implies c in (x.teaches & y.teaches)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p,z : Professor | p != z and some p.enrolled & z.enrolled implies no p.teaches & z.enrolled and no z.teaches & p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor | p not in Student implies p not in Course.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2: Professor | some p1.teaches & p2.teaches => p1.enrolled not in p2.teaches and \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tp2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1,p2 : Professor | some c : Course | p1.teaches in c and p2.teaches in c implies p1.teaches not in p2.enrolled and p2.teaches not in p1.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tsome disj p1, p2 : Person | some (p1.teaches & p2.teaches) implies no (p1.teaches & p2.enrolled) \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor, p2 : Professor | some (p1.teaches & p2.teaches) implies \n  \t\tnot ( p1.teaches in p2.enrolled)\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Professor, c : Course | c in a.teaches iff c not in b.enrolled \n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | lone teaches.c \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2 : Professor| some c : Course | c in p1.teaches && c in p2.teaches => no (p1.enrolled & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2: Person | some p1.teaches & p2.enrolled => p2 in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | p1.teaches!=none implies (p1.enrolled & p2.teaches) = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p,p1: Professor | no (p.teaches & p1.teaches) implies no (p.teaches & p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\tall p:Professor |\n  \t\t\tsome c:p.teaches |\n  \t\t\t\tc in p.teaches implies c not in Professor-p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor | p2 not in Student implies no (p1.teaches&p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p: Professor | p.teaches not in p.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tteaches.~enrolled.teaches = univ->univ\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tteaches.~enrolled.teaches = none->none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Professor | p1.teaches in p2.enrolled => p2 not in p1.teaches.~teaches \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor-p1 | (some p1.enrolled and p1.enrolled in p2.teaches) implies no (p1.teaches & p2.teaches) \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p:Professor | all c:p.teaches | teaches.c not in enrolled.c   \n\n}",
                    "{ \n\t// A professor cannot teach colleagues\n\n\t\n\t\n\n\t\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\n\tall p1 : Professor | no p2 : Professor | \n\t  (some p1.teaches & p2.teaches)\n\t   implies\n\t  (no p1.teaches & p2.enrolled)\n\n\t\n\n\t\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | no p.teaches & (Person-Student-p).enrolled \n}",
                    "{ all p : Professor & Student | no ((Professor & Student - p).enrolled & p.teaches) }",
                    "{ all p : Professor | no (((Professor & Student)-p).enrolled & p.teaches) }",
                    "{\n\t\n  all p: Professor, p1: Professor - p, c: Course| c in p.teaches and c not in p1.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor, c: p.teaches| enrolled.c not in Professor-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2: Professor | some p1.teaches & p2.teaches => no p1.enrolled & p2.enrolled\n}",
                    "{\n   all p: Professor | no p2: Professor | no(p.teaches & p2.enrolled)\n\t// A professor cannot teach colleagues\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | enrolled.c not in Professor \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tno Professor & Student\n    no Professor -> Professor & teaches.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2: Professor, c1, c2: Course | some s: Student | p1->c1 in teaches and p2->c2 in teaches and s in (c1.enrolled & c2.enrolled) implies p2 not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | p not in Student implies no enrolled.(p.teaches) <: Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | some c1, c2: Course |\n  \t\tc1 in p1.teaches and c1 in p2.teaches implies\n  \t\t\t(c2 in p1.teaches) and (c2 not in p2.enrolled) or \n  \t\t\t(c2 in p2.teaches) and (c2 not in p1.enrolled)\n  \t\t\t\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2 : Professor | p2 not in Student implies no (p1.teaches & p2.enrolled) and no (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | teaches.c in Professor implies enrolled.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p, p1 : Professor | all c : Course | p != p1 and p in teaches.c implies not p in enrolled.c\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | teaches.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2:Person | all t1:p1.teaches |all t2:p2.teaches| t1 = t2 and p1 != p2 implies t1 not in p1.enrolled and t1 not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p: Professor, c: p.teaches | all pe: Person - p | c in pe.enrolled => no pe.teaches & c\n\n}",
                    "{\n\t\n  \t\n\tall p:Professor | no p1:Professor | some (p.teaches & p1.teaches) implies  some (p1.enrolled & p.teaches )\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 :Professor | all t1:p1.teaches | all t2:p2.teaches | t1 = t2 implies p1.enrolled not in t1\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Person | all p2 : Person | some (p1.enrolled & p2.enrolled) implies no p1.teaches & p2.enrolled  \n}",
                    "{\n   // A professor cannot teach colleagues\n   all p: Professor | all c: p.teaches | \n      no p2: Professor | c in p2.enrolled \n      and not (c in p.enrolled)\n}",
                    "{\n   \n   all p: Professor | \n      all c: p.teaches | \n         no p2: Professor | c in p2.enrolled\n         and not (c in p.enrolled)\n         and no s: Student | s in Professor and c in s.enrolled\n}",
                    "{\n  // A professor cannot teach colleagues\n  all p: Professor |\n    all c: p.teaches |\n      all p2:Person | c in p2.enrolled implies (no c1:Course | c1 in p2.teaches) \n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p, p2 : Professor |p not in Student and p2 not in Student implies p.teaches & p2.enrolled = none and p.enrolled & p2.teaches = none\n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno disj p,p1 : Professor | (some p1.enrolled & p.teaches) or p1 in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2: Professor | p1.teaches in p2.teaches implies p2.teaches not in p1.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall prof : Professor, col : Professor - prof | prof.teaches not in col.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2: Person | all c: Course | c in p1.teaches and c in p2.enrolled implies p2 not in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person, c : Course | c in a.enrolled and c in b.enrolled implies a.enrolled not in b.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person, c : Course | c in a.teaches and c in b.enrolled implies a.enrolled not in b.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Person-Student | p1.enrolled not in p2.teaches and p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all t : Professor, t1 : Professor | some t.enrolled & t1.teaches or some t.teaches & t1.enrolled => t1 in Student or t in Student\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | Professor-p not in p.teaches  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | (Professor-p).enrolled not in p.teaches  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | all a : enrolled.c |\n\t\tno ( p.teaches - a.teaches) \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall t : Professor | (all te : t.enrolled | Professor - t not in  t.teaches ) \n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\tall p:Professor |\n  \t\t\tsome c:p.teaches |\n  \t\t\t\tc in p.teaches implies c not in (Professor-p).enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Professor | some c : Course | p1 in teaches.c and p2 in teaches.c implies no(p1.enrolled & p2.teaches) and no (p1.teaches & p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all t : Professor - Student, t1 : Professor-Student | no t.enrolled & t1.teaches and no t.teaches - t1.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p: Professor, c: p.teaches | all pe: Person - p | c in pe.enrolled => one c & pe.teaches\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n   all p1 : Professor, p2 : Professor | p1!=p2 and some (p1.teaches & p2.teaches) implies \n          no ( p1.teaches & p2.enrolled) or no ( p2.teaches & p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2 : Professor, c : Course | c = p1.teaches && c = p2.teaches => no (p1.enrolled & c)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, p1: Professor - p, c: Course| p1 not in enrolled.c\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p : Professor, t:Person | (p.teaches & t.enrolled) in Student\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall pr : Professor, p : Person | p.enrolled in pr.teaches implies p in Student \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1,p2:Person | all c:Course | c in p1.teaches and c in p2.enrolled implies p2 not in Professor\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | not (p.teaches in Professor.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Person | all p2:Person-p1 | no (p1.enrolled & p2.enrolled) and no (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor-p1 | no (p1.enrolled & p2.enrolled) and no (p1.teaches & p2.teaches)\n}",
                    "{\n   all p: Professor | some p2: Professor | not(p.teaches in p2.enrolled )\n\t// A professor cannot teach colleagues\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all p,p1 : Professor | p!=p1 and (some p.teaches & p1.teaches) implies (some p.enrolled & p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor, c : Course |\n  \t\tc in p.teaches and c in p2.teaches iff (\n          \tc not in (p.enrolled + p2.enrolled))\n                    \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | all c:Course | \n  \t\tc in p1.teaches implies (some p2: Student | c in p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p,z : Professor | some p.enrolled & z.enrolled implies no p.teaches & z.enrolled and no z.teaches & p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall x1, x2: Person | one c: Course | (c in x1.teaches and c in x2.teaches) \t\t\timplies (not c in x1.enrolled) or (not c in x2.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p: Professor, s: Student, c: Course | p->c in teaches and s in Professor implies s->c not in enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | no p2 : Professor | (p2.enrolled in p1.teaches) and (p2.teaches in p1.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p : Professor | no enrolled.(p.teaches) & teaches.(p.enrolled) \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | teaches.c in Professor implies enrolled.c not in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | lone (teaches.c) and teaches.c in Professor implies enrolled.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | teaches.c not in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n  Professor.enrolled not in Professor.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor| Professor.^enrolled not in p1.^teaches \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | Professor-p in p.teaches  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | one teaches.c-Person-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \n  all pr : Professor |  (enrolled.(pr.teaches)) in (Student + Professor)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p : Professor | some s : Person - Student | no (p.teaches & s.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p : Professor | some s : Person - Student | no (p.teaches & s.enrolled & p.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno c : Course | some p : Professor-Student | p in c.(~enrolled) and p in c.(~teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor | p.teaches not in p.teaches.(~teaches).enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n \tall p1 : Professor | no p2 : Professor |  all c:p1.teaches |\n  \t\tp2 in teaches.c and p2 in enrolled.c\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Professor | p2.teaches not in none && p2.teaches in p1.teaches => p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Professor, c : Course | c in a.teaches implies c not in b.enrolled and c in b.teaches implies c not in a.enrolled\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2 : Professor, c : Course | ((p1 not in enrolled.c) iff (p2 not in teaches.c)) and ((p2 not in enrolled.c) iff (p1 not in teaches.c))  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n\tall disj p1: Professor, p2: Professor | some (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t all p:Professor | all c:p.teaches | all pe:enrolled.c| p in Student \n  \t\n\t\n}",
                    "{\n\t\n  \t\n\tall p:Professor | no p1:Professor |  some (p.teaches & p1.teaches) implies  (p1.enrolled in p.teaches and p1!=p)\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person-Student, c : Course | c in a.teaches implies c not in b.enrolled \n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Professor, c : Course | c in p1.teaches implies c not in p2.enrolled and c in p2.teaches implies c not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a: Person | some a.teaches implies no a.enrolled \n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a: Person-Student | some a.teaches implies no a.enrolled \n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all disj a,b : Person | b.enrolled not in a.teaches\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person | a.enrolled in b.teaches implies a not in Professor\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person | a.enrolled in b.teaches implies a in Student\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person | a.enrolled in b.teaches implies b.enrolled not in a.teaches\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person | some a.teaches and some b.teaches implies a.enrolled not in b.teaches and b.enrolled not in a.teaches\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Professor | some a.teaches and some b.teaches implies a.enrolled not in b.teaches and b.enrolled not in a.teaches\n  \t\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person, c : Course | c in a.teaches and c in b.teaches implies a.teaches not in b.enrolled and b.teaches not in a.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person | a.teaches != b.enrolled and b.teaches!= a.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all a,b : Person-Student | a.teaches != b.enrolled and b.teaches!= a.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Person, c : Course | c in p1.teaches and c in p2.teaches implies p1.enrolled != p2.teaches and p2.enrolled != p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Professor, c : Course | c in p1.teaches and c in p2.teaches implies p1.enrolled != p2.teaches and p2.enrolled != p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all t : Professor, t1 : Professor - Student | no t.enrolled & t1.teaches and no t.teaches & t1.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1,p2 : Professor | all c : Course | p1.teaches in c and p2.teaches in c implies p1.teaches not in p2.enrolled and p2.teaches not in p1.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1,p2 : Professor | some c : Course | c in p1.teaches and p2.teaches in c implies p1.teaches not in p2.enrolled and p2.teaches not in p1.enrolled\n\n}",
                    "{\n\t\n  \tall a,b : Professor | some c : Course | c in a.teaches and c in b.teaches implies  c not in b.enrolled and  c not in a.enrolled  \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1,p2 : Professor | some c : Course | c in p1.teaches and c in p2.teaches implies p1.teaches not in p2.enrolled and p2.teaches not in p1.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1,p2 : Professor | (some c : Course | c in p1.teaches and c in p2.teaches) implies p1.teaches != p2.enrolled \n}",
                    "{\n\t\n  \tall a,b : Professor | (some c : Course | c in a.teaches and c in b.teaches) implies no a.teaches-b.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 : Professor | some c : Course | (p1 in teaches.c and p2 in teaches.c) implies (p1 not in enrolled.p2 and p2 not in enrolled.p1)  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : (Professor-Student) | ((Professor-Student)-p).enrolled not in p.teaches  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Person-Student | (Person-Student-p).enrolled not in p.teaches  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | no p.teaches & (Person-p).enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Person-Student | no p.teaches & (Person-Student-p).enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all t : p.teaches | teaches.t not in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all t : p.teaches | teaches.t in Student \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | enrolled.c in Professor \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | all p : Person | some(p.enrolled) => p in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | all p : Person | p.enrolled in c => p in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : p.teaches | all a : enrolled.c |\n\t\tp.teaches != a.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Person | some c : Course | c in p.teaches implies no p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tsome p1 : Person, p2 : Person | all c : Course | c in (p1.teaches & p2.teaches) implies no (p1.teaches & p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall t : Professor | (all te : t.enrolled | (Professor - t).enrolled not in  t.teaches ) \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor, c: Course |\n  \t\tc in p.teaches => no (enrolled.c & (Professor->(p.projects)).Project)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all c:Course| not (teaches.c in (enrolled.c))\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor | one c: Course | c not in p.enrolled\n}",
                    "{\n\t\n  \tall c: Course | some p: Professor | c in p.teaches \n\tall p: Professor | all c: Course | c not in p.enrolled\n}",
                    "{\n\t\n  \tall c: Course | some p: Professor | c in p.teaches and c not in p.enrolled\n}",
                    "{\n  \n  all p1, p2: Professor, c: Course |\n    p1.teaches = c and p2 in Professor - p1 implies c not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n    all disj p1, p2 : Professor | (some c : Course | c in p1.teaches and c in p2.teaches) => (no c2 : Course | c2 in p1.teaches and c2 in p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall u: Person-Student | #u.enrolled=0\n\tall disj p1,p2: Professor | all c: p1.teaches | c not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p : Professor | all c : p.teaches | c.grades not in p.grades\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | no p1 : Professor | no(p.teaches & p1.enrolled) and no(p.teaches & p1.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2: Professor, ce: p2.enrolled | ce not in p1.teaches iff p1 != p2\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor, p2 : Professor | some (p1.teaches & p2.teaches) implies \n  \t\tnot ( p1.teaches in p2.enrolled) or not ( p2.teaches in p1.enrolled)\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor, p2 : Professor | some (p1.teaches & p2.teaches) implies \n  \t\tno ( p1.teaches & p2.enrolled) or not ( p2.teaches in p1.enrolled)\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p,p1: Person | all c : p.enrolled | c not in p1.teaches => p1.enrolled not in c\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1, p2 : Professor, disj c1, c2 : Course | (c1 in p1.teaches and c2 in p2.teaches) implies c2 not in p1.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1, p2 : Professor, disj c1, c2 : Course | (c1 in p1.teaches and c2 in p1.teaches) implies (c2 not in p1.teaches and c2 not in p2.enrolled)\n \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p1, p2 : Professor, disj c1, c2 : Course | (c1 in p1.teaches and c1 in p2.teaches) implies (c2 not in p1.teaches and c2 not in p2.enrolled)\n \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall pe1,pe2 : Person, enroll1 : pe1.teaches, enroll2 : pe2.teaches |  \t\t\t(((pe1.teaches & (enroll1 & enroll2)) = none) and \t\n      \t((pe2.teaches & (enroll1 & enroll2)) = none))\n  \t\t\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall  disj t,t1 : Person | t in Professor and t1 in Professor and no t.teaches&t1.enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 :Professor | all en:p2.enrolled | \n  \t\t\ten not in p1.teaches iff en in p1.teaches and en in p2.teaches and p1 != p2\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2 :Professor | all en:p2.enrolled | \n  \t\t\ten not in p1.teaches implies en in p1.teaches and en in p2.teaches and p1 != p2\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p: Professor, c: p.teaches | all pe: Person - p | c in pe.enrolled => no pe.teaches\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p: Professor, c: p.teaches | all pe: Person - p | c in pe.enrolled => pe.teaches & p.teaches != c\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2 : Person | some c : Course | p1 in Professor and p2 in Professor and c in p1.teaches implies c not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Person | p1 in Professor and p2 in Professor and p2 not in Person.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all p1, p2: Professor, c: Course |\n        (p1.teaches & c.grades.p1 in Professor) => (p2.teaches & c.grades.p2 in Professor) => p1 = p2\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2: Person | some p1.teaches & p2.enrolled => p2 in Student or p1 = p2\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor | some x:Professor, c:Course | c in x.enrolled implies p.teaches = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor | p1 not in Student implies p1.teaches not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor | p2 not in Student implies p1.teaches not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor | p1 not in Student implies no (p1.teaches&p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p,p2:  Professor | all c : Course| p.teaches in c\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p,p2:  Professor | all c : Course| p.teaches in c implies not (p2.enrolled in c)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  no disj p1,p2 : Professor | all c:Course | c in p1.teaches and c in p2.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  no c:Course | all disj p1,p2:Professor | c in p1.teaches and c in p2.enrolled\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno p : Professor | some c1 : Course, c2: Course, x : Person | c1 in p.enrolled and c1 in x.enrolled and c2 in p.teaches implies c2 not in x.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno p : Professor | all c1 : Course, c2: Course, x : Person | c1 in p.enrolled and c1 in x.enrolled and c2 in p.teaches implies c2 not in x.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n\tall x : Person | (x.enrolled = none) implies x in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n  \tall p : Professor, c : Course | p->c in teaches implies no Professor.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n  \tall p : Professor, c : Course | p->c in teaches implies Professor not in enrolled.c\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all c : Course | some p : Professor | all ps : Person |\n  (c in p.teaches and c in ps.enrolled and ps != p) implies ps not in Professor \n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | all p2 : Professor-p1 | all c : p1.teaches | p2.enrolled not in c\n}",
                    "{\n\t// A professor cannot teach colleagues\n  one c : Course | all p,ps : Professor |\n  (c in p.teaches and c in ps.enrolled and ps != p) implies c not in ps.teaches \n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | all c : Course |\n\t\tc in p.teaches implies no p2 : Professor | c.grades[p2] = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2: Person | some c1, c2: Course | c1 in p1.teaches and c1 in p2.enrolled implies c2 not in p1.teaches and c2 not in p2.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1,p2: Person | one c1,c2: Course | c1 in p1.teaches and c1 in p2.teaches and c2 in p1.teaches implies c2 not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course, p : Professor | c in p.teaches and enrolled.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | one teaches.c \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | one teaches.c-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | lone teaches.c-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c:Course | enrolled.c not in Professor\n}",
                    "{\n    // A professor cannot teach colleagues\n  \tnot (Professor in Student)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor, c: p.teaches| enrolled.c in Person-Professor or enrolled.c in Person-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor, c: p.teaches| enrolled.c not in Person-Professor \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Person | all p2:Person | p1.enrolled not in (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, p2 : Professor-p, c : Course, c2 : Course-c | (p->c in enrolled and p2->c in enrolled) implies (not (p->c2 in teaches and p2->c2 in teaches))\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, p2 : Professor-p, c : Course | (p->c in teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, p2 : Professor, c : Course | (p->c in teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, p2 : Professor-p, c : Course | (p->c in teaches) implies (not (p2->c in enrolled and p->c in enrolled))\n}",
                    "{\n    // A professor cannot teach colleagues\n all p: Professor | all p2: Professor | some p2.enrolled implies not(p.teaches in p2.enrolled)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor | some (p1.enrolled) implies p1.enrolled not in (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p : Professor, c : Course | enrolled.c not in Person-Professor\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Professor, c: p.teaches| enrolled.c not in Person-Professor-Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall c : Course | enrolled.c not in Person-Professor\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor-p1 | no (p1.enrolled & p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n  \t\n  \n  all p1:Professor | all p2:Professor-p1 | some p1.enrolled implies no (p1.teaches & p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1:Professor | all p2:Professor-p1 | no (p1.teaches & p2.teaches) implies (some p1.enrolled and p1.enrolled in p2.teaches)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p : Professor , c : p.teaches |\n  \t\tno Professor-Student & enrolled.c \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2 : Professor | (some p2.teaches + p2.enrolled) implies (no p1.teaches + p1.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : p.teaches |\n  \t\tc in p.teaches and c in p2.teaches and (\n          c not in p2.enrolled)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : p.teaches |\n  \t\tp2.teaches in c implies (\n          p2.enrolled not in c)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : p.teaches |\n  \t\tp2.teaches in c and p.teaches in c implies (\n          p2.enrolled not in c)\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : Course |\n  \t\tc in p.teaches or c in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall disj p,p2 : Professor | all c : Course |\n  \t\tc in p.teaches or c in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall disj p,p2 : Professor | all c : p.teaches |\n  \t\tc in p2.teaches or c in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : Course |\n  \t\tp.teaches != p.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall p,p2 : Professor | all c : Course |\n  \t\tp.teaches != p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | all c:Course | one p2 : Person |\n  \t\t(c in p1.teaches and c in p2.enrolled) implies p2 in Student \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | all c:Course | some p2 : Person |\n  \t\t(c in p1.teaches and c in p2.enrolled) implies p2 in Student \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1,p2 : Professor |\n  \t\tsome c:Course | c in p1.teaches implies not (c in p2.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n \tall disj p1,p2:Professor | all c:Course|\n  \t\tc in p1.teaches implies ((not c in p2.teaches) and (not c in p2.enrolled))\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \n  all p : Person | (p in Professor and p in Student) implies  (p.teaches & p.enrolled = none )\n  \n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p: Person, c: Course, g: Grade | c->p->g in grades implies p in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor, c : p.teaches |\n  \t\tno Professor-p & teaches.c\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall x,y : Professor | some c : Course | c in x.teaches implies not c in y.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1 : Professor | no p2 : Professor | p2 in enrolled.(p1.teaches) and p2.teaches in teaches.(p1.teaches)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2:Professor, c:Course | c in p1.teaches implies c in p2.enrolled \n}",
                    "{\n\t// A professor cannot teach colleagues\n  all disj p1,p2: Person | (p1.teaches & p2.enrolled) = none\n    \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  all p1,p2: Person | p1 != p2 and (p1.teaches & p2.enrolled) = none\n    \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | one (teaches.c) and teaches.c in Professor implies enrolled.c in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c : Course | lone (teaches.c & Professor) and (teaches.c in Professor implies enrolled.c in Student)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t\n\tall p1, p2 : Person | some (p1.teaches & p2.enrolled) implies p2 in Student and p1 in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | p1.teaches!=none iff (p1.enrolled & p2.teaches) = none\n}",
                    "{\n  all disj p,p1 : Professor| all c : Course | p not in Student and  c in p.teaches implies c not in p1.enrolled \n  \n\t// A professor cannot teach colleagues\n\n}",
                    "{\n  all disj p,p1 : Professor| all c : Course | p not in Student and p1 not in Student and c in p.teaches implies c not in p1.enrolled  or c in p1.teaches implies c not in p.enrolled \n  \n\t// A professor cannot teach colleagues\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p, p1 : Professor | all c : Course | p != p1 implies (p in teaches.c => p1 not in enrolled.c)implies p1 not in enrolled.c\n  \n}",
                    "{\n \n  // A professor cannot teach colleagues\n  some p: Professor | p in Person \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c: Course | teaches.c not in c.enrolled\n}",
                    "{\n    \n    all p1, p2: Professor, c: Course | \n        (p1->c in teaches and p2->c in enrolled) implies no (enrolled & teaches)\n}",
                    "{\n    \n    all p1 : Professor | all p2 : Person - Professor |\n  \t\tp2 in teaches.(p1.teaches) and p2 in enrolled.(p1.teaches)\n\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p: Professor, c: p.teaches | (teaches.c - p) not in enrolled.c\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \t\n  \tall disj p1, p2: Professor | #(p1.teaches & p2.enrolled) <= 1\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | no ( p.teaches.grades.Grade & p.enrolled.grades.Grade)\n}",
                    "{\n\t\n  \t\n\tall p: Professor | all c: Course | \n  \tc in p.enrolled \n  \timplies \n  (enrolled.c).enrolled not in p.teaches\n}",
                    "{\n\t\n  \t\n\tall p: Professor | all c: Course | all s: Student |\n  \tc in p.enrolled implies (\n  \t\tc in s.enrolled implies (\n\t\t\tno s.enrolled - c & p.teaches\n      \t)\n  \t)\n}",
                    "{\n\t\n  \t\n\tall p: Professor | all c: Course | all s: Student |\n  \tc in p.enrolled implies (\n  \t\tc in s.enrolled implies (\n\t\t\tno s.enrolled & p.teaches\n      \t)\n  \t)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2 : Person | p1 != p2 and some (p1.enrolled & p2.enrolled) implies no p1.teaches & p2.enrolled  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | (enrolled.(p.teaches) & Professor) not in (Professor - p)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | (enrolled.(p.teaches) & Professor) not in p.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | all c:Course |( c in p1.teaches and p1 != p2 and c in p2.teaches) implies (c not in p2.enrolled or c not in p1.enrolled)\n  \n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1, p2: Professor | some c:Course |( c in p1.teaches and p1 != p2 and c in p2.teaches) implies (c not in p2.enrolled or c not in p1.enrolled)\n  \n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n  \n  all p : Professor | enrolled.(p.teaches) not in Professor \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tsome c : Course | no p : c.(~enrolled) | (some c.~teaches & Professor) and (some p & Professor)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno c : Course | ( c.~enrolled & c.~teaches) in Professor\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno p : Professor | p.teaches.~enrolled in (Person - Student)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | some c : Course , p1 : Professor | p in c.(~enrolled) and \t  p1 in c.~teaches \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | some c : Course , p1 : Professor - Student | \n    p in c.(~enrolled) and p1 in c.~teaches \n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all p: Professor | {\n        \n        all c: p.teaches | {\n            \n            no c.~enrolled & Professor\n            \n            no c.grades[Professor]}}\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all disj p,p1 : Professor | some c : p.teaches | p not in Student \n  \t\timplies (c in p1.enrolled implies p1 in Student)\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all p1 : Professor , c : Course | let map = p1 -> c.~enrolled | \n  \t\tsome p2 : Professor |\n  \t\t\tp1 in c.~teaches and p2 not in p1.map\n}",
                    "{\n\t// A professor cannot teach colleagues\n\t all disj p1,p2 : Professor | p1.teaches & p2.enrolled = none and \n  \t\tp1.teaches & p2.teaches != none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Person | some p.teaches implies p in Professor\n  \t\n\tall p:Person | some p.enrolled implies p in Student\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p:Person | some p.teaches implies p in Professor\n  \tall p: Person | p in Professor implies p not in Student\n  \t\n\tall p:Person | some p.enrolled implies p in Student\n}",
                    "{\n   // A professor cannot teach colleagues\n   all p: Professor | all c: p.teaches | \n      no p2: Professor | c in p2.enrolled \n      and not (c in p.enrolled)\n  \tand p not in Student\n}",
                    "{\n   // A professor cannot teach colleagues\n   all p: Professor | all c: p.teaches | \n      no p2: Professor | c in p2.enrolled \n      and not (c in p.enrolled)\n  \tand p not in Student and p2 not in Student\n}",
                    "{\n  \n  all p:Person | p in Professor <=> p not in Student\n  all p: Professor | \n    all c: p.teaches | \n      no p2: Professor | c in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tPerson = Professor + Student\n  \t(Professor & Student) = none\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno p:Professor | p not in Student implies p not in Course.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tno p:Professor | p not in Student implies p in Course.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall disj p, p2 : Professor |p not in Student and p2 not in Student iff p.teaches & p2.enrolled = none and p.enrolled & p2.teaches = none\n  \n\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2: Professor | p1.teaches in p2.teaches implies p1.teaches not in p2.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2: Professor |\n  \t\tp1.teaches in p2.teaches iff p2.teaches not in p1.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p1: Person | all p2: Professor |\n  \t\tp1.teaches in p2.teaches implies p2.teaches not in p1.enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor | all coll: Person-p | coll.teaches in p.teaches implies p.teaches & coll.enrolled = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor | all coll: Professor-p | coll.teaches in p.teaches implies p.teaches & coll.enrolled = none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | (p.teaches.~teaches - p) not in p.teaches.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p : Professor | (p.teaches.~teaches) not in p.teaches.~enrolled\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tteaches.~enrolled.teaches not in iden\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tteaches.~enrolled.teaches.~teaches not in iden\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tteaches.~enrolled & enrolled.~teaches = none->none\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Professor | p2.teaches in p1.teaches => p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall disj p1, p2 : Professor | p1.teaches in p2.teaches => p2.enrolled not in p1.teaches\n}",
                    "{\n\t// A professor cannot teach colleagues\n  \tall p1, p2 : Professor, c : Course | not (p1.enrolled in p2.teaches) and not (p2.teaches in p1.enrolled)\n\n}",
                    "{\n\t\n  \n\n  all p: Person, c: Course | c in p.teaches implies p in Professor and p not in c.enrolled\n}",
                    "{ \n\t\n  \n  \n  all p1, p2: Professor, c: Course | (c in p1.teaches implies p2 & p1 not in enrolled.c) and (c in p2.teaches implies p1 & p2 not in enrolled.c)\n  \n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall p: Professor,c: Course | some p1: Professor | p in enrolled.c implies p1 not in teaches.c\n}",
                    "{\n\t// A professor cannot teach colleagues\n\tall c: Course | some p1: Professor,p: Professor | p in enrolled.c implies p1 not in teaches.c\n}"
                ]
            },
            {
                "description": "Only students have grades",
                "pred": "this/inv10",
                "oracle": "{\n\t// Only students have grades\n\tCourse.grades.Grade in Student\n}",
                "erroneous": [
                    "{\n\t// Only students have grades\n\t\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | all p : Person.(c.grades) | p in Student\n}",
                    "{\n\t// Only students have grades\n\tall p : Person | some p.enrolled.grades => p in Student\n}",
                    "{\n\tall p: Person | some c: Course | (p -> c) in c.grades implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p: Person | p->Grade in c.grades implies p in Student\n}",
                    "{\n\t// Only students have grades\n\n\t\n\t\n\n\t\n\t\n\n\t\n\n\t\n  all p : Person | some p.(p.enrolled.grades) implies p in Student\n}",
                    "{\n\t// Only students have grades\n  \tall p : Person | all g : Grade | p->g in Course.grades => p in Student\n  \n  \tsome grades.(Person->Grade)\n}",
                    "{\n\t// Only students have grades\n  \n  all c : Course, s: Student | some c.grades.Person & s \n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p : Person | c.grades[p] in Grade => p in Student\n}",
                    "{\n\t// Only students have grades\n\tall s:Student | all c:Course | all g:Grade | s in c.grades.g \n}",
                    "{\n\t// Only students have grades\n  all p : Person | p in Student implies some p.grades\n\n}",
                    "{\n\t// Only students have grades\n\tall s : Person | all g : Grade|  s in Student and s->g in Course.grades\n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p: Professor-Student | all g:Grade| p->g not in c.grades\n}",
                    "{\n\t// Only students have grades\n\tall g:Grade | all p:Person | some (grades.(g->p)) implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall c: Course, p: Person | c not in p.enrolled implies no p.(c.grades)\n}",
                    "{\n\t// Only students have grades\n\tall p : Person - Student | #p.enrolled.grades + #p.teaches.grades = 0 \n}",
                    "{\n\t// Only students have grades\n\tall p : Person - Student | #p.enrolled.grades = 0 and \n  \tno #p.enrolled.grades[p]\n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p: Professor-Student |some g:Grade| p->g not in c.grades\n}",
                    "{\n    // Only students have grades\n  all p: Professor | all c: Course | not (p->Grade) in c.grades\n\n}",
                    "{\n\t// Only students have grades\n\tall s : Person | all g : Grade|  s in Student implies s->g in Course.grades\n}",
                    "{\n\t// Only students have grades\n  all p: Person-Student | no c: Course | no c.grades[p]\n\n}",
                    "{\n\t// Only students have grades\n  all s: Student, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades\n\n}",
                    "{\n\t// Only students have grades\n\tall s: Student, c: Course | some s.enrolled.grades\n\n}",
                    "{\n  \n  all p : Person | some c : Course, g : Grade | c->p->g in grades implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall p : Person, c : Course | some g : Grade | grades[p,g] in Student and grades[p,g] not in Professor\n}",
                    "{\n\t// Only students have grades\n   all p : Professor | no Course.grades->p\n\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall p : Person  | all c : p.enrolled | some g : Grade | p->g in c.grades implies p in Student\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall pr : Professor | all class : pr.enrolled+pr.teaches | no g : Grade | pr->g in class.grades\n  \n\n  \t\n}",
                    "{\n\t// Only students have grades\n\tall p:Student | some p.enrolled.grades\n}",
                    "{\n\t// Only students have grades\n\tall p : Person | all c : Course | one c.grades[p] => p in Student  \n\n}",
                    "{\n\t// Only students have grades\n\tall p: Person | all c: Course | all x: c.grades[p] | p not in Student\n}",
                    "{\n  all s: Student, c: Course | some c.grades[s]\n\t// Only students have grades\n\n}",
                    "{\n\t// Only students have grades\n  \t\n  \tall s : Student |\n\t\ts in Course.grades.Grade  \n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p: Person-Professor | all g:Grade | p->g not in c.grades\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall p: Person | p->Grade in Course.grades implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall p: Person | #p.enrolled.grades > 0 implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall c: Course | some (c.grades.Person & Student) \n}",
                    "{\n\t// Only students have grades\n   Professor not in Course.grades.Person\n\n}",
                    "{\n\t// Only students have grades\n\tall p: Person | all c: Course | lone c.grades[p]\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall p: Person | all c: Course | some c.grades[p]\n}",
                    "{\n\t// Only students have grades\n\tall p : Person, c : Course, g : Grade | p.(c.grades) in g implies p in Student and p not in Professor\n}",
                    "{\n\t// Only students have grades\n\tall p : Person, c : Course | some g : Grade | p.(c.grades) in g implies p in Student and p not in Professor\n}",
                    "{\n\t// Only students have grades\n\tall p : Person, c : Course | some g : Grade | p.(c.grades) in g implies p not in Professor\n}",
                    "{\n\t// Only students have grades\n\tall p : Person, c : Course | some g : Grade | p.(c.grades) in g implies c in p.enrolled and p not in Professor\n}",
                    "{\n\t// Only students have grades\n    all c : Course, s : Student | (s.enrolled.grades in c.grades)\n\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | some p : Person | some (c.grades[p]) => p in Student\n\n}",
                    "{\n\t// Only students have grades\n    all p: Person | p in Professor or p in Student\n    all s: Student | s.grades = Course->Grade\n    all p: Professor | no p.grades\n\n}",
                    "{\n\t// Only students have grades\n\n  \t\n\n\tall c: Course, g: Grade | some p: Person | c.grades[p] = g implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall p : Person | one(p.enrolled.grades[p]) implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall p : Person | lone(p.enrolled.grades[p]) implies p in Student\n}",
                    "{\n\t// Only students have grades\n\tall pe : Person | (pe.teaches.grades.Grade = none) and (pe.enrolled.grades.Grade != none)\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall pr : Professor | all class : pr.enrolled+pr.teaches | no g : Grade | pr->g in class.grades\n  \n  \tall p : Person  | all c : p.enrolled | some g : Grade | p->g in c.grades implies p in Student\n  \t\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall pr : Professor | all class : pr.teaches | no g : Grade | pr->g in class.grades\n  \n\n  \t\n}",
                    "{\n\t// Only students have grades\n\t\n  \tall pr : Professor | all class : pr.enrolled | no g : Grade | pr->g in class.grades\n  \n\n  \t\n}",
                    "{\n\t// Only students have grades\n\tall p:Student, c:Course, g:Grade | some c.grades.g\n}",
                    "{\n\t// Only students have grades\n\n\tall c: Course, g: Grade | some p: Person | g in c.grades[p] implies p in Student\n\n}",
                    "{\n\t// Only students have grades\n\n\tall c: Course, g: Grade | one p: Person | g in c.grades[p] implies p in Student\n\n}",
                    "{\n\t// Only students have grades\n  all p: Person |\n\t\t(p in Student implies some c: p.enrolled | c.grades[p] in Grade) and\n\t\t(p in Professor implies no c: p.teaches | some pe: c.enrolled | c.grades[pe] in Grade)\n\n  \n\n}",
                    "{\n\t// Only students have grades\n\tsome s : Person | all g : Grade|  s in Student and s->g in Course.grades\n}",
                    "{\n\t// Only students have grades\n\tall s: Student, c: Course | some c.grades\n\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | c.grades.first in Student\n}",
                    "{\n\t// Only students have grades\n\tall c: Course | all p: Professor-Student | lone g:Grade | p->g not in c.grades\n}",
                    "{\n    // Only students have grades\n  all s: Student | all c: Course | not (s->Grade) in c.grades\n\n}",
                    "{\n    // Only students have grades\n  all s: Person | all c: Course | not (s->Grade) in c.grades\n\n}",
                    "{\n\t// Only students have grades\n  \n \tall p : Person - Student | all c : p.enrolled | some grades.c\n\n}",
                    "{\n\t// Only students have grades\n  \n \tall s : Student | all c : s.enrolled | some grades.c\n\n}",
                    "{\n\t// Only students have grades\nall p:Person, g:Grade| (Course<:grades).g in enrolled implies p in Student}",
                    "{\n\t// Only students have grades\n  all c: Course | grades in c -> Student -> Grade\n\n}",
                    "{\n\t// Only students have grades\n  all x : Person | some (x.enrolled.grades) \n\n}",
                    "{\n\t// Only students have grades\n\tall c: Course, p: Person| some g:Grade |p->g in c.grades => p in Student - Professor\n}",
                    "{\n\t// Only students have grades\n\tall c: Course, p: Person, g:Grade |p->g in c.grades => p in Student - Professor\n}",
                    "{\n\t// Only students have grades\n  \tall p: Person, g: Grade, pr: Project |\n  \t\tp->pr in projects implies (p in Student and some enrolled.grades)\n  \t\t\n\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | some (c.grades.Grade & Student)\n}",
                    "{\n\t// Only students have grades\n\tall p: Person | #p.enrolled.grades > 0 implies p in Student\n\tall p: Person | one g: Grade | g in p.enrolled\n}",
                    "{\n\t\n  all s: Student, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades\n  \n  all c: Course, g: Grade, p: Person | p->g in c.grades implies p in Student\n\n}",
                    "{\n\t\n  all s: Person, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades and s in Student\n\n}",
                    "{\n\t// Only students have grades\n\tno p : Person - Student | #p.enrolled.grades > 0 and #p.teaches.grades > 0\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | all p : Person | p in c.grades.Grade implies p = Student\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | all p : Person | (p not in Professor and p in c.grades.Grade ) implies p = Student\n}",
                    "{\n\t// Only students have grades\n\tall c : Course | all p : Person | (p in Professor and p in c.grades.Grade ) implies p = Student\n}"
                ]
            },
            {
                "description": "Students only have grades in courses they are enrolled",
                "pred": "this/inv11",
                "oracle": "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : Course | some c.grades[s] implies c in s.enrolled\n}",
                "erroneous": [
                    "{\n\t// Students only have grades in courses they are enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tCourse.grades.Grade in enrolled.Course\n}",
                    "{\n\tall c: Course | c.grades.Grade in c.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s:Student | s.enrolled.grades[s] = Course.grades[s]\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : s.enrolled | no s <: (Course - c).grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \n  all p:Student | all c:Course.grades[p]| c in p.enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tall s : Student | all c : s.enrolled |\n  \ts in c.grades.Grade  \n  \t\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student, c: Course |\n  \t\t(s->Grade) in c.grades => c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tno c : Course | some s : Student - c.~enrolled | s -> c.grades[s] in c.grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tCourse.grades.Grade in Student\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student, c: s.enrolled | some g: Grade | g = s.grades.c\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student | some (grades.s)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n    all s: Student, c: s.enrolled | one g: Grade | g = c.grades[s]\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student, c: Course | s in c.grades.Grade  iff c in s.enrolled\n  \n  \n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  all s: Student, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  all p: Student , c: Course | p in c.grades.Grade & p.enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n   all c: Course | all p: Student | c in p.enrolled implies lone p.(c.grades)\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  all c : Course | c in c.grades.Person.enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student | some c: Course | some s.(c.grades) implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Person | some g : Grade | some c : Course | s->g in c.grades implies (c in s.enrolled and s in Student)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c:Course | all s:Student | c.grades.Grade in s implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | Course.grades in s.enrolled->Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c: Course | some c.grades.Grade implies c in c.grades.Grade.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : Course | some(c.grades) implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | all g : Grade | some c : Course | s->g in c.grades implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n   all c: Course | all p: Student | c in p.enrolled and lone p.(c.grades)\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n    all c : Course | all g : Grade | all p : Person | (p in c.grades.g and p in enrolled.c) implies p in Student\n    \n}",
                    "{\n\t\n  all s: Person, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades and s in Student\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \t(grades.Grade) = ~enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | s.enrolled.grades in s.enrolled->Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | all c : Course | some(grades.Grade) => c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tall p: Student | all g: p.(p.enrolled.grades) | p.(Course.grades) in g\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s:Student | s.enrolled.grades[s] = Course.grades[s]\n    all disj c1,c2:Course | no (c1.grades & c2.grades)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n    all p:Person,c:Course | some (c.grades) implies p in Student and c in p.enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\nall s : Student | all c : Course | s.enrolled not in c implies no(s->Grade)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\nall s : Student, c : Course | one s.(c.grades) implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\t\n  \tall c : Course | c in c.grades.Grade.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  all c: Course |  all g:Grade | c.grades.g.enrolled in c\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tall s: Student | some g: Grade | all c: Course | g in s.(c.grades) implies c in s.enrolled\n\n}",
                    "{\n\t\n  all s: Person, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades\n  \n  all s: Person | s in Student\n}",
                    "{\n\t\n  all s: Person, c: Course , g: Grade | (s in enrolled.c implies s->g in c.grades) and (s->g in c.grades implies s in Student)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student, c: Course, p: Project | c in projects.p and s in projects.p implies s in enrolled.c\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student, c: Course, g:Grade | c->s->g in grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | all c : s.enrolled | some(c.grades)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : Course | lone(c.grades) implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s:Student | Student.enrolled.grades[s] = Course.grades[s]\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Person - Professor | all c : Course - s.enrolled | s not in c.grades.Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tsome teaches.Course\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, g : Grade | s.enrolled.grades.g in Student\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Person, c : Course | c in s.enrolled implies some(c.grades.s)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : Course | c in s.enrolled implies some(grades.Grade.s)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Person | all g : Grade | some c : Course | s->g in c.grades implies c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Person | all g : Grade | some c : Course | s->g in c.grades implies (c in s.enrolled and s in Student)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n    all s : Student | grades in s.enrolled -> s -> Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s: Student | all c: Course | Grade in c.grades[s] => c in s.enrolled and c not in s.teaches\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall p : Person, g : Grade, c : Course | some p.enrolled implies p->g in c.grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall p : Student, g : Grade, c : Course | some p.enrolled implies p->g in c.grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c:Course | all s:Student | (grades.Grade.s in c) implies (c in s.enrolled)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s:Student | one c:s.enrolled | (grades.Grade).s in c\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s:Student | some c:s.enrolled | (grades.Grade).s in c\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | Course.grades = s.enrolled->Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tCourse.grades = Student.enrolled->Grade\n}",
                    "{\n    // Students only have grades in courses they are enrolled\n  all p: Person | all g:Grade | p->g in Course.grades implies p->Course in enrolled\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tall s : Student | some c : s.enrolled |\n  \ts in c.grades.Grade  \n  \t\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\t\n\tCourse.grades in Student -> some Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \n  all p : Person, c : Course |  one (p.enrolled & grades.p.Grade) and p in Student\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c : Course | c in c.grades.Grade.enrolled implies c.grades.Grade in Student\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n   all c: Course | all p: Person - Professor| c in p.enrolled and lone p.(c.grades)\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n   all c: Course | all p: Student | c not in p.enrolled and no p.(c.grades)\n\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c: Course, s: Student | lone s.(c.grades) => c in s.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, e : s.enrolled, t: s.teaches | no s <: (Course - e - t).grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall p : Person, e : p.enrolled, t: p.teaches | no p <: (Course - e - t).grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student, c : s.enrolled | no (s <: Course.grades)\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tenrolled.Course->Grade in Course.grades \n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | s.enrolled.grades in s->Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | s->Grade in s.enrolled.grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | s->Grade = s.enrolled.grades\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall s : Student | (Course - s.enrolled).grades not in s->Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \n all s : Student |  some s.(Course.grades)  \n\n}",
                    "{\n\t\n  all s: Person, c: Course , g: Grade | s in enrolled.c implies s->g in c.grades\n  \n  all s: Person, c: Course , g: Grade | s in Student\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  \tall x: Student, g: Grade | x in Course.grades.g implies (some c: Course | x in enrolled.c and x in c.grades.g)\n\tall x: Student, g1, g2: Grade, c: Course | x in c.grades.g1 and x in c.grades.g2 implies g1 = g2\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tall c : Course | some s : Student | s in c.~enrolled and \n  \t\tc.grades[s] in  Grade\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\t\n  \t\t\n  all c: Course, p: Person |\n        p -> Grade in c.grades implies p in c.enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\t\n  \t\t\n  all c: Course, p: Person |\n        p -> Grade in c.grades implies p in c.~enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tCourse.grades & Professor->Grade = none->none \n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n\tgrades.Grade = enrolled\n}",
                    "{\n\t// Students only have grades in courses they are enrolled\n  all s: Student, c: Course, g: Grade | c in s.enrolled implies c.grades.g in enrolled.c\n\n}"
                ]
            },
            {
                "description": "Students have at most one grade per course",
                "pred": "this/inv12",
                "oracle": "{\n\t// Students have at most one grade per course\n\tall s : Student, c : Course | lone c.grades[s] \n}",
                "erroneous": [
                    "{\n\t// Students have at most one grade per course\n\tall s:Student, c:Course | lone c.grades.s\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p: Student | all c: Course | (one c.grades[p])\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student , c: Course | one c.grades.s\n\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n\t\n\n\t\n\n\tall s : Student | lone s.(Course.grades)\n\n  \t\n\t\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | lone(s.enrolled.grades) \n}",
                    "{\n\t// Students have at most one grade per course\n\t\n\t\n\n\t\n\n\tlone Student.(Course.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n  all s:Student | all c:s.enrolled | one s.(c.grades)\n\n}",
                    "{\n\t// Students have at most one grade per course\n  all s : Student | all c : s.enrolled | lone c.grades\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p:Student | all c:Course | all g1,g2:Grade | p->g2 in c.grades and p->g2 in c.grades implies g1=g2\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall c: Course, s: Student | lone c.grades\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n\t\n\n\t\n  all c : Course | lone c.grades.Grade\n\n\t\n\t\n\t\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | all c : Course | some (s.enrolled & c) implies one (c.grades.Grade & s)\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student | lone(s.(s.enrolled.grades))\n}",
                    "{\n\t// Students have at most one grade per course\n\tone Course.grades.Person\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall c : Course | all p : Student | lone g : Grade | c in p.enrolled implies p->g in c.grades\n\n}",
                    "{\n\t// Students have at most one grade per course\n    all s : Student, c : Course | lone (s.enrolled.grades - c.grades)\n\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall p : Person , c : Course | one p.(c.grades)\n  \t\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student, c: Course | c in s.enrolled implies lone c.grades.Grade\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | one Course.grades.s\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n  all c : Course , p : Person | one ( c.grades.p)\n  \n  \n}",
                    "{\n\t// Students have at most one grade per course\n\tall c: Course | lone c.grades\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | lone g : Grade | all c : Course | c.grades[s] = g\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student, c : Course |\n  \t\tsome s.(c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n  all c : Course , g : Grade | one ( c.grades.g) \n  \n  \n}",
                    "{\n\t// Students have at most one grade per course\n  all c: Course | all g1, g2: Person.(c.grades) | \n  \t\t(g1 != g2) \n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p : Person, c : Course | p->c in enrolled implies one p.(c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c : Course | c.grades.Grade in enrolled.c\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c : Course,g:Grade | lone c.grades.g\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student | all c: Course | c in s.enrolled and one s.(c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student, c: Course | one g: Grade| (s->g in c.grades) implies (one c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n\t\n\n\t\n\n\tall c : Course | lone Student.(c.grades)\n\n  \t\n\t\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall p : Person, g1,g2 : Grade, c : Course | p.(c.grades) in g1 and p.(c.grades) in g2 implies g1 = g2\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p : Professor | all c : p.enrolled | lone(p.(c.grades))\n}",
                    "{\n\t// Students have at most one grade per course\n    all s : Student, c : Course | lone (s.enrolled.grades & c.grades)\n\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall s : Student | all c : grades.Grade.s | lone(c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n  all c : Course | lone c.grades & Student.enrolled.grades\n  \n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s1, s2 : Student, c : Course | some s1.(c.grades) and some s2.(c.grades) implies s1 = s2\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall s : Student, c : s.enrolled | one c.grades.Grade \n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | one(s.enrolled.grades) \n}",
                    "{\n\t// Students have at most one grade per course\n  all s : Student | all c : s.enrolled | lone c.grades\n  \n  all c : Course | all per : Person | lone g : Grade | per->g in c.grades\n\n}",
                    "{\n\tall s : Student | (grades.Grade).s in s.enrolled\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student | lone g : Grade | all c : s.enrolled | c.grades[s] = g\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student, c : Course | one (c.grades.Grade)\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s : Student, g : Grade, c : Course | lone s->g => s->g in c.grades\n}",
                    "{\n\t// Students have at most one grade per course\n    one s: Student, c: Course | lone s.enrolled.grades\n\n\n}",
                    "{\n\t// Students have at most one grade per course\n    some s: Student, c: Course | lone s.enrolled.grades\n\n\n}",
                    "{\n  all c : Course | lone g : Grade | all p : Person | \n\t c -> p -> g in grades implies p in Student\n\t// Students have at most one grade per course\n\n}",
                    "{\n  some c : Course | lone g : Grade | all p : Person | \n\t c -> p -> g in grades implies p in Student\n\t// Students have at most one grade per course\n\n}",
                    "{\n  all c : Course | all p : Person | lone g : Grade |\n\t c -> p -> g in grades implies p in Student\n\t// Students have at most one grade per course\n\n}",
                    "{\n\t// Students have at most one grade per course\n  \tall s : Student, c : Course | one s->c.grades\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tCourse.grades in Student -> lone Grade\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n  all c : Course , p : Person | one ( c.grades)\n  \n  \n}",
                    "{\n\t// Students have at most one grade per course\n\t\n  all c : Course  | one ( c.grades)\n  \n  \n}",
                    "{\n\t// Students have at most one grade per course\n  \tall c: Course, g: Grade | lone (enrolled.c & c.grades.g) \n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c: Course | all s: Student | one (s.enrolled.grades.Grade) \n}",
                    "{\n\t// Students have at most one grade per course\n  \tall s: Student | all c: Course | c in s.enrolled implies\n\t\t#(c.grades.Grade & s) <1\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c : Course, s:Student| lone c.grades.Grade \n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student | all g: Grade | all c: Course | \n  \t\t#grades->c->s <= 1\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student | all g: Grade | one c: Course | \n  \t\t#(c->s->g & grades) <=  1\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student | all g: Grade | all c1, c2: Course | \n  \t\tc1->s->g in grades and c2->s->g in grades\n  \t\t\timplies c1 = c2\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n    all c : Course | lone g : Grade | all s : Student | s in c.grades.g\n  \n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student | lone (Course.grades.Grade)\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p:Student | some c:Course | all g1,g2:Grade | p->g2 in c.grades and p->g2 in c.grades implies g1=g2\n}",
                    "{\n\t// Students have at most one grade per course\n all x: Student | some (x.enrolled.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s:Student, c:s.enrolled | #(s & c.grades.Grade) >1\n}",
                    "{\n   all c : Course | all s : Student| lone c.grades[s] implies c in s.enrolled\n\t// Students have at most one grade per course\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall p : Person | one Course.grades.p\n}",
                    "{\n\t// Students have at most one grade per course\n\tone Course.grades.Grade\n}",
                    "{\n\t// Students have at most one grade per course\n  all c:Course | lone g:Grade |all p:Person |  c->p->g in grades\n\n}",
                    "{\n\t// Students have at most one grade per course\n\tall s: Student, g: Grade, c: s.enrolled | s->g in c.grades\n}",
                    "{\n\t// Students have at most one grade per course\n\t\n\tlone (Student <: Course.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n  all s : Student | lone s.enrolled.grades.Grade\n\n}",
                    "{\n\t// Students have at most one grade per course\n  all s:Student | #(s.(Course.grades)) = 1\n\n}",
                    "{\n\t// Students have at most one grade per course\n  all s:Student|one c:Course | lone s.(Course.grades)\n\n}",
                    "{\n\t// Students have at most one grade per course\n  all s:Student|one c:Course | lone s.(c.grades)\n\n}",
                    "{\n\t// Students have at most one grade per course\nCourse.grades.Grade in enrolled.Course\n}",
                    "{\n\t// Students have at most one grade per course\n  all c:Course | one c.grades.Person\n}",
                    "{\n\t\n\tall c: Course | one g: Grade | c.grades.g in enrolled.c\n}",
                    "{\n\t\n\tall c: Course | one g: Grade | c.grades.g in Student\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student, c: Course | s in enrolled.c implies (one c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c : Course | all p : c.grades.Grade | lone p.enrolled.grades\n}",
                    "{\n\t// Students have at most one grade per course\n\tall c : Course | all p : c.grades.Grade | lone p.enrolled.grades and p in Student\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student, c: Course | lone g: Grade| (s->g in c.grades) implies (lone c.grades)\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student, c: Course | lone g: Grade | c.grades.g in enrolled.c\n}",
                    "{\n\t// Students have at most one grade per course\n  all  c: Course | lone g: Grade | c.grades.g in enrolled.c\n}",
                    "{\n\t// Students have at most one grade per course\n  all s: Student, c: Course | lone g: Grade | c in s.enrolled implies g in c.grades.s\n}",
                    "{\n\t// Students have at most one grade per course\n\tlone Person.(Course.grades)\n}"
                ]
            },
            {
                "description": "A student with the highest mark in a course must have worked on a project on that course",
                "pred": "this/inv13",
                "oracle": "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \n    all c : Course, s: Student | last in s.(c.grades) implies some s.projects & c.projects\n}",
                "erroneous": [
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one p : c.grades.max | one s : Student | one g : Grade |\n  \t(c in s.enrolled and s->g in c.grades and g=p) \n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tsome (c.projects & bestStudent.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student |\n  \t\ts.(c.grades) = ordering/max[Student.(c.grades)] => some (c.projects & s.projects)\n}",
                    "{ \n  all c : Course | all s : enrolled.c - Professor | s.(c.grades) = max[Student.(c.grades)] implies some (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c: Course |\n        all s: Student | let map = Grade -> Int | \n            \n            (#c.grades[s] > 0 and \n             no s2: Student |#c.grades[s2] > 0 and \n              c.grades[s2].map > c.grades[s].map) =>\n            \n            some c.projects & s.projects\n  \t\t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s1, s2: Student, c: Course | no g2: c.grades[s2] | g2 in c.grades[s1].next => some (s1.projects & c.projects)\n}",
                    "{ \n  all p : Student | all c : Course | c in p.enrolled and p.(c.grades) = max[Person.(c.grades)] implies some (p.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s,s1:Student | all c:Course | (s!=s1 and gt [c.grades[s],c.grades[s1]]) implies (some p:s.projects | p in c.projects) \n  \t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | some max[Person.(c.grades)]\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all c : Course | some (c.grades[Student].max[c.grades].projects & c.projects)\n        or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c: Course, s: Student, g: Grade | s->g in c.grades => s.projects in c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: Course | no c.grades[s].next => some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | let g = (c.grades), g2 = Person.g | g.(max[g2]) in (Person <: projects).(c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all c : Course | some (c.grades[Student].max[c.grades].projects & c.projects) or no c.grades\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course, pr : c.projects\n\t\t| max[Grade] in s.(c.grades) implies pr in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \n  all s1: Student,c:Course | not ( some s2:Student | \n      gt[s2.(c.grades),s1.(c.grades)] )\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Student,c: Course | (not ( some s2:Student-s1 | \n      gt[s2.(c.grades),s1.(c.grades)]))\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Student,c: Course | \n      (all s2:Student-s1 | gt[s1.(c.grades),s2.(c.grades)])\n      implies some s1.projects & c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, g : max[c.grades[Student]], s : c.grades.g | some s.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student | last in s.(c.grades) implies s.projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet map = Grade -> Int |\n\tall c: Course |\n        all s: Student |\n            \n            (all s2: Student | c.grades[s].map >= c.grades[s2].map) =>\n            \n            some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: Course | s.(c.grades) = max[Person.(c.grades)] implies \n  \t\ts.projects & c.projects != none\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n \n  all c:Course | some(c.grades) implies some(c.projects & ( ( (c.grades).(max[Person.(c.grades)]) ).projects))\n  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tone c.projects & bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\tall c: Course | all s: Student | s.(c.grades) = max[Person.(c.grades)] => s.projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one p : Grade.max[c.grades] | some proj : p.projects | proj in c.projects and p in Student\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course | some c.grades and some c.projects implies some s: Student {\n      \tc.grades[s] = max[c.grades[Student]]\n      \tsome s.projects & c.projects\n  \t}\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: Course {\n  \t\t{\n          \tsome c.grades[Student]\n          \tc.grades[s] = max[c.grades[Student]]\n      \t} implies {\n          \tsome s.projects & c.projects\n      \t}\n  \t}\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s: Student, c: Course {\n\t\t{\n          \tsome c.grades[Student]\n          \tc.grades[s] = max[c.grades[Student]]\n      \t} implies {\n          \tno c.projects or some s.projects & c.projects\n      \t}\n  \t}\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all s1 : Student | s1!=s and c in s1.enrolled implies c.grades[s1].lte[c.grades[s]])\n             implies\n             some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\tall c: Course | all s: Student | s.(c.grades) = last => s.projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | let g = c.grades, g2 = Person.g | some c.projects implies g.(max[g2]) in (Person <: projects).(c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tone s: Student | all c: Course |\n  \t\tlast in s.(c.grades) implies some c.(Course <: projects) & s.(Person <: projects)\n  \t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  let map1 = Grade -> Int |\n  all c: Course |\n        \n        all s: Student |\n            \n            (all s2: Student | #c.grades[s2] > 0 => c.grades[s].map1 >= c.grades[s2].map1) =>\n            \n            some c.projects & s.projects\n  \t\t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n        some s: Student | \n            (s in Person.(c.grades) and c.grades[s] = last) implies\n                (some p: Project | p in s.projects and p in c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course, p: Person, g: Grade | all p1: Person, g1: Grade | p->g in c.grades and p1->g1 in c.grades and gt[g, g1] implies p in enrolled.c\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n \n  all c:Course | c in Course:> projects.(((c.grades).last)    .projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | one b : Student | gte[b.(c.grades),a.(c.grades)] implies some c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1,s2 : Student | some c : Course | gt[s1.(c.grades),s2.(c.grades)] implies one s1.enrolled.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall p1,p2 : Student | some c : Course | gt[p1.(c.grades),p2.(c.grades)] implies one p1.projects & c.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies one a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  one a : Person | all b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies one p : Project | p in c.projects and p in a.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | all s : enrolled.c | no ((s <: c.grades).prev) implies some (s.projects & c.projects)\n}",
                    "{ \n  all c : Course | all s : enrolled.c | s.(c.grades) = max[Student.(c.grades)] implies some (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    let highest_mark = Grade.max |\n    let s = highest_mark[Course.grades] |\n    let c = { c : Course | c.grades[s] = highest_mark } |\n    some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    let highest_mark = grades[Course][Student].max |\n    let s = highest_mark[Course.grades] |\n    let c = { c : Course | c.grades[s] = highest_mark } |\n    some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | grades[c][s] = grades[c][Student].max\n        implies some s.projects & c.projects or no c.grades\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | ( max[grades.c] in s.(c.grades)  ) implies some(s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course | some c.grades implies some s: Student {\n      \tc.grades[s] = max[c.grades[Student]]\n      \tsome s.projects & c.projects\n  \t}\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall g: Grade {\n        let student = univ.grades.g, course = grades.g.univ {\n          \tg = max[course.grades[Student]] implies some student.projects & course.projects\n        }\n    }\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | ((c.grades).(max[Student.(c.grades)])).projects in c.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, s : Student | s.(c.grades) in Person.(c.grades).max implies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Student,c:Course,g:Grade | (c->s->g in grades and (all s2:Student,g2:Grade| c->s2->g2 in grades implies gte[g,g2])) implies (some p:Project| s->p in projects and c->p in projects )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, p: Student | some max[(c.grades)] \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    \n    \n    \n\n\t\n\n  all s1: Student,c: Course | (not ( some s2:Student | \n      (some s2.(c.grades)) and gt[s2.(c.grades),s1.(c.grades)]))\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tone s: Student | all c: Course | some p: s.projects | s in c.grades.last => p in s.projects & c.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \n  all p : Student, c : Course | last in p.(c.grades) => c in p.enrolled \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c: Course | \n        one s: Student | c.grades[s] = last[c.grades] implies #(s.projects & c.projects) > 0\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student, sg: s.(c.grades) | all cg: Person.(c.grades) - sg | some p: c.projects | gte[sg, cg] implies p in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall p:Person | some c:Course | last in p.(c.grades) implies (p.projects & c.projects != none)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student | all c: Course | some p: Project | s in c.grades.(max[Grade]) implies p in s.projects and p in c.projects\n        \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    \n    \n    \n\n\t\n\n  \n  \n  \n  \n  \n  \n\n  all s : Student, c : Course | (all g : Grade | not some s.(c.grades) and gte[s.(c.grades),g]) implies some s.projects & c.projects\n}",
                    "{ \n  all c : Course | all s : Student | c in s.enrolled and s.(c.grades) = max[Person.(c.grades)] implies one (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, s : Student | first in c.grades[s] implies some c.projects&s.projects\n  \t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course, s: Student, g: Grade | all s1: Student, g1: Grade | s->g in c.grades and s1->g1 in c.grades and gt[g, g1] implies s in enrolled.c\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course, p: Person, g: Grade | all p1: Person, g1: Grade | p->g in c.grades and p1->g1 in c.grades and gte[g, g1] implies p in enrolled.c\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Student | (all s1:Student  | s!=s1 implies gt[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n  \t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Person | (all s1:Person  | gte[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | one b : Student | gte[b.(c.grades),a.(c.grades)] implies c.projects in b.projects \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course, p: Project | one b : Student | gte[b.(c.grades),a.(c.grades)] implies p in c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1,s2 : Student | some c : Course | gt[s1.(c.grades),s2.(c.grades)] implies s1.enrolled.projects in c.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | (c.grades).(max[Person.(c.grades)]).projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies some a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  one a : Student | all b : Student, c : Course | gt[a.(c.grades),b.(c.grades)] implies one a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \n  all c : Course, p : Person | first in p.(c.grades) implies some p.projects & c.projects\n  \n  \t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some student : Student | max[student.(c.grades)] = max[Person.(c.grades)] => c in student.(Person<:projects)\n}",
                    "{ \n  all c : Course | all s : enrolled.c | s.(c.grades) = max[Student.(c.grades)] and some c.projects implies some (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one p : Grade.max[c.grades] | some proj : p.projects | proj in c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all s : Student, c : Course |\n        (grades[c][s] = max[grades[Course][Student]]) implies (some s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    let highest_mark = grades[Course][Student].max |\n    let s = highest_mark[Course.grades] |\n    let c = { c : Course | c.grades[s] = highest_mark } |\n    some (s.projects & c.projects)\n    or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet highest_mark = grades[Course][Student].max |\n  \tlet s = highest_mark[Course.grades] |\n    all c : Course | \n  \t\tc.grades[s] = highest_mark\n     \timplies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | grades[c][s] = grades[c][Student].max\n        implies some s.projects & c.projects or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | grades[c][s] = grades[Course][Student].max\n        implies some s.projects & c.projects or no c.grades\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (lone g : Grade | s->g in c.grades implies some ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall g: Grade {\n        let student = univ.grades.g, course = grades.g.univ {\n          \t{\n              \tsome course.projects\n          \t\tg = max[course.grades[Student]]\n      \t\t} implies some student.projects & course.projects\n        }\n    }\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some s : Student | c.grades[Student] = c.grades[s] => some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | some c.grades and s.(c.grades) in Person.(c.grades).max implies some (c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | (some c.grades and s.(c.grades) = Person.(c.grades).max) implies some (c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all s1 : Student | s1!=s and c in s1.enrolled implies c.grades[s1].lte[c.grades[s]])\n             implies\n             one c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             c.grades[Student].lte[c.grades[s]]\n             implies\n             some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all g : c.grades[Student] | g.lte[c.grades[s]])\n             implies\n             some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Student,c:Course,g:Grade | (s->c in enrolled and c->s->g in grades and (all s2:Student,g2:Grade| c->s2->g2 in grades implies gte[g,g2]) ) implies (some p:Project| s->p in projects and c->p in projects )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n   all s : Student, c : Course, g : Grade, g2 : Grade-g, p : Project | (c->s->g in grades and gt[g,g2]) implies (c->p in projects and s->p in projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (all g : Grade | s->g in c.grades implies some ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n  \tone s : Student | some c : s.enrolled | \n  \t\tc.grades[s] in max[Grade] implies some s.projects & c.projects\n  \t\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: s.enrolled | max[c.grades] = s.(c.grades) implies one (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tone s: Student | all c: Course | some p: s.projects | s in c.grades.first => p in s.projects & c.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all x: Student | all c:Course | last in (x.(c.grades)) implies x.projects in c\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1:Student,  c:Course | (all s2:Student | gte [s1.(c.grades),  s2.(c.grades)] )\n\timplies\n\tlone (s1.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s1:Student,  c:Course | ((all s2:Student | gte [s1.(c.grades),  s2.(c.grades)] )\n\t\t\t\t\t\timplies\n\t\t\t\t\t\tsome (s1.projects & c.projects))\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course | max[Grade] in s.(c.grades) implies some p : Project | p in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tone p: Person| all c: Course |\n  \t\tlast in p.(c.grades) implies some c.projects & p.projects\n  \t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s:Student | max[Grade] in s.(Course.grades) implies s.projects in Course.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c: Course |\n  \tlet map = Grade -> Int |\n        \n        all s: c.~enrolled |\n            \n            (all s2: Student | #c.grades[s2] > 0 => c.grades[s].map >= \t\t\t\t\t\tc.grades[s2].map) =>\n            \n            some c.projects & s.projects\n  \t\t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n        some s: Student | \n            (s in (c.grades).Grade and c.grades[s] = last) implies\n                (some p: Project | p in s.projects and p in c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some ((Student->max[Student.(c.grades)]) & c.grades).Grade.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one (c.grades).Grade.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s: Student, c: s.enrolled | s.(c.grades) in last implies one (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s : Student | all c : Course | some c.grades and first[c.grades] = c.grades[s] implies all p:Project | p in c.projects and p in s.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s : Student | all c : Course | all p :Project | some c.grades and c.grades[s] in last[c.grades] implies p in c.projects and p in s.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, g : max[c.grades[Student]], s : c.grades.g |some c.projects implies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course, p: Person, g: Grade | all p1: Person, g1: Grade | p->g in c.grades and p1->g1 in c.grades and lt[g, g1] implies p in enrolled.c\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n \n  some c:Course | c in Course:> projects.(((c.grades).last).projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Student | (all s1:Student  | s!=s1 and gt[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n  \t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Person | (all s1:Person  | s!=s1 implies gt[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | lone s:Person | (all s1:Person  | s!=s1 implies gt[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | one b : Student | gte[b.(c.grades),a.(c.grades)] implies b.projects in c.projects \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s:Person | one c:Course | (all s1:Person  | gte[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s:Person | all c:Course | (all s1:Person  | gte[s.(c.grades),s1.(c.grades)]) implies (some p:s.projects | p in c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | one b : Student | gte[b.(c.grades),a.(c.grades)] implies one c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | one b : Student | gt[b.(c.grades),a.(c.grades)] implies some c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Person | (all s1:Person  | smaller[s.(c.grades),s1.(c.grades)]=s.(c.grades)) implies (some p:s.projects | p in c.projects) \n  \t\n\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | one s:Person | (all s1:Person  | larger[s.(c.grades),s1.(c.grades)]=s.(c.grades)) implies (some p:s.projects | p in c.projects) \n  \t\n\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n   all  s : Student, c : Course | s.(c.grades) in (c.grades.last) =>  s.projects in c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | some b : Student | gte[b.(c.grades),a.(c.grades)] implies some c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall a : Student, c : Course | some b : Student | lte[a.(c.grades),b.(c.grades)] implies some c.projects&b.projects  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student | last in s.(c.grades) implies no (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n \n  all c:Course | c in Course:>  projects.( ( (c.grades).(max[Person.(c.grades)]) ).projects)\n  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | all c: Course | (s.(c.grades) in last) implies c in Person <: s.projects \n\t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1,s2 : Student | some c : Course | gt[s1.(c.grades),s2.(c.grades)] implies s2.enrolled.projects in c.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1,s2 : Student | some c : Course | gt[s1.(c.grades),s2.(c.grades)] implies lone s1.enrolled.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall p1,p2 : Student | some c : Course | gt[p1.(c.grades),p2.(c.grades)] implies one p1.enrolled.projects & c.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall p1,p2 : Student | some c : Course | gte[p1.(c.grades),p2.(c.grades)] implies one p1.projects & c.projects\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\tall c: Course | all s: Student | s.(c.grades) = max[Person.(c.grades)] => c.projects in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\tall c: Course | all s: Student | s.(c.grades) = max[Person.(c.grades)] => (c.projects in s.projects and some c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\tall c: Course | all s: Student | (some s.(c.grades) and s.(c.grades) = max[Person.(c.grades)]) => (c.projects in s.projects and some c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n\t\n\tall c: Course | all s: Student | (some s.(c.grades) and s.(c.grades) = last) => (c.projects in s.projects and some c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  one a : Person | all b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies a.projects in c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies c.projects in a.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Person, c : Course | gt[a.(c.grades),b.(c.grades)] implies a.projects in c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Student, c : Course | gt[a.(c.grades),b.(c.grades)] implies some a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all a,b : Student, c : Course | gt[a.(c.grades),b.(c.grades)] implies one a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  one a : Student | all b : Student-a, c : Course | gt[a.(c.grades),b.(c.grades)] implies one a.projects&c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | some s : enrolled.c | no ((s <: c.grades).prev) implies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c:Course | no s : enrolled.c | no ((s <: c.grades).prev) and some (s.projects & c.projects)\n}",
                    "{\n  \n  all c: Course |\n  \tall s:enrolled.c |\n  \t\tno c.grades[s].nexts implies some s.projects & c.projects\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student |\n  \t\ts.(c.grades) = ordering/max[Student.(c.grades)]\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student |\n  \t\ts.(c.grades) = ordering/max[Student.(c.grades)] => one (c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tc.projects in bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tlone c.projects & bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tone bestStudent and some c.projects & bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tlone bestStudent => some c.projects & bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n  \t\tlet bestGrade = ordering/max[(c.grades)[Student]], bestStudent = c.grades.bestGrade |\n  \t\tone bestStudent => some c.projects & bestStudent.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some student : Student | max[student.(c.grades)] = max[Person.(c.grades)] => student in (Person<:projects).(c.(Course<:projects))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some student : Student | c in student.enrolled and max[student.(c.grades)] = max[Person.(c.grades)] => student in (Person<:projects).(c.(Course<:projects))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some student : Student | c in student.enrolled and some c.grades and max[student.(c.grades)] = max[Person.(c.grades)] => student in (Person<:projects).(c.(Course<:projects))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s: Student |all c: s.enrolled| some (s.(c.grades) & last) implies (Course :> projects.(s.projects) in c) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | no( ((c.grades).(max[Student.(c.grades)])).projects & c.projects ) \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | c in ((c.grades).(max[Student.(c.grades)])).teaches\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | c.grades[s] = c.grades.last implies some s.enrolled.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | c.grades[s] = last implies some s.enrolled.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one p : Grade.max[c.grades] | one s : Student | one g : Grade |\n  \tc in s.enrolled and s->g in c.grades\n  \n}",
                    "{ all p : Person | all c : Course | last = p.(c.grades) implies p.projects in c.projects }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c:Course|all s:Student | last in s.(c.grades) implies s.enrolled in c\n}",
                    "{ \n  all c : Course | all p : Student | p.enrolled in c and p.(c.grades) = max[Person.(c.grades)] implies some (p.projects & c.projects) }",
                    "{ \n  all c : Course | all s : enrolled.c | s.(c.grades) = max[Person.(c.grades)] implies some (s.projects & c.projects) }",
                    "{ \n  all c : Course | all s : enrolled.c | s.(c.grades) = max[Person.(c.grades)] and some c.projects implies some (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c : Course | some s: Person | (s.(c.grades) = max[Person.(c.grades)] ) implies s in projects.(c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c : Course | some s: enrolled.c | (s.(c.grades) = max[Person.(c.grades)] ) implies s in projects.(c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all c : Course | some s: enrolled.c | s in Student and (s.(c.grades) = max[Person.(c.grades)] ) implies s in projects.(c.projects)\n\n}",
                    "{ \n  all c : Course | all s : enrolled.c - Professor | (some Student.(c.grades) and s.(c.grades) = max[Student.(c.grades)]) implies some (s.projects & c.projects) }",
                    "{ \n  all c : Course | all s : enrolled.c | s in Student and s not in Professor and s.(c.grades) = max[Student.(c.grades)] implies some (s.projects & c.projects) }",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some s : (Student.(c.grades)) | \n  \t\tsome(s & last) implies Person:>s.projects in Course:>c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course | some (s.(c.grades) & last) implies \n  \t\t\t\t\t\t\t\t  s.enrolled in Course:>c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course | some (s.(c.grades) & last) implies \n  \t\t\t\t\t\t\t\t  s.enrolled in Course:>projects.(c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course | some (s.(c.grades) & last) implies \n  \t\t\t\t\t\t\t\t  s.enrolled.projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course | some (s.(c.grades) & last) implies \n  \t\t\t\t\t\t\t\t  some (s.enrolled.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course | some s: Student | c.grades[s] = max[c.grades[Student]] => (s.enrolled in c)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course | some s: Student | c.grades[s] = max[c.grades[Student]] => (c in s.enrolled)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course | some s: Student |\n  \t\t(c.grades[s] in max[c.grades[Student]]) implies c.projects in s.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course | some s: Student |\n  \t\t(c.grades[s] in max[c.grades[Student]]) implies s.projects in c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course, s: Student |\n  \t\t(c.grades[s] in max[c.grades[Student]]) implies s.projects in c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course, s: Student |\n  \t\t(c.grades[s] in max[c.grades[Student]]) implies c.projects in s.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\tall c: Course, s: Student |\n  \t\t(c.grades[s] in max[c.grades[Student]]) implies some p : Project | (p in s.projects and p in c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one st : Grade.max[c.grades] | c in st.enrolled implies (some p : st.projects | p in c.projects)\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one st : Grade.max[c.grades] | (st in Student and c in st.enrolled) implies (some p : st.projects | p in c.projects)\n  \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | ( s.(c.grades) \nin max[c.grades]) implies some(s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all c : Course | some (Course.grades[Student].max[Course.grades].projects & c.projects)\n        or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all c : Course | some (Course.grades[Student].max[c.grades].projects & c.projects)\n        or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    let highest_mark = Grade.max |\n    let s = highest_mark[Course.grades] |\n    let c = { c : Course | c.grades[s] = highest_mark } |\n    some (s.projects & c.projects)\n  \tor no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    let highest_mark = Grade.max |\n    let s = highest_mark[Course.grades] |\n    let c = { c : Course | c.grades[s] = highest_mark } |\n    some (s.projects & c.projects) or no c.grades\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet highest_mark = grades[Course][Student].max |\n  \tlet s = highest_mark[Course.grades] |\n    all c : Course | \n  \t\tc.grades[s] = highest_mark\n     \timplies (\n          \tsome (s.projects & c.projects)\n        \tor no c.grades or no c.projects\n  \t\t)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet highest_mark = Grade.max |\n  \tlet s = highest_mark[Course.grades] |\n    all c : Course | c.grades[s] = highest_mark\n     \timplies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s : Student, c : Course | grades[c][s] = grades[Course][Student].max\n        implies some s.projects & c.projects or no c.grades or no c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (lone g : Grade | s->g in c.grades and some ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (lone g : Grade | s->g in c.grades and one ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (lone g : Grade | s->g in c.grades and lone ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (all g : Grade | s->g not in c.grades implies no ( s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (all p : c.projects | (one g : Grade | s->g in c.grades implies p in s.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (all p : c.projects | (lone g : Grade | s->g in c.grades implies p in s.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (lone g : Grade | s->g in c.grades implies lone (s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (one g : Grade | s->g in c.grades implies lone (s.projects & c.projects)))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (one g : Grade | s->g in c.grades implies s.projects = c.projects))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | ( all c : s.enrolled | (one g : Grade | s.projects = c.projects implies s->g in c.grades  ))\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: Course | no c.grades[s].next => one (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall disj s1, s2: Student | all c: Course | no g2: c.grades[s2] | g2 in c.grades[s1].next => some (s1.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s1, c: Course | c.grades[s1] = c.grades.max => some (s1.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s: Student, c: Course, g: Grade | s->g in c.grades => one s.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s: Student, c: Course, g: Grade | s->g in c.grades => c.projects in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student , c : Course | max[c.grades[Student]] in c.grades[s] implies  some (s.projects&c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Project.~(Course <: projects) {\n      \tsome max[c.grades[Student]]\n  \t}\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c: Course | some c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | let maxGrade = max[c.grades] {\n        some s: Student | s.grades.c = maxGrade and s.projects in c.projects\n    }\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some s : Student | c.grades[Student] & first = c.grades[s] => some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one s : Student | first = c.grades[s] && some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course | some c.grades.(Student.(c.grades).min).projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | s.(c.grades) in Person.(c.grades).max implies some (c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled | (some c.grades and s.(c.grades) = Person.(c.grades).max) implies (some (c.projects & s.projects) or no c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all s1 : Student | c in s1.enrolled implies c.grades[s1].lt[c.grades[s]])\n             implies\n             some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all s1 : Student | s1!=s and c in s1.enrolled implies c.grades[s1].lte[c.grades[s]])\n             implies\n             (some c.projects & s.projects)\n               or\n              one enrolled.c\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             c.grades[Student-s].lt[c.grades[s]]\n             implies\n             some c.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             c.grades[Student].lte[c.grades[s]]\n             implies\n             (some c.projects & s.projects\n              or one enrolled.c\n             )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n           all s : Student, c : s.enrolled |\n             (all g : c.grades[Student] | g.lte[c.grades[s]])\n             implies\n             (some c.projects & s.projects\n              or\n              one enrolled.c\n             )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall g:Grade | not (some g2:Grade| gt[g2,g]) implies (some s:Student,c:Course,p:Project| s->c in enrolled and s->p in projects and c->p in projects and c->s->g in grades)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Student,c:Course,g:Grade | (c->s->g in grades and (all s2:Student,g2:Grade| c->s2->g2 in grades and gte[g,g2])) implies (some p:Project| s->p in projects and c->p in projects )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Student,c:Course,g:Grade | (s->c in enrolled and c->s->g in grades and (all s2:Student,g2:Grade| s2->c in enrolled and c->s2->g2 in grades and gte[g,g2]) ) implies (some p:Project| s->p in projects and c->p in projects )\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, s : Student\n  \t\t| max[Student.(c.grades)] in s implies some pr : s.projects | pr in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled, g: Person.(c.grades) | (g != s.(c.grades)) implies some s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : Course\n\t\t| max[Grade] in Student.(c.grades) implies some pr : c.projects | pr in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n   all s : Student, c : Course, g : Grade, g2 : Grade-g, p : Project | (c->s->g in grades and gt[g,g2]) implies (s->c in enrolled and c->p in projects and s->p in projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Person,c: Course | (not ( some s2:Student | \n      gt[s2.(c.grades),s1.(c.grades)]))\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Student,c: Course | (not ( some s2:Student | \n      gt[s2.(c.grades),s1.(c.grades)])\n      and\n      (some s1.projects & c.projects))\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Student,c: Course | (not ( some s2:Student-s1 | \n      gt[s2.(c.grades),s1.(c.grades)])\n      and\n      (some s1.projects & c.projects))\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    all s1: Person,c: Course | \n      (not (some s2:Student-s1 | gt[s2.(c.grades),s1.(c.grades)]))\n      implies some s1.projects & c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    \n    \n    \n\n\t\n\n  all s1: Student,c: Course | \n      (some s1.(c.grades)) and \n  \t  (not ( some s2:Student-s1 | \n      (some s2.(c.grades)) and gt[s2.(c.grades),s1.(c.grades)]))\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\n\t\n\t\n\n\t\n\n    \n    \n    \n\n\t\n\n  all s1: Student,c: Course | \n      (some s1.(c.grades)) and \n  \t  (not ( some s2:Student-s1 | \n      (some s2.(c.grades)) and gte[s2.(c.grades),s1.(c.grades)]))\n      implies\n      (some s1.projects & c.projects) \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\t\n  \n  \tall s : Student, c : s.enrolled | some p : s.projects | max[Grade] in s.(c.grades) implies p in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n\tall c : Course, s : enrolled.c, g : max[s.(c.grades)] | some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n\tall s : Student, c : s.enrolled, g : max[s.(Course.grades)] | g in s.(c.grades) implies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n\tall c : Course, s : enrolled.c, g : max[Student.(c.grades)] | g in s.(c.grades) implies some (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n  \tone s : Student | some c : s.enrolled | \n  \t\tc.grades[s] = max[Grade] implies some s.projects & c.projects\n  \t\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n  \tone s : Student | some c : Course | \n  \t\tc.grades[s] in max[Grade] implies some s.projects & c.projects\n  \t\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n  \tone s : Student | some c : Course | \n  \t\tc.grades[s] = max[Grade] implies some s.projects & c.projects\n  \t\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \t\n  \tone s : Student | one c : s.enrolled | \n  \t\tc.grades[s] in max[Grade] implies some s.projects & c.projects\n  \t\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all student: Student, course: student.enrolled | first in student.(course.grades) implies some student.projects & course.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c : Course, s : enrolled.c |\n  \t\tGrade.next in s.(c.grades) implies\n  \t\t\tsome s.projects & c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall c : Course, s : enrolled.c |\n  \t\tGrade.prev in s.(c.grades) implies\n  \t\t\tsome s.projects & c.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tone s: Student | all c: Course | some p: s.projects | s in first.grades[c] => p in s.projects & c.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tone s: Student | all c: Course | s in c.grades.first => some s.projects & c.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student, c : s.enrolled |\n  \t\tmax[Grade] in s.(c.grades) implies\n  \t\t\tsome s.projects & s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student | all c: Course | c.grades[s] = c.grades.max implies c.projects in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all p: Person | all c: Course | c.grades[p] = c.grades.(max[Grade]) implies some pr:Project | pr in p.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all p: Person | all c: Course | p in c.grades.(max[Grade]) implies some pr:Project | pr in p.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s1:Student,  c:Course | (all s2:Student | gte [s1.(c.grades),  s2.(c.grades)] )\n\timplies\n\tlone (s1.projects - c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s1:Student,  c:Course | ((all s2:Student | s2 in (c.grades).Grade and gte [s1.(c.grades),  s2.(c.grades)] )\n\t\t\t\t\t\timplies\n\t\t\t\t\t\tlone (s1.projects & c.projects))\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s1:Student,  c:Course | ((all s2:Student | s2 in (c.grades).Grade and gte [s1.(c.grades),  s2.(c.grades)] )\n\t\t\t\t\t\timplies\n\t\t\t\t\t\tsome (s1.projects & c.projects))\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Person, c:Course | (s->c in enrolled and (max [Person.(c.grades)] =  s.(c.grades) ) ) \n\t\t\t\t\t\timplies\n\t\t\t\t\t\tone (s.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Person, c:Course | (s->c in enrolled and (max [Person.(c.grades)] =  s.(c.grades) ) and some enrolled.c-s ) \n\t\t\t\t\t\timplies\n\t\t\t\t\t\tone (s.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s:Student, c:Course | (s->c in enrolled and (max [Student.(c.grades)] =  s.(c.grades) ) ) \n\t\t\t\t\t\timplies\n\t\t\t\t\t\tone (s.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall p:Person, c:Course, g:Grade | (c->p->g in grades and (all g2:Grade | g2 in Person.(c.grades) and gte[g,g2]) ) \n\t\t\t\t\t\t\t\timplies\n\t\t\t\t\t\t\t\tone (p.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall p:Person, c:Course, g:Grade | max[Grade]=g implies one (p.projects & c.projects)\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall g : Grade | some c : Course, u : Person | u->g in c.grades\n\tall c : Course | let g = c.grades, g2 = Person.g | some c.projects implies g.(max[g2]) in (Person <: projects).(c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall g : Grade | some c : Course, u : Person | u->g in c.grades\n\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course, s: Student, sg: s.(c.grades) | all cg: Person.(c.grades) - sg | all p: c.projects | gte[sg, cg] implies p in s.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student | all c:Course | one p:Project | max[Grade] in s.(c.grades) and p in c.projects and c in s.enrolled implies p in s.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student | all c:Course | some p:Project | max[Grade] in s.(c.grades) and p in c.projects and c in s.enrolled implies p in s.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tone s: Student | all c: Course |\n  \t\tlast in s.(c.grades) implies c in s.(Person <: projects)\n  \t\t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tone s: Student | all c: Course |\n  \t\tlast in s.(c.grades) implies c.(Course <: projects) in s.(Person <: projects)\n  \t\t\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tone p: Person, c: Course |\n  \t\tlast in p.(c.grades) implies some (c.projects & p.projects)\n  \t\t\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all p:Person, c:Course | last in p.(c.grades) implies p.projects in c.projects\n  \n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course, p : Person |\n  \tsome p.projects & c.projects implies last in p.(c.grades)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet map = Grade -> Int |\n\tall c: Course |\n        all s: Student |\n            \n            ((all s2: Student | c.grades[s].map >= c.grades[s2].map) =>\n            \n            some c.projects & s.projects) or #c.grades[] = 1\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet map = Grade -> Int |\n\tall c: Course |\n        all s: Student |\n            \n            ((all s2: c.~enrolled | c.grades[s].map >= c.grades[s2].map) =>\n            \n            some c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tlet map = Grade -> Int |\n\tall c: Course |\n        all s: c.~enrolled |\n            \n            ((all s2: c.~enrolled | c.grades[s].map >= c.grades[s2].map) =>\n            \n            some c.projects & s.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  let map = Grade -> Int |\n  \tall c: Course |\n        all s: Student |\n            \n            (all s2: Student | c.grades[s].map >= c.grades[s2].map) =>\n            \n             #(c.projects & s.projects) = 1\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c: Course |\n        some s: Student | \n            (c in s.enrolled and s in c.grades.Grade and c.grades[s] = last) implies\n                (some p: Project | p in s.projects and p in c.projects)\n}",
                    "{\n    \n    all c: Course |\n        some s: Student |\n            (c in s.enrolled and s -> last in c.grades) implies\n                (some p: Project | p in s.projects and p in c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tsome s: Student, c: Course | s.(c.grades) = max[Person.(c.grades)] implies \n  \t\ts.projects & c.projects != none\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s: Student, c: Course | s.(c.grades) = max[Person.(Course.grades)] implies \n  \t\ts.projects & c.projects != none\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some ((Student->max[Student.(c.grades)]) & c.grades).Grade.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | one (((Student->max[Student.(c.grades)]) & c.grades).Grade.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some (c.grades).Grade.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | (c.grades).Grade.projects = c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | (c.grades).Grade.projects in c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | c.projects in (c.grades).Grade.projects \n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some (c.grades).Grade.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall c : Course | some (c.grades).Grade.projects => some c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  \tall s: Student, c: s.enrolled | s.(c.grades) = last implies lone (s.projects & c.projects)\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n    all s: Student, c: Course | first in s.(c.grades) implies one s.projects & c.projects\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n  all s : Student | all c : Course | some c.grades and first[c.grades] = c.grades[s] implies some p:Project | p in c.projects and p in s.projects\n\n}",
                    "{\n\t// A student with the highest mark in a course must have worked on a project on that course\n\tall s : Student | all c : Course | \n\t\t(some c.grades and c.grades[s] in last[c.grades]) \n\t\timplies \n\t\t(some p : Project | p in c.projects and p in s.projects)\n}"
                ]
            },
            {
                "description": "A student cannot work with the same student in different projects",
                "pred": "this/inv14",
                "oracle": "{\n\t// A student cannot work with the same student in different projects\n\tall disj a, b : Student | lone a.projects & b.projects\n}",
                "erroneous": [
                    "{\n\t// A student cannot work with the same student in different projects\n\n\t\n\t\n        \n\n\tall s1 : Student | all s2 : Student | lone (s1.projects & s2.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1: Student, s2: Student | all disj p1: Project, p2: Project | ((p1 in s1.projects) && (p1 in s2.projects)) implies !( (p2 in s1.projects) && (p2 in s2.projects) )\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n    all s1, s2: Student, p1, p2 : Project | s1 != s2 and p1 in s1.projects and p1 in s2.projects implies ( p2 in s1.projects and p2 not in s2.projects or p2 in s2.projects and p2 not in s1.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1:Student, s2:Student| s1!=s2 and lone(s1.projects & s2.projects)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall s1,s2 : Student | s1 != s2 implies one (s1.projects & s2.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s : Student | all s1 : Student | one (s.projects & s1.projects)\n}",
                    "{\n  all s: Student, s2: Student, p: Project| (s & s2) in (projects.p) and some p2: Project | not(s-> p2 in projects) or not(s2-> p2 in projects)\n\t// A student cannot work with the same student in different projects\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall disj s1, s2 : Student, disj p1, p2 : Project | (p1 in s1.projects and p1 in s2.projects) implies (p2 not in s1.projects and p2 not in s2.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s : Student | one s.projects & s.^(projects)\n}",
                    "{\n    // A student cannot work with the same student in different projects\n    all s1, s2: Student, p1, p2: Project |\n        s1 != s2 and p1 != p2 and p1 in s1.projects and p1 in s2.projects implies \n            (p2 in s1.projects and p2 not in s2.projects)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall p1,p2: Project, s1,s2: Person | s1+s2 in (Person <: projects).p1 implies\n  s1+s2 not in (Person <: projects).p2\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall p1,p2: Project, s1,s2: Person | s1+s2 in (Person <: projects).p1 and s1!=s2 implies s1+s2 not in (Person <: projects).p2\n}",
                    "{\n  all p: Person, p2: Person| no(p.projects & p2.projects) and p in Student and p2 in Student\n\t// A student cannot work with the same student in different projects\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1,s2 : Student | lone p1 : s1.projects | s1 != s2 and p1 not in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1,s2:Student | lone p:Project |\n  \t\tp in s1.projects and p in s2.projects implies (all p2:Project | p2 in s1.projects implies not p2 in s2.projects)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \n  all p1,p2 : Student | some p : Project | p in p1.projects and p in p2.projects implies no pr : Project - p | pr in p1.projects and pr in p2.projects\n\n}",
                    "{\n  all disj s, s1 : Student | all  p  : Project | (p in s.projects and p in s1.projects) implies no p1 : Project | p1 in s.projects and p1 not in s1.projects\n\t// A student cannot work with the same student in different projects\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1,s2 : Student | some p1,p2 : s1.projects | s1 != s2 and p1 in s2.projects and p2 in s2.projects implies p1 = p2\n  \n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s1, s2 : Student | some p : Project | p in (s1.projects & s2.projects) implies p not in (s1.projects & s2.projects) - p\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1, s2: Student, p1, p2: Project | p1 in s1.projects and p2 in s2.projects => p1 = p2 \n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall disj s1,s2 : Student | lone(s1.projects & s1.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s,s1: Student | no(s.enrolled.projects & s1.enrolled.projects)\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n    \n    all disj c1,c2:Course | no (c1.grades & c2.grades)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall s1,s2 :Student | all p1:s1.projects | all p2:s2.projects | p1 = p2 and s1 != s2 implies s1.projects-p1 not in s2.projects -p1\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s: Student, p: s.projects | no (Person-s).projects & p \n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s: Person, p: s.projects | one (Person-s).projects & p \n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s: Person | one (Person-s).projects & s.projects \n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  all s: Person | lone (Person-s).projects & s.projects \n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1, s2: Student | lone s1.projects.~(Course <: projects) & s2.projects.~(Course <: projects)\n}",
                    "{\n  all s: Student, s2: Student, c: Course| no(s.projects & s2.projects) and s != s2\n\t// A student cannot work with the same student in different projects\n\n}",
                    "{\n  all p: Person, p2: Person| no(p.projects & p2.projects) implies (p & p2) in Student\n\t// A student cannot work with the same student in different projects\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1,s2:Student | one p:Project |\n  \t\tp in s1.projects and p in s2.projects implies (all p2:Project | p2 in s1.projects implies not p2 in s2.projects)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1: Student | some s2: Student | lone (s1 & s2).projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tsome s1: Student | some s2: Student | lone (s1 & s2).projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1, s2: Student | one (s1 & s2).projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall s1, s2: Student, p1, p2: Project | (p1 in (s1.enrolled).projects and p1 in (s2.enrolled).projects and p2 in (s1.enrolled).projects and p2 in (s2.enrolled).projects) implies p1=p2\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1, s2: Student | #(s1.projects & s2.projects) > 2\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1,s2:Student | one p1:Project | all p2:Project | p1 in s1.projects and p2 in s2.projects and p2 in s1.projects implies p2 not in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1,s2:Student | one p1:Project | all p2:Project | p1 != p2 and p1 in s1.projects and p2 in s2.projects and p2 in s1.projects implies p2 not in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1,s2:Student | one p1:Project | all p2:Project | p1 != p2 and p1 in s1.projects and p1 in s2.projects and p2 in s1.projects implies p2 not in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1, s2: Student | some p:s1.projects | p not in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1, s2: Student | #({p: Project | p in (s1.projects & s2.projects) and p not in (s1.teaches.projects + s2.teaches.projects)}) <=1  \n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s, t : Student | lone (s.enrolled & t.enrolled)\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1,s2 : Student | all p : s1.projects | lone pro : Project | p in s2.projects implies pro in s1.projects and pro in s2.projects\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall s1, s2: Student, disj p1, p2: Project | p1 in s1.enrolled and p2 in s2.enrolled\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1, s2: Student, p1, p2: Project | p1 in s1.projects and p2 in s2.projects => p1 = p2 \n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall disj s1, s2: Student, p1, p2: Project |\n  \t\tsome p: s1.projects | p in s2.projects implies s1.projects - p != s2.projects - p\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n\tall p1,p2:Person, w1,w2: Project | p1 != p2 and w1 != w2 \n  \t\t\t\t\t\t\t\t\t\tand w1 in p1.projects and w1 in p2.projects implies (p1.projects - w1 & p2.projects - w1 = none )\n  \t\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall s1, s2: Student, c1, c2: Course, p1, p2: Project | s1 in enrolled.c1 and s2 in enrolled.c1 and s1 in enrolled.c2 and s2 in enrolled.c2 and p1 in c1.projects and p2 in c2.projects and p1 in s1.projects and p2 in s2.projects implies c1 = c2 and p1 = p2\n\n}",
                    "{\n\t// A student cannot work with the same student in different projects\n  \tall s1, s2: Student, c: s1.enrolled & s2.enrolled | lone (s1.projects & s2.projects & c.projects)\n}"
                ]
            },
            {
                "description": "Students working on the same project in a course cannot have marks differing by more than one unit",
                "pred": "this/inv15",
                "oracle": "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c : Course, disj x,y : Student, g1 : x.(c.grades), g2 : y.(c.grades) |\n\t  (some c.projects & x.projects & y.projects) implies g1 in g2.(prev+iden+next)\n}",
                "erroneous": [
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course |\n  \t\tsome c.projects & s1.projects & s2.projects implies\n  \t\t\ts1.(c.grades) in s2.(c.grades).(prev+iden+next)\n  \t\t\n  \t\n  \t\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s,s2: Student , p : s.projects & s2.projects, c : Course | p in c.projects implies next[s.(c.grades)]  = s2.(c.grades) or next[s2.(c.grades)] = s.(c.grades) or s.(c.grades) = s2.(c.grades)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all s1, s2 : Student, p : Project, c: Course | s1 != s2 and p in s1.projects and p in s2.projects and p in c.projects implies (all g1, g2 : Grade | g1 in s1.(c.grades) and g2 in s2.(c.grades) implies (g1 = g2 or g1 =  prev[g2] + 1 or g1 + 1 = g2))\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course | some (s1.projects & s2.projects).~projects :> c => gte[s2.(c.grades),prev[s1.(c.grades)]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1,s2 :Student | all p1:s1.projects | all p2:s2.projects | all c:Course |\n  \t\t p1 = p2 and s1 != s2 and p1 in c.projects implies c.grades[s1] = c.grades[s2]  or c.grades[s2] = c.grades[s1] - 1 or c.grades[s1] = c.grades[s2] -1\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person<:projects.p | \n  (s1.((projects.p).grades)) in (s2.((projects.p).grades)).prev\n\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person <: projects.p | \n  (s1.(Course.grades)) + (s2.(Course.grades)) in (s2.(Course.grades)).prev + (s1.(Course.grades)).prev\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2: Student, c: Course | \n  \t\ts1.projects & s2.projects in c.projects\n  \t\timplies (\n  \t\ts1.(c.grades) = s2.(c.grades)+1 or\n  \t\ts1.(c.grades) = s2.(c.grades) or\n  \t\ts1.(c.grades) = s2.(c.grades)-1)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student | \n  \t\ts1.projects & s2.projects != none implies\n  \t\tall g1: s1.(Course.grades), g2: s2.(Course.grades) |\n  \t\t\tg1 = g2 or\n  \t\t\tg1 = g2 + 1 or\n  \t\t\tg1 = prev[g2]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all c : Course | \n  \t\t(c in s1.enrolled&s2.enrolled) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all c : Course, p : Project | \n  \t\t(c in s1.enrolled&s2.enrolled \n          and ( p in (s1.projects&s2.projects) and p in c.projects)) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all c: Course, disj s1,s2: Student , g1: s1.(c.grades) , g2 : s2.(c.grades) | some (s1.projects & s2.projects & c.projects) \n  implies g1 in g2.next + g2.prev\n\n}",
                    "{\n    // Students working on the same project in a course cannot have marks differing by more than one unit\n    all disj s1, s2 : Student | \n  all c : Course, p : Project |\n      (c in s1.enrolled & s2.enrolled and \n      (p in (s1.projects & s2.projects) and \n       p in c.projects)) implies\n        let g1 = c.grades[s1], g2 = c.grades[s2] |\n          g1 = g2 or g1.next = g2 or g2.next = g1\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Student <: projects.p | some s2.(Course.grades) and some s1.(Course.grades) =>\n  (s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student, p: Project | p in s1.projects and p in s2.projects implies (s1.((Course <: projects).p.grades) in (s2.((Course <: projects).p.grades)).(prev + iden + next))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \t\n  \tall disj x,y:Student, c: Course, p:x.projects&y.projects&c.projects |c.grades[x].(prev+iden+next) in c.grades[y]\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all p :s1.projects & s2.projects | s1.((Course <: projects.p).grades) = s2.((Course <: projects.p).grades) or s1.((Course <: projects.p).grades).next = s2.((Course <: projects.p).grades) or s1.((Course <: projects.p).grades) = s2.((Course <: projects.p).grades).next \n\n\n  }",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c: Course | all p: c.projects |\n\t\t all disj x, y: (Person <: projects).p | \n\t\t \tsome x.(c.grades) and some y.(c.grades) => \n\t\t \tnot lt[x.(c.grades), y.(c.grades).prev] and not lt[x.(c.grades).prev, y.(c.grades)]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all c: Course |\n  all p : c.projects |\n  all disj s1,s2: (projects.p & Student) | \n  \t\t\tp in c.projects implies(\n  \t\t\t\t(p in s1.projects and p in s2.projects) implies (c.grades[s1].prev = c.grades[s2] or c.grades[s2].prev = c.grades[s1] or c.grades[s2]=c.grades[s1])\n  \n  \n  \t)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall s1,s2 : Student | all c : Course | \n  \t\t(c in s1.enrolled&s2.enrolled) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n  \tall c : Course | all project : c.projects | all disj p1, p2 : Person <: projects.project | gte[p1.(c.grades), -1 + p2.(c.grades)] or lte[p1.(c.grades), 1 + p2.(c.grades)]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1, s2 : Student | (all p : (s1.projects & s2.projects) | all c : (s1.enrolled & s2.enrolled) | all g1,g2 : Grade | g1 in s1.(c.grades) and g2 in s2.(c.grades))\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2: Student, c: Course | (s1.projects & s2.projects) in c.projects implies s1.(c.grades) = s2.(c.grades) or next[s1.(c.grades)] = s2.(c.grades) or s1.(c.grades) = next[s2.(c.grades)]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2 : Student |\n\t\tsome c : Course |\n\t\t\tsome (c.projects & s1.projects & s2.projects) implies\n\t\t\t\tc.grades[s1] = c.grades[s2] or c.grades[s1] = next[c.grades[s2]] or c.grades[s1] = prev[c.grades[s2]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall c : Course, disj x,y : Student |\n\t  (one c.projects & x.projects & y.projects) implies c.grades[x] in c.grades[y].(prev+iden+next)\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall p : Project | all m : (enrolled.((Course <: projects).p)).(((Course <: projects).p).grades) | some m2 : (enrolled.((Course <: projects).p)).(((Course <: projects).p).grades) | next[m] = m2 or prev[m] = m2\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person <: projects.p | \n  (s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all p :s1.projects & s2.projects | s1.((Course <: projects.p).grades) = s2.((Course <: projects.p).grades)\n\n\n  }",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student, c: Course | \n  \t\t((s1.projects & s2.projects) != none and s1.projects & s2.projects in c.projects and s1.(c.grades)!=none and s2.(c.grades)!=none)\n  \t\timplies (\n          (\n  \t\t\ts1.(c.grades) = s2.(c.grades)+1 or\n  \t\t\ts1.(c.grades) = s2.(c.grades) or\n  \t\t\ts1.(c.grades) = prev[s2.(c.grades)])\n  \t\t)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course | some (s1.projects & s2.projects).~projects :> c => lt[s2.(c.grades),prev[s1.(c.grades)]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \t\n\tall s,s2: Student , p : s.projects & s2.projects, c : Course | \n  \tp in c.projects and some s.(c.grades) and some s2.(c.grades) implies \n  \t(next[s.(c.grades)]  = s2.(c.grades)\n   \tor s.(c.grades) = s2.(c.grades))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n    all disj s1, s2: Student, c: Course | s1.(c.grades) = s2.(c.grades) or s1.(c.grades) = s2.(c.grades).next or s1.(c.grades).next = s2.(c.grades)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all p :s1.projects & s2.projects | s1.((Course <: projects.p).grades) = s2.((Course <: projects.p).grades) or s1.((Course <: projects.p).grades).next = s2.((Course <: projects.p).grades) or s1.((Course <: projects.p).grades) = s2.((Course <: projects.p).grades).next and one(s2.((Course <: projects.p).grades)) and one(s1.((Course <: projects.p).grades))\n\n\n  }",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\t\n  all p : Student, p1 : Student & projects.(p.projects) | no p\n}",
                    "{\n\t\n\tall disj s, s1 : Student | some c : Course | some p : c.projects | p in (s.projects & s1.projects) and (s.(c.grades)).next = s1.(c.grades)\n}",
                    "{\n\t\n\tall disj s, s1 : Student | some c : Course | some p : c.projects | p in (s.projects & s1.projects) and ((s.(c.grades)).next = s1.(c.grades) || (s1.(c.grades)).next = s.(c.grades) || s1.(c.grades) = s.(c.grades))\n}",
                    "{\n\t\n\tall disj s, s1 : Student | some c : Course | some p : c.projects | p in (s.projects & s1.projects) => ((s.(c.grades)).next = s1.(c.grades) || (s1.(c.grades)).next = s.(c.grades) || s1.(c.grades) = s.(c.grades))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c: Course | all p: c.projects |\n\t\t all disj x, y: (Person <: projects).p | not lt[x.(c.grades), y.(c.grades).next] and not lt[x.(c.grades), y.(c.grades).prev]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c: Course | all p: c.projects |\n\t\t all disj x, y: (Person <: projects).p | \n\t\t \tsome x.(c.grades) and some y.(c.grades) => \n\t\t \tnot lt[x.(c.grades), y.(c.grades).next] and not lt[x.(c.grades), y.(c.grades).prev]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all disj s1,s2 : Student | \n  \tlone p : Project |\n  \t\tall c:Course | \n  \t\t\tp in c.projects implies(\n  \t\t\t\t(p in s1.projects and p in s2.projects) implies (c.grades[s1].prev = c.grades[s2] or c.grades[s2].prev = c.grades[s1] or c.grades[s2]=c.grades[s1])\n  \n  \n  \t)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1, s2 : Student, c : Course, p : Project | some s1.projects & s2.projects & c.projects implies one (s1.(c.grades) - s2.(c.grades))\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p: Project | all s1, s2: (Person<:projects).p | \n  \t\tlet g1 = s1.(Course.grades) |\n  \t\tlet g2 = s2.(Course.grades) |\n  \t\tall g11: g1, g22: g2 | g11.prev in g22 or g11.next in g22\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p: Project | all s1, s2: (Person<:projects).p | \n  \t\tlet g1 = s1.(Course.grades) |\n  \t\tlet g2 = s2.(Course.grades) |\n  \t\tall g11: g1, g22: g2 | g11.prev = g22 or g11.next = g22\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p: Project | all s1, s2: (Person<:projects).p | \n  \t\ts1 != s2 implies\n  \t\tlet g1 = s1.(Course.grades) |\n  \t\tlet g2 = s2.(Course.grades) |\n  \t\tall g11: g1, g22: g2 | g11.prev = g22 or g11.next = g22\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p: Project | all s1, s2: (Person<:projects).p | \n  \t\ts1 != s2 implies\n  \t\tlet g1 = s1.(Course.grades) |\n  \t\tlet g2 = s2.(Course.grades) |\n  \t\tall g11: g1, g22: g2 | g11.prev = g22 or g11.next = g22 or g11 = g22\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | some c : Course | \n  \t\t(c in s1.enrolled&s2.enrolled and some c.projects) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | some c : Course | \n  \t\t(c in s1.enrolled&s2.enrolled) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | one c : Course | \n  \t\t(c in s1.enrolled&s2.enrolled) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | all c : Course, p : Project | \n  \t\t(c in s1.enrolled&s2.enrolled \n          and ( p in (s1.projects&s2.projects))) implies \n\t\t(c.grades[s1].next = c.grades[s2] or c.grades[s1].prev = c.grades[s2] )\n\n}",
                    "{\n  \tall c : Course | all project : c.projects | all person : Person <: projects.project | project = person\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student, c: Course | some s1.projects & s2.projects & c.projects implies s1.(c.grades) in (s2.(c.grades) +s2.(c.grades).next)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1,s2 :Student | all p1:s1.projects | all p2:s2.projects | all c:Course |\n  \t\t p1 = p2 and s1 != s2 and p1 in c.projects implies c.grades[s1] - c.grades[s2] = 1 or c.grades[s2] - c.grades[s1] = 1 or c.grades[s1] - c.grades[s2] = 0\n}",
                    "{\n  \t\n  all c: Course | all p: c.projects | all disj p1,p2: Person<:projects.p | lte[p1.(c.grades)-1,p2.(c.grades)] or lte[p2.(c.grades)-1,p1.(c.grades)]\n}",
                    "{\n  \t\n  all c: Course | all p: c.projects | all disj p1,p2: Person<:projects.p | all g1:p1.(c.grades), g2:p2.(c.grades) | lte[g1,g2+1] or lte[g2,g1+1]\n}",
                    "{\n  \t\n  all c: Course | all p: c.projects | all disj p1,p2: Person<:projects.p | p1 in Student and p2 in Student implies (all g1:p1.(c.grades), g2:p2.(c.grades) | lte[g1,g2+1] or lte[g2,g1+1])\n}",
                    "{\n  \t\n  all c: Course | all disj s1,s2: Student | (s1 in enrolled.c and s2 in enrolled.c ) implies (all p:c.projects | (s1 in projects.p and s2 in projects.p) implies lte[s1.(c.grades) - 1,s2.(c.grades)] )\n}",
                    "{\n  \t\n  all c: Course | all disj s1,s2: Student | (s1 in enrolled.c and s2 in enrolled.c ) implies (all p:c.projects | (s1 in projects.p and s2 in projects.p) implies lte[s1.(c.grades) + 1,s2.(c.grades)] )\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n    all disj s1, s2: Student, c : Course |\n        (some s1.projects & s2.projects & c.projects)\n        implies (\n               grades[c][s1] = grades[c][s2]\n            or grades[c][s1] = grades[c][s2].prev\n            or grades[c][s1] = grades[c][s2].next\n        )\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1, s2 : Student | (all c : (s1.enrolled & s2.enrolled) | some (s1.projects & s2.projects & c.projects) implies (all g1,g2:  (s1.(c.grades) & s2.(c.grades)) | (g1=prev[g2] or g2=prev[g1] or g1=g2)))\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall disj s1,s2 : Student | some c : Course | some p : Project | p in s1.projects & s2.projects and p in c.projects implies c.grades[s1] = c.grades[s2] - 1\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall p: Project | all disj s1, s2: Student {\n  \t\tlet c = { c: Course | p in c.projects } | {\n          \tp in s1.projects\n          \tp in s2.projects\n      \t} implies {\n      \t\t(c.grades[s1] -> c.grades[s2] in prev) or (c.grades[s2] -> c.grades[s1] in prev)\n      \t}\n  \t}\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall p: Project | all disj s1, s2: Student {\n  \t\tlet c = { c: Course | p in c.projects } | {\n          \tp in s1.projects\n          \tp in s2.projects\n      \t} implies {\n      \t\tc.grades[s1] = c.grades[s2] or some (c.grades[s1] -> c.grades[s2] + c.grades[s2] -> c.grades[s1]) & prev\n      \t}\n  \t}\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c : Course, p : c.projects, s1, s2 : Student | (p in (s1.projects & s2.projects)) implies lone s1.(c.grades).prevs - s2.(c.grades).prevs\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \t\n\tall disj s,s2: Student |\n  \t\tall c : s.enrolled & s2.enrolled | \n  \n  \t\t\t\tsome s.(c.grades) and some s2.(c.grades) implies\n  \t\t\t\t\t(next[s.(c.grades) ] = s2.(c.grades) or\n                     next[s2.(c.grades)] = s.(c.grades) or\n                      s.(c.grades) = s2.(c.grades))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\t\tall s1, s2: Student, c: s1.enrolled | (s1.projects & s2.projects) in c.projects implies s1.(c.grades) = s2.(c.grades) or next[s1.(c.grades)] = s2.(c.grades) or s1.(c.grades) = next[s2.(c.grades)]\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\t\tall s1, s2: Student, c: (s1.enrolled & s2.enrolled) | (s1.projects & s2.projects) in c.projects implies s1.(c.grades) = s2.(c.grades) or next[s1.(c.grades)] = s2.(c.grades) or s1.(c.grades) = next[s2.(c.grades)]\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\t\tall s1, s2: Student, c: (s1.enrolled & s2.enrolled) | (s1.projects & s2.projects) in c.projects and some s1.(c.grades) and some s2.(c.grades) implies s1.(c.grades) = s2.(c.grades) or next[s1.(c.grades)] = s2.(c.grades) or s1.(c.grades) = next[s2.(c.grades)]\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \t\n\tall s,s2: Student , c : Course | \n  \t s.projects & s2.projects in c.projects and some s.(c.grades) and some s2.(c.grades) implies \n  \t(next[s.(c.grades)]  = s2.(c.grades) or next[s2.(c.grades)] = s.(c.grades) \n   \tor s.(c.grades) = s2.(c.grades))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student,\n  \t\tc : (s1.enrolled & s2.enrolled),\n  \t\tp : c.projects & s1.projects & s2.projects |\n  \t\t\ts1.(c.grades) in s2.(c.grades).(prev+iden+next)\n  \t\t\n  \t\n  \t\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall c : Course, disj x,y : Student |\n\t  (lone c.projects & x.projects & y.projects) implies c.grades[x] in c.grades[y].(prev+iden+next)\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student ,\n  \t\tp : s1.projects & s2.projects ,\n  \t\tc : Course <: projects.p |\n  \t\t\tsome s1.(c.grades) and some s2.(c.grades) implies \n\t\t\t\ts1.(c.grades).(prev+iden+next) in s2.(c.grades)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2: Student | all c: Course |\n        (c in s1.enrolled and c in s2.enrolled and some (s1.projects & s2.projects)) implies\n        let g1 = c.grades[s1], g2 = c.grades[s2] |\n        g1 = g2 or g1 = next[g2] or g2 = next[g1]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2 : Student |\n\t\tsome c : Course |\n\t\t\tsome (c.projects & s1.projects & s2.projects) implies\n\t\t\t\tc.grades[s1] = c.grades[s2]\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2 : Student |\n\t\tsome c : Course |\n\t\t\tsome (c.projects & s1.projects & s2.projects) implies\n\t\t\t\tc.grades[s1] = c.grades[s2] or c.grades[s1] = next[c.grades[s2]] or c.grades[s2] = next[c.grades[s1]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student |\n\t\tsome c : Course |\n\t\t\tsome (c.projects & s1.projects & s2.projects) implies\n\t\t\t\tc.grades[s1] = c.grades[s2] or c.grades[s1] = next[c.grades[s2]] or c.grades[s2] = next[c.grades[s1]]\n}",
                    "{\n    // Students working on the same project in a course cannot have marks differing by more than one unit\n    all s1, s2: Student |\n        all c: Course |\n            some (c.projects & s1.projects & s2.projects) implies\n                c.grades[s1] = c.grades[s2] or lt[c.grades[s1], c.grades[s2]] or lt[c.grades[s2], c.grades[s1]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall c: Course | all p: Project | all disj s1, s2: Student | \n  \t\tp in s1.projects and\n  \t\tp in s2.projects and\n  \t\tp in c.projects implies\n  \t\t(\n          c.grades[s1] = c.grades[s2].next or\n          c.grades[s2] = c.grades[s1].next\n        )\n  \n  \n\n\n\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course | one p : Project | p in s1.projects & s2.projects and p in c.projects implies s1.(c.grades) in s2.(c.grades).(prev + iden + next)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student | one c : Course, p : Project | p in s1.projects & s2.projects and p in c.projects implies s1.(c.grades) in s2.(c.grades).(prev + iden + next)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student | one c : Course | one s1.projects & s2.projects & c.projects implies s1.(c.grades) in s2.(c.grades).(prev + iden + next)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s, s1: Student | all p: Project | all c: Course | s != s1 and  p in s.projects and p in s1.projects and p in c.projects and some s.(c.grades) and some s.(c.grades) implies ( next[s1.(c.grades)] = s.(c.grades) or not next[s.(c.grades)] = s1.(c.grades) or  s.(c.grades) = s1.(c.grades) )\n\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all s,s2: Student | all p : Project | p in s.projects and p in s2.projects and  all c : Course |   p in c.projects and some s.(c.grades) and some s2.(c.grades) implies \n  \t(next[s.(c.grades)]  = s2.(c.grades) or next[s2.(c.grades)] = s.(c.grades) \n   \tor s.(c.grades) = s2.(c.grades))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student ,\n  \t\tc : s1.enrolled & s2.enrolled |\n  \t\t\tsome s1.(c.grades) and some s2.(c.grades) implies\n  \t\t\t\ts1.(c.grades) in s2.(c.grades).(prev+iden+next)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  some p:Project | all s1,s2:Student | s1+s2 in projects.p => \n  (s1.((projects.p).grades)) in (s2.((projects.p).grades)).prev\n\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, s1,s2:Student | s1+s2 in projects.p => \n  (s1.((projects.p).grades)) in (s2.((projects.p).grades)).prev\n\t\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person <: projects.p | \n  (s1.(Course.grades)) in (s2.(Course.grades)).prev or (s2.(Course.grades)) in (s1.(Course.grades)).prev\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person <: projects.p | \n  (s1.(Course.grades)) in ((s2.(Course.grades)).prev + (s2.(Course.grades)))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Person <: projects.p | some s2.(Course.grades) =>\n  (s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  some p:Project, disj s1,s2: Person <: projects.p | some s2.(Course.grades) =>\n  (s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Student <: projects.p | some (s1+s2).(Course.grades) =>\n  (s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  all p:Project, disj s1,s2: Student <: projects.p |\n  \tsome s2.((projects.p).grades) =>\n  \t\t(s1.(Course.grades)) in s2.(Course.grades).(prev + iden + next) \n}",
                    "{\n    // Students working on the same project in a course cannot have marks differing by more than one unit\n    all disj s1, s2: Student | \n        some p: s1.projects & s2.projects | \n            all c: Course | \n                p in c.projects => \n                    s1.grades[c] = s2.grades[c] or \n                    s1.grades[c] in next[s2.grades[c]] or \n                    s2.grades[c] in next[s1.grades[c]]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course, p : Project | \n  \t\tp in (s1.projects & s2.projects & c.projects) implies\n  \t\t\tsome s1.(c.grades) and \n  \t\t\tsome s2.(c.grades) and\n  \t\t\ts1.(c.grades) in (s2.(c.grades).(prev + iden + next))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \n  all disj x,y:Student, c:Course | one p : x.projects & y.projects| x->c in enrolled and y->c in enrolled and c->p in projects implies x.(c.grades) = y.(c.grades)\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\n  all disj x,y:Student, c:Course, g1: x.(c.grades), g2:y.(c.grades) | (lone c.projects & x.projects & y.projects) implies g1=g2\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student |\n  \t\tall p: Project |\n  \t\t\t(p in s1.projects and p in s2.projects) implies \n  \t\t\t\t(one c: Course |\n  \t\t\t\t\tp in c.projects and \n  \t\t\t\t\t(c.grades[s1] = c.grades[s2] or\n                      c.grades[s1] = next[c.grades[s2]]\n                      or c.grades[s2] = next[c.grades[s1]]))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student |\n  \t\tall p: Project |\n  \t\t\t(p in s1.projects and p in s2.projects) implies \n  \t\t\t\t(some c: Course |\n  \t\t\t\t\tp in c.projects and \n  \t\t\t\t\t(c.grades[s1] = c.grades[s2] or\n                      c.grades[s1] = next[c.grades[s2]]\n                      or c.grades[s2] = next[c.grades[s1]]))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall s1, s2: Student |\n  \t\tall p: Project |\n  \t\t\t(p in s1.projects and p in s2.projects) implies \n  \t\t\t\t(some c: Course |\n  \t\t\t\t\tp in c.projects and \n  \t\t\t\t\t(c.grades[s1] = c.grades[s2] or\n                      c.grades[s1] = next[c.grades[s2]]\n                      or c.grades[s2] = next[c.grades[s1]]))\n}",
                    "{\n\t    all c: Course |\n        all p: Project |\n            p in c.projects =>\n                all disj s1, s2: Student |\n                    (p in s1.projects and p in s2.projects) =>\n                        let g1 = c.grades[s1], g2 = c.grades[s2] |\n                            g1 != none and g2 != none and \n                            (g1 = g2 or g1 in g2.~next or g2 in g1.~next)\n}",
                    "{\n\t    all c: Course |\n        all p: Project |\n            (p in c.projects and \n             some disj s1, s2: Student | \n                (p in s1.projects and p in s2.projects and \n                 ((c.grades[s1] = next[c.grades[s2]]) or \n                  (c.grades[s2] = next[c.grades[s1]]) or \n                  (c.grades[s1] = c.grades[s2]))))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student |\n  \t\t(all p: Project | p in s1.projects and p in s2.projects implies (\n                some c: Course | \n                    p in c.projects and \n                    s1 in c.grades.Person and \n                    s2 in c.grades.Person and \n                     (\n                        c.grades[s1] = c.grades[s2] or \n                        c.grades[s1] = next[c.grades[s2]] or \n                        c.grades[s2] = next[c.grades[s1]]\n                    )))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student |\n  \t\t(all p: Project | p in s1.projects and p in s2.projects implies (\n                some c: Course | \n                    p in c.projects and \n                    s1 in c.grades.Grade and \n                    s2 in c.grades.Grade and \n                     (\n                        c.grades[s1] = c.grades[s2] or \n                        c.grades[s1] = next[c.grades[s2]] or \n                        c.grades[s2] = next[c.grades[s1]]\n                    )))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student, c: Course | \n  \t\t(s1.projects & s2.projects) != none and s1.projects & s2.projects in c.projects\n  \t\timplies (\n  \t\ts1.(c.grades) = s2.(c.grades)+1 or\n  \t\ts1.(c.grades) = s2.(c.grades) or\n  \t\ts1.(c.grades) = prev[s2.(c.grades)])\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student, c: Course | \n  \t\t(s1.projects & s2.projects) != none and s1.projects & s2.projects in c.projects\n  \t\timplies (s1.(c.grades)!=none and s2.(c.grades)!=none and (\n  \t\ts1.(c.grades) = s2.(c.grades)+1 or\n  \t\ts1.(c.grades) = s2.(c.grades) or\n  \t\ts1.(c.grades) = prev[s2.(c.grades)]))\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2: Student | \n  \t\ts1.projects & s2.projects != none implies\n  \t\tall g1: s1.(Course.grades) | all g2: s2.(Course.grades) |\n  \t\t\tg1 = g2 or\n  \t\t\tg1 = next[g2] or\n  \t\t\tg1 = prev[g2]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course | some (s1.projects & s2.projects).~projects :> c => gt[s2.(c.grades),s1.(c.grades).prev]\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n\tall disj s1, s2 : Student, c : Course | (some (s1.projects & s2.projects).~projects :> c) => gte[s2.(c.grades),s1.(c.grades).prev] && s2.(c.grades) not = none\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall s1, s2: Student, c: s1.enrolled & s2.enrolled | one (s1.projects & s2.projects & c.projects) implies s1.(c.grades) = 0\n}",
                    "{\n\t// Students working on the same project in a course cannot have marks differing by more than one unit\n  \tall s1, s2: Student, c: s1.enrolled & s2.enrolled | one (s1.projects & s2.projects & c.projects) implies s1.(c.grades) = s2.(c.grades)\n}"
                ]
            }
        ]
    }
]